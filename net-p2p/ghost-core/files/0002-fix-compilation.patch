From 472d63c04b9c71e8a18f2733e1128b06e5f755b1 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Fri, 14 Jan 2022 18:29:33 +0200
Subject: [PATCH 01/57] tests: Backport Particl taproot verification test

---
 src/Makefile.test.include          |   3 +-
 src/test/data/particl_taproot.json |   8 ++
 src/test/particlchain_tests.cpp    | 122 ++++++++++++++++++++++++++++-
 3 files changed, 131 insertions(+), 2 deletions(-)
 create mode 100644 src/test/data/particl_taproot.json

diff --git a/src/Makefile.test.include b/src/Makefile.test.include
index 390168253d..7707822a93 100644
--- a/src/Makefile.test.include
+++ b/src/Makefile.test.include
@@ -181,7 +181,8 @@ JSON_TEST_FILES = \
   test/data/tx_valid.json \
   test/data/bip39_vectors_english.json \
   test/data/bip39_vectors_japanese.json \
-  test/data/ringct.json
+  test/data/ringct.json \
+  test/data/particl_taproot.json
 
 RAW_TEST_FILES = \
   test/data/asmap.raw
diff --git a/src/test/data/particl_taproot.json b/src/test/data/particl_taproot.json
new file mode 100644
index 0000000000..ab41455b53
--- /dev/null
+++ b/src/test/data/particl_taproot.json
@@ -0,0 +1,8 @@
+[
+"a0000000000000010100e1f50500000000225120d389aadb4285875825cb9cfdc0304e08b152586c62d82c0ee5d281b067da4f2a",
+"a00000000000010afe3791b07f26eeb63ede60fac69d6e1c2056d710980abda67e8fcc4fc7fb960000000000ffffffff010130d9f50500000000225120d389aadb4285875825cb9cfdc0304e08b152586c62d82c0ee5d281b067da4f2a00",
+"a00000000000010afe3791b07f26eeb63ede60fac69d6e1c2056d710980abda67e8fcc4fc7fb960000000000ffffffff010130d9f50500000000225120d389aadb4285875825cb9cfdc0304e08b152586c62d82c0ee5d281b067da4f2a01410c299a98a2a496994000cb9c679f732c99fb60ef29c1ee6142d72c36508c4487633cd65d964fda655d72de43c016a31d7660ff035c48f7067a464c42b837a3d701",
+"a0000000000000010100e1f50500000000225120d847322c4e9593a0cca9316ab1e93d86469e57159416b76f6403d5893d9cde56",
+"a003000000000127e40b4351a19b9682af4c304d9c634afb983ab85d9aace0d46001e04e93265f0000000000ffffffff0204040100000001d0e8f50500000000225120d847322c4e9593a0cca9316ab1e93d86469e57159416b76f6403d5893d9cde560341c451c5c81cd4543f005f7f3fc9c2b7fac0275b9c18eef81c2aad1dc3cf6d2f5309f29c680d1ca90ddbde46a5060c1d380734eea1700a550bf87a65ac6e5080840124b869207e399dc498c71690c9b881c496fb540bd536e38378ea6075cae8189f6afbc281ac21c1ea63ec5443c1fda86078d0b32aba11b7317bc9852d0cfac1908f0d69ae4a97cd",
+"a002000000000127e40b4351a19b9682af4c304d9c634afb983ab85d9aace0d46001e04e93265f0000000000ffffffff0204040100000001d0e8f50500000000225120d847322c4e9593a0cca9316ab1e93d86469e57159416b76f6403d5893d9cde560341c451c5c81cd4543f005f7f3fc9c2b7fac0275b9c18eef81c2aad1dc3cf6d2f5309f29c680d1ca90ddbde46a5060c1d380734eea1700a550bf87a65ac6e5080840124b869207e399dc498c71690c9b881c496fb540bd536e38378ea6075cae8189f6afbc281ac21c1ea63ec5443c1fda86078d0b32aba11b7317bc9852d0cfac1908f0d69ae4a97cd"
+]
diff --git a/src/test/particlchain_tests.cpp b/src/test/particlchain_tests.cpp
index 3fc345f3b1..47f655d4dc 100644
--- a/src/test/particlchain_tests.cpp
+++ b/src/test/particlchain_tests.cpp
@@ -1,4 +1,4 @@
-// Copyright (c) 2017-2021 The Particl Core developers
+// Copyright (c) 2017-2022 The Particl Core developers
 // Distributed under the MIT software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
@@ -16,9 +16,18 @@
 
 #include <script/sign.h>
 #include <policy/policy.h>
+#include <test/data/particl_taproot.json.h>
+#include <core_io.h>
+#include <univalue.h>
 
 #include <boost/test/unit_test.hpp>
 
+extern UniValue read_json(const std::string& jsondata);
+
+bool CheckInputScripts(const CTransaction& tx, TxValidationState& state,
+                       const CCoinsViewCache& inputs, unsigned int flags, bool cacheSigStore,
+                       bool cacheFullScriptStore, PrecomputedTransactionData& txdata,
+                       std::vector<CScriptCheck> *pvChecks, bool fAnonChecks = true) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
 
 BOOST_FIXTURE_TEST_SUITE(particlchain_tests, ParticlBasicTestingSetup)
 
@@ -445,4 +454,115 @@ BOOST_AUTO_TEST_CASE(coin_year_reward)
     BOOST_CHECK(Params().GetCoinYearReward(1626109200 + seconds_in_year * 6) == 6 * CENT);
 }
 
+BOOST_AUTO_TEST_CASE(taproot)
+{
+    // Import txns from version 22.x
+    UniValue test_txns = read_json(
+        std::string(json_tests::particl_taproot,
+        json_tests::particl_taproot + sizeof(json_tests::particl_taproot)));
+
+    unsigned int flags = SCRIPT_VERIFY_P2SH;
+    flags |= SCRIPT_VERIFY_DERSIG;
+    flags |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;
+    flags |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;
+    flags |= SCRIPT_VERIFY_WITNESS;
+    flags |= SCRIPT_VERIFY_NULLDUMMY;
+
+    unsigned int flags_with_taproot = flags | SCRIPT_VERIFY_TAPROOT;
+
+    CAmount txfee_out;
+    int nSpendHeight = 1;
+
+    // Test signing with the internal pubkey
+    {
+    CCoinsView viewDummy;
+    CCoinsViewCache inputs(&viewDummy);
+
+    CMutableTransaction mtx1;
+    BOOST_CHECK(DecodeHexTx(mtx1, test_txns[0].get_str()));
+    CTransaction tx1(mtx1);
+
+    AddCoins(inputs, tx1, 1);
+
+    CMutableTransaction mtx2;
+    BOOST_CHECK(DecodeHexTx(mtx2, test_txns[1].get_str()));
+    CTransaction tx2(mtx2);
+
+    TxValidationState state;
+    bool rv = Consensus::CheckTxInputs(tx2, state, inputs, nSpendHeight, txfee_out);
+    BOOST_CHECK(rv);
+
+    {
+    // Without SCRIPT_VERIFY_TAPROOT prevout defaults to spendable
+    LOCK(cs_main);
+    PrecomputedTransactionData txdata;
+    bool ret = CheckInputScripts(tx2, state, inputs, flags, /* cacheSigStore */ false, /* cacheFullScriptStore */ false, txdata, nullptr);
+    BOOST_CHECK(ret);
+    }
+
+    {
+    // With SCRIPT_VERIFY_TAPROOT prevout must pass verification
+    LOCK(cs_main);
+    PrecomputedTransactionData txdata;
+    bool ret = CheckInputScripts(tx2, state, inputs, flags_with_taproot, /* cacheSigStore */ false, /* cacheFullScriptStore */ false, txdata, nullptr);
+    BOOST_CHECK(!ret);
+    }
+
+    {
+    TxValidationState state;
+    CMutableTransaction mtx3;
+    BOOST_CHECK(DecodeHexTx(mtx3, test_txns[2].get_str()));
+    CTransaction tx3(mtx3);
+
+    LOCK(cs_main);
+    PrecomputedTransactionData txdata;
+    bool ret = CheckInputScripts(tx3, state, inputs, flags_with_taproot, /* cacheSigStore */ false, /* cacheFullScriptStore */ false, txdata, nullptr);
+    BOOST_CHECK(ret);
+    }
+    }
+
+    // Test signing a script path
+    {
+    CCoinsView viewDummy;
+    CCoinsViewCache inputs(&viewDummy);
+
+    CMutableTransaction mtx4;
+    BOOST_CHECK(DecodeHexTx(mtx4, test_txns[3].get_str()));
+    CTransaction tx4(mtx4);
+
+    AddCoins(inputs, tx4, 1);
+
+    {
+    // Should fail as !IsCoinStake()
+    TxValidationState state;
+    CMutableTransaction mtx5;
+    BOOST_CHECK(DecodeHexTx(mtx5, test_txns[4].get_str()));
+    CTransaction tx5(mtx5);
+
+    LOCK(cs_main);
+    PrecomputedTransactionData txdata;
+    bool ret = CheckInputScripts(tx5, state, inputs, flags_with_taproot, /* cacheSigStore */ false, /* cacheFullScriptStore */ false, txdata, nullptr);
+    BOOST_CHECK(!ret);
+    BOOST_CHECK(state.GetRejectReason() == "non-mandatory-script-verify-flag (Script failed an OP_VERIFY operation)");
+
+    // Should pass without SCRIPT_VERIFY_TAPROOT
+    bool ret_without_taproot = CheckInputScripts(tx5, state, inputs, flags, /* cacheSigStore */ false, /* cacheFullScriptStore */ false, txdata, nullptr);
+    BOOST_CHECK(ret_without_taproot);
+    }
+
+    {
+    // Should pass
+    TxValidationState state;
+    CMutableTransaction mtx6;
+    BOOST_CHECK(DecodeHexTx(mtx6, test_txns[5].get_str()));
+    CTransaction tx6(mtx6);
+
+    LOCK(cs_main);
+    PrecomputedTransactionData txdata;
+    bool ret = CheckInputScripts(tx6, state, inputs, flags_with_taproot, /* cacheSigStore */ false, /* cacheFullScriptStore */ false, txdata, nullptr);
+    BOOST_CHECK(ret);
+    }
+    }
+}
+
 BOOST_AUTO_TEST_SUITE_END()

From 956aba8158d7dca5aa2b316c050bc46f7343dde7 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Fri, 14 Jan 2022 23:51:45 +0200
Subject: [PATCH 02/57] tests: Test OP_CHECKSIGADD

---
 src/test/data/particl_taproot.json |  5 +++-
 src/test/particlchain_tests.cpp    | 41 ++++++++++++++++++++++++++++++
 2 files changed, 45 insertions(+), 1 deletion(-)

diff --git a/src/test/data/particl_taproot.json b/src/test/data/particl_taproot.json
index ab41455b53..bf6eda7bef 100644
--- a/src/test/data/particl_taproot.json
+++ b/src/test/data/particl_taproot.json
@@ -4,5 +4,8 @@
 "a00000000000010afe3791b07f26eeb63ede60fac69d6e1c2056d710980abda67e8fcc4fc7fb960000000000ffffffff010130d9f50500000000225120d389aadb4285875825cb9cfdc0304e08b152586c62d82c0ee5d281b067da4f2a01410c299a98a2a496994000cb9c679f732c99fb60ef29c1ee6142d72c36508c4487633cd65d964fda655d72de43c016a31d7660ff035c48f7067a464c42b837a3d701",
 "a0000000000000010100e1f50500000000225120d847322c4e9593a0cca9316ab1e93d86469e57159416b76f6403d5893d9cde56",
 "a003000000000127e40b4351a19b9682af4c304d9c634afb983ab85d9aace0d46001e04e93265f0000000000ffffffff0204040100000001d0e8f50500000000225120d847322c4e9593a0cca9316ab1e93d86469e57159416b76f6403d5893d9cde560341c451c5c81cd4543f005f7f3fc9c2b7fac0275b9c18eef81c2aad1dc3cf6d2f5309f29c680d1ca90ddbde46a5060c1d380734eea1700a550bf87a65ac6e5080840124b869207e399dc498c71690c9b881c496fb540bd536e38378ea6075cae8189f6afbc281ac21c1ea63ec5443c1fda86078d0b32aba11b7317bc9852d0cfac1908f0d69ae4a97cd",
-"a002000000000127e40b4351a19b9682af4c304d9c634afb983ab85d9aace0d46001e04e93265f0000000000ffffffff0204040100000001d0e8f50500000000225120d847322c4e9593a0cca9316ab1e93d86469e57159416b76f6403d5893d9cde560341c451c5c81cd4543f005f7f3fc9c2b7fac0275b9c18eef81c2aad1dc3cf6d2f5309f29c680d1ca90ddbde46a5060c1d380734eea1700a550bf87a65ac6e5080840124b869207e399dc498c71690c9b881c496fb540bd536e38378ea6075cae8189f6afbc281ac21c1ea63ec5443c1fda86078d0b32aba11b7317bc9852d0cfac1908f0d69ae4a97cd"
+"a002000000000127e40b4351a19b9682af4c304d9c634afb983ab85d9aace0d46001e04e93265f0000000000ffffffff0204040100000001d0e8f50500000000225120d847322c4e9593a0cca9316ab1e93d86469e57159416b76f6403d5893d9cde560341c451c5c81cd4543f005f7f3fc9c2b7fac0275b9c18eef81c2aad1dc3cf6d2f5309f29c680d1ca90ddbde46a5060c1d380734eea1700a550bf87a65ac6e5080840124b869207e399dc498c71690c9b881c496fb540bd536e38378ea6075cae8189f6afbc281ac21c1ea63ec5443c1fda86078d0b32aba11b7317bc9852d0cfac1908f0d69ae4a97cd",
+"a0000000000000010100e1f505000000002251201e8b4519203d30fd779e91f83600fa1b02f55b07e0bfabbdc3701a9ad7d7c3b6",
+"a002000000000162f33a5c29180bcd227eedca82b47c7fa4ba4112bdcd2410bfd93c3201220ec30000000000ffffffff0204040100000001d0e8f505000000002251201e8b4519203d30fd779e91f83600fa1b02f55b07e0bfabbdc3701a9ad7d7c3b60441783d92db81217c070a25f25bac93e8a3f72191b828c27ad3533fe5c83478f71cbecfe4bbeb7db1709cd3833952b27d516194049a015f045b28a361facfe619e60141783d92db81217c070a25f25bac93e8a3f72191b828c27ad3533fe5c83478f71cbecfe4bbeb7db1709cd3833952b27d516194049a015f045b28a361facfe619e60146204f76429304c1792ae7c582b6f149aefe700de75b2457f47315fa9cd354779ec5ac2024e0415fa01d9e2dc12ecb93010bf80fd05ccad09d874cf671f815bc311a6378ba529c21c01dc7f723ee33b364b3b08dc6e2e88a4e21484409541f64306ab35d5720ca0c56",
+"a002000000000162f33a5c29180bcd227eedca82b47c7fa4ba4112bdcd2410bfd93c3201220ec30000000000ffffffff0204040100000001d0e8f505000000002251201e8b4519203d30fd779e91f83600fa1b02f55b07e0bfabbdc3701a9ad7d7c3b60441080971ae4ecb000c723674d3f118b4ffea21fb6759d363ab1e201175dafea297a77de5928a04c0cedd2cea98431d1948c4e5cff59b17f1541d32195646c175400141783d92db81217c070a25f25bac93e8a3f72191b828c27ad3533fe5c83478f71cbecfe4bbeb7db1709cd3833952b27d516194049a015f045b28a361facfe619e60146204f76429304c1792ae7c582b6f149aefe700de75b2457f47315fa9cd354779ec5ac2024e0415fa01d9e2dc12ecb93010bf80fd05ccad09d874cf671f815bc311a6378ba529c21c01dc7f723ee33b364b3b08dc6e2e88a4e21484409541f64306ab35d5720ca0c56"
 ]
diff --git a/src/test/particlchain_tests.cpp b/src/test/particlchain_tests.cpp
index 47f655d4dc..1c2bb0a653 100644
--- a/src/test/particlchain_tests.cpp
+++ b/src/test/particlchain_tests.cpp
@@ -461,6 +461,8 @@ BOOST_AUTO_TEST_CASE(taproot)
         std::string(json_tests::particl_taproot,
         json_tests::particl_taproot + sizeof(json_tests::particl_taproot)));
 
+    BOOST_CHECK(!IsOpSuccess(OP_ISCOINSTAKE));
+
     unsigned int flags = SCRIPT_VERIFY_P2SH;
     flags |= SCRIPT_VERIFY_DERSIG;
     flags |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;
@@ -563,6 +565,45 @@ BOOST_AUTO_TEST_CASE(taproot)
     BOOST_CHECK(ret);
     }
     }
+
+    // OP_CHECKSIGADD
+    {
+        CCoinsView viewDummy;
+        CCoinsViewCache inputs(&viewDummy);
+
+        CMutableTransaction mtx7;
+        BOOST_CHECK(DecodeHexTx(mtx7, test_txns[6].get_str()));
+        CTransaction tx7(mtx7);
+        AddCoins(inputs, tx7, 1);
+
+        {
+        // Should fail as sig2 is invalid
+        TxValidationState state;
+        CMutableTransaction mtx8;
+        BOOST_CHECK(DecodeHexTx(mtx8, test_txns[7].get_str()));
+        CTransaction tx8(mtx8);
+        LOCK(cs_main);
+        PrecomputedTransactionData txdata;
+        bool ret = CheckInputScripts(tx8, state, inputs, flags_with_taproot, /* cacheSigStore */ false, /* cacheFullScriptStore */ false, txdata, nullptr);
+        BOOST_CHECK(!ret);
+        BOOST_CHECK(state.GetRejectReason() == "non-mandatory-script-verify-flag (Invalid Schnorr signature)");
+
+        // Should pass without SCRIPT_VERIFY_TAPROOT
+        bool ret_without_taproot = CheckInputScripts(tx8, state, inputs, flags, /* cacheSigStore */ false, /* cacheFullScriptStore */ false, txdata, nullptr);
+        BOOST_CHECK(ret_without_taproot);
+        }
+
+        {
+        TxValidationState state;
+        CMutableTransaction mtx9;
+        BOOST_CHECK(DecodeHexTx(mtx9, test_txns[8].get_str()));
+        CTransaction tx9(mtx9);
+        LOCK(cs_main);
+        PrecomputedTransactionData txdata;
+        bool ret = CheckInputScripts(tx9, state, inputs, flags_with_taproot, /* cacheSigStore */ false, /* cacheFullScriptStore */ false, txdata, nullptr);
+        BOOST_CHECK(ret);
+        }
+    }
 }
 
 BOOST_AUTO_TEST_SUITE_END()

From c61f88c64084c8fd1a898a51be834a5277f63975 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Sun, 16 Jan 2022 15:55:33 +0200
Subject: [PATCH 03/57] Add TX_WITNESS_V1_TAPROOT to AreInputsStandard.

---
 src/policy/policy.cpp           | 22 ++++++++++++++++------
 src/test/particlchain_tests.cpp | 12 ++++++++++++
 2 files changed, 28 insertions(+), 6 deletions(-)

diff --git a/src/policy/policy.cpp b/src/policy/policy.cpp
index 4e04e665e4..a7338f03ae 100644
--- a/src/policy/policy.cpp
+++ b/src/policy/policy.cpp
@@ -241,8 +241,9 @@ bool IsStandardTx(const CTransaction& tx, bool permit_bare_multisig, const CFeeR
  */
 bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs, bool taproot_active, int64_t time)
 {
-    if (tx.IsCoinBase())
+    if (tx.IsCoinBase()) {
         return true; // Coinbases don't use vin normally
+    }
 
     if (fParticlMode) {
         for (unsigned int i = 0; i < tx.vin.size(); i++) {
@@ -266,7 +267,15 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs,
                 return false;
             }
 
-            if (whichType == TxoutType::SCRIPTHASH) {
+            if (whichType == TxoutType::NONSTANDARD || whichType == TxoutType::WITNESS_UNKNOWN) {
+                // WITNESS_UNKNOWN failures are typically also caught with a policy
+                // flag in the script interpreter, but it can be helpful to catch
+                // this type of NONSTANDARD transaction earlier in transaction
+                // validation.
+                return false;
+            } else
+            if (whichType == TxoutType::SCRIPTHASH
+                || whichType == TxoutType::SCRIPTHASH256) {
                 if (tx.vin[i].scriptWitness.stack.size() < 1) {
                     return false;
                 }
@@ -282,13 +291,15 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs,
                         return false;
                     }
                 }
+            } else if (whichType == TxoutType::WITNESS_V1_TAPROOT) {
+                // Don't allow Taproot spends unless Taproot is active.
+                if (!taproot_active) return false;
             }
         }
         return true;
     }
 
-    for (unsigned int i = 0; i < tx.vin.size(); i++)
-    {
+    for (unsigned int i = 0; i < tx.vin.size(); i++) {
         const CTxOut& prev = mapInputs.AccessCoin(tx.vin[i].prevout).out;
 
         std::vector<std::vector<unsigned char> > vSolutions;
@@ -299,8 +310,7 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs,
             // this type of NONSTANDARD transaction earlier in transaction
             // validation.
             return false;
-        } else if (whichType == TxoutType::SCRIPTHASH
-            || whichType == TxoutType::SCRIPTHASH256) {
+        } else if (whichType == TxoutType::SCRIPTHASH) {
             std::vector<std::vector<unsigned char> > stack;
             // convert the scriptSig into a stack, so we can inspect the redeemScript
             if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SigVersion::BASE))
diff --git a/src/test/particlchain_tests.cpp b/src/test/particlchain_tests.cpp
index 1c2bb0a653..508bd2ab29 100644
--- a/src/test/particlchain_tests.cpp
+++ b/src/test/particlchain_tests.cpp
@@ -463,6 +463,18 @@ BOOST_AUTO_TEST_CASE(taproot)
 
     BOOST_CHECK(!IsOpSuccess(OP_ISCOINSTAKE));
 
+    CScript s;
+    std::vector<std::vector<unsigned char> > solutions;
+    s << OP_1 << ToByteVector(uint256::ZERO);
+    BOOST_CHECK_EQUAL(Solver(s, solutions), TxoutType::WITNESS_V1_TAPROOT);
+    BOOST_CHECK_EQUAL(solutions.size(), 1U);
+    BOOST_CHECK(solutions[0] == ToByteVector(uint256::ZERO));
+
+    CKey k1, k2, k3;
+    InsecureNewKey(k1, true);
+    InsecureNewKey(k2, true);
+    InsecureNewKey(k3, true);
+
     unsigned int flags = SCRIPT_VERIFY_P2SH;
     flags |= SCRIPT_VERIFY_DERSIG;
     flags |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;

From 48caf61baf44dedaf8bd2d0e0315467492a82118 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Sun, 16 Jan 2022 15:56:10 +0200
Subject: [PATCH 04/57] New checkpoints.

---
 doc/release-notes-particl.md |  2 ++
 src/chainparams.cpp          | 24 +++++++++++++-----------
 2 files changed, 15 insertions(+), 11 deletions(-)

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index bb9af593a8..c8160dbafc 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -77,6 +77,8 @@
 ==============
 
 - qt: Fix abandon transaction button greyed out for record txns.
+- Backported taproot validation.
+- New checkpoints.
 
 
 0.19.2.18
diff --git a/src/chainparams.cpp b/src/chainparams.cpp
index 3e73fcd470..2c9e2fee09 100644
--- a/src/chainparams.cpp
+++ b/src/chainparams.cpp
@@ -501,8 +501,8 @@ class CMainParams : public CChainParams {
         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].min_activation_height = 709632; // Approximately November 12th, 2021
 
         // The best chain should have at least this much work.
-        consensus.nMinimumChainWork = uint256S("0x0000000000000000000000000000000000000000000000dfa5de89831c918d2c");
-        consensus.defaultAssumeValid = uint256S("0x1357966bfddceb8ea97f15da76e61087be6254d0b62ce9d4959ceee9b75c89f3"); // 1075660
+        consensus.nMinimumChainWork = uint256S("0x0000000000000000000000000000000000000000000000e7759137502a14b078");
+        consensus.defaultAssumeValid = uint256S("0x4e43167170e4639dbb1fdb84cb5735853f9595ff42713c143b70fd0625a382cd"); // 1102310
 
         consensus.nMinRCTOutputDepth = 12;
 
@@ -610,13 +610,14 @@ class CMainParams : public CChainParams {
                 { 992790,   uint256S("0xea97054e60558199d5c94627116fbfa9f3be1c63d45510963d1a308fe152974b")},
                 { 1026710,  uint256S("0xdcbe7be05060974cca33a52790e047a73358812102a97cd5b3089f2469bd6601")},
                 { 1075660,  uint256S("0x1357966bfddceb8ea97f15da76e61087be6254d0b62ce9d4959ceee9b75c89f3")},
+                { 1102310,  uint256S("0x4e43167170e4639dbb1fdb84cb5735853f9595ff42713c143b70fd0625a382cd")},
             }
         };
 
         chainTxData = ChainTxData {
-            // Data from rpc: getchaintxstats 4096 1357966bfddceb8ea97f15da76e61087be6254d0b62ce9d4959ceee9b75c89f3
-            /* nTime    */ 1638909184,
-            /* nTxCount */ 1303169,
+            // Data from rpc: getchaintxstats 4096 4e43167170e4639dbb1fdb84cb5735853f9595ff42713c143b70fd0625a382cd
+            /* nTime    */ 1642340432,
+            /* nTxCount */ 1345742,
             /* dTxRate  */ 0.01
         };
     }
@@ -702,8 +703,8 @@ class CTestNetParams : public CChainParams {
         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].min_activation_height = 0; // No activation delay
 
         // The best chain should have at least this much work.
-        consensus.nMinimumChainWork = uint256S("0x00000000000000000000000000000000000000000000001519f85a995c53963c");
-        consensus.defaultAssumeValid = uint256S("0x12e6a081d1874b3dfff99e120b8e22599e15730c23c88805740c507c11c91809"); // 1010348
+        consensus.nMinimumChainWork = uint256S("0x000000000000000000000000000000000000000000000015c1cd69e130305e0f");
+        consensus.defaultAssumeValid = uint256S("0x62ca4edbeb88e371d36052f7bbb52a598b1ac13d9269b5205ba7ed228d8b742a"); // 1029738
 
         consensus.nMinRCTOutputDepth = 12;
 
@@ -788,14 +789,15 @@ class CTestNetParams : public CChainParams {
                 {808059, uint256S("0x89de981a2cca262ae52ff5e69a0915c9083fb7cd4aba44e39f83c12a6b6602a9")},
                 {909640, uint256S("0xe2e1880d525c93e24ca2d0d494fe78624ad28c4ce778f987504582b7404bcb71")},
                 {1010348, uint256S("0x12e6a081d1874b3dfff99e120b8e22599e15730c23c88805740c507c11c91809")},
+                {1029738, uint256S("0x62ca4edbeb88e371d36052f7bbb52a598b1ac13d9269b5205ba7ed228d8b742a")},
             }
         };
 
         chainTxData = ChainTxData{
-            // Data from rpc: getchaintxstats 4096 12e6a081d1874b3dfff99e120b8e22599e15730c23c88805740c507c11c91809
-            /* nTime    */ 1638908912,
-            /* nTxCount */ 1073585,
-            /* dTxRate  */ 0.007
+            // Data from rpc: getchaintxstats 4096 62ca4edbeb88e371d36052f7bbb52a598b1ac13d9269b5205ba7ed228d8b742a
+            /* nTime    */ 1642340464,
+            /* nTxCount */ 1093189,
+            /* dTxRate  */ 0.002
         };
     }
 };

From c98847f9daa6821ec511bc31842620ed16624352 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Fri, 21 Jan 2022 16:46:55 +0200
Subject: [PATCH 05/57] doc: Describe walletsettings time return value.

---
 src/wallet/rpchdwallet.cpp | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/src/wallet/rpchdwallet.cpp b/src/wallet/rpchdwallet.cpp
index 346f3653a4..cfa2e999e1 100644
--- a/src/wallet/rpchdwallet.cpp
+++ b/src/wallet/rpchdwallet.cpp
@@ -7189,7 +7189,15 @@ static UniValue walletsettings(const JSONRPCRequest &request)
                         },
                     },
                 },
-                RPCResults{},
+                RPCResult{
+                    RPCResult::Type::OBJ, "", "",
+                    {
+                        {RPCResult::Type::OBJ, "setting_name", "",
+                        {
+                            {RPCResult::Type::STR, "time", /*optional=*/true, "Timestamp from when setting was last changed."},
+                        }
+                    }}
+                },
                 RPCExamples{
             "Set coldstaking changeaddress extended public key:\n"
             + HelpExampleCli("walletsettings", "changeaddress \"{\\\"coldstakingaddress\\\":\\\"extpubkey\\\"}\"") + "\n"

From a6b6508e22fd5229627a93f1faee94b5a3cc41cc Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Thu, 3 Feb 2022 21:20:09 +0200
Subject: [PATCH 06/57] net: Raise min proto version to 90014

---
 doc/release-notes-particl.md | 5 +++++
 src/version.h                | 2 +-
 2 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index c8160dbafc..dd7957ea45 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -73,6 +73,11 @@
     - Nonce is calculated as ECDH(ephem_secret + tweak, scan_public_key) and recovered with ECDH(scan_secret_key, ephem_public_key + G * tweak)
 
 
+0.19.2.19
+==============
+- Raised min protocol version to 90014
+
+
 0.19.2.19
 ==============
 
diff --git a/src/version.h b/src/version.h
index 94f4c5d460..92e75e0f54 100644
--- a/src/version.h
+++ b/src/version.h
@@ -15,7 +15,7 @@ static const int PROTOCOL_VERSION = 90035;
 static const int INIT_PROTO_VERSION = 209;
 
 //! disconnect from peers older than this proto version
-static const int MIN_PEER_PROTO_VERSION = 90013;
+static const int MIN_PEER_PROTO_VERSION = 90014;
 
 //! nTime field added to CAddress, starting with this version;
 //! if possible, avoid requesting addresses nodes older than this

From 0fba710a4b743b4ac360d0af0858e35bccced4ff Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Thu, 3 Feb 2022 21:48:00 +0200
Subject: [PATCH 07/57] refactor: Remove smsg_fee_rate_fix_time

---
 src/chainparams.cpp         | 8 +-------
 src/consensus/consensus.h   | 1 -
 src/consensus/params.h      | 2 --
 src/consensus/tx_verify.cpp | 3 +--
 src/smsg/rpcsmessage.cpp    | 3 +--
 5 files changed, 3 insertions(+), 14 deletions(-)

diff --git a/src/chainparams.cpp b/src/chainparams.cpp
index 2c9e2fee09..d015891be8 100644
--- a/src/chainparams.cpp
+++ b/src/chainparams.cpp
@@ -69,10 +69,7 @@ int64_t CChainParams::GetProofOfStakeReward(const CBlockIndex *pindexPrev, int64
 int64_t CChainParams::GetMaxSmsgFeeRateDelta(int64_t smsg_fee_prev, int64_t time) const
 {
     int64_t max_delta = (smsg_fee_prev * consensus.smsg_fee_max_delta_percent) / 1000000;
-    if (time >= consensus.smsg_fee_rate_fix_time) {
-        return std::max((int64_t)1, max_delta);
-    }
-    return max_delta;
+    return std::max((int64_t)1, max_delta);
 };
 
 bool CChainParams::CheckImportCoinbase(int nHeight, uint256 &hash) const
@@ -468,7 +465,6 @@ class CMainParams : public CChainParams {
 
         consensus.clamp_tx_version_time = 1643734800;   // 2022-02-01 17:00:00 UTC
         consensus.exploit_fix_3_time = 1643734800;      // 2022-02-01 17:00:00 UTC
-        consensus.smsg_fee_rate_fix_time = 1643734800;  // 2022-02-01 17:00:00 UTC
         consensus.m_taproot_time = 1643734800;          // 2022-02-01 17:00:00 UTC
 
         consensus.m_frozen_anon_index = 27340;
@@ -674,7 +670,6 @@ class CTestNetParams : public CChainParams {
         consensus.exploit_fix_1_time = 1614268800;      // 2021-02-25 16:00:00
 
         consensus.clamp_tx_version_time = 1641056400;   // 2022-01-01 17:00:00 UTC
-        consensus.smsg_fee_rate_fix_time = 1641056400;  // 2022-01-01 17:00:00 UTC
         consensus.m_taproot_time = 1641056400;          // 2022-01-01 17:00:00 UTC
 
         consensus.smsg_fee_period = 5040;
@@ -946,7 +941,6 @@ class CRegTestParams : public CChainParams {
         consensus.smsg_fee_max_delta_percent = 4300;
         consensus.smsg_min_difficulty = 0x1f0fffff;
         consensus.smsg_difficulty_max_delta = 0xffff;
-        consensus.smsg_fee_rate_fix_time = 0;
         consensus.m_taproot_time = 0;
 
         consensus.powLimit = uint256S("7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
diff --git a/src/consensus/consensus.h b/src/consensus/consensus.h
index 7c8fe1071d..a973890364 100644
--- a/src/consensus/consensus.h
+++ b/src/consensus/consensus.h
@@ -33,7 +33,6 @@ static constexpr unsigned int LOCKTIME_VERIFY_SEQUENCE = (1 << 0);
 /** Use GetMedianTimePast() instead of nTime for end point timestamp. */
 static constexpr unsigned int LOCKTIME_MEDIAN_TIME_PAST = (1 << 1);
 
-static const size_t MAX_DATA_OUTPUT_SIZE_OLD = 34 + 5 + 34; // DO_STEALTH 33, DO_STEALTH_PREFIX 4, DO_NARR_CRYPT (max 32 bytes)
 static const size_t MAX_DATA_OUTPUT_SIZE = 512;
 
 #endif // BITCOIN_CONSENSUS_CONSENSUS_H
diff --git a/src/consensus/params.h b/src/consensus/params.h
index 7ea617fb72..246b06e853 100644
--- a/src/consensus/params.h
+++ b/src/consensus/params.h
@@ -104,8 +104,6 @@ struct Params {
     int m_frozen_blinded_height = 0;
     /** Maximum value of tainted blinded output that can be spent without being whitelisted */
     int64_t m_max_tainted_value_out = 200LL * 100000000LL /* COIN */;
-    /** Fix GetMaxSmsgFeeRateDelta */
-    uint32_t smsg_fee_rate_fix_time = 0xffffffff; /* TODO: Remove after fork */
     /** Time taproot activates on Particl chain */
     uint32_t m_taproot_time = 0xffffffff;
 
diff --git a/src/consensus/tx_verify.cpp b/src/consensus/tx_verify.cpp
index a28e9ddd6b..e287991fbe 100644
--- a/src/consensus/tx_verify.cpp
+++ b/src/consensus/tx_verify.cpp
@@ -639,8 +639,7 @@ static bool CheckDataOutput(TxValidationState &state, const CTxOutData *p)
         return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-output-data-size");
     }
 
-    size_t max_output_size = GetAdjustedTime() >= state.m_consensus_params->smsg_fee_rate_fix_time ? MAX_DATA_OUTPUT_SIZE : MAX_DATA_OUTPUT_SIZE_OLD;
-    if (p->vData.size() > max_output_size) {
+    if (p->vData.size() > MAX_DATA_OUTPUT_SIZE) {
         return state.Invalid(TxValidationResult::TX_CONSENSUS, "bad-output-data-size");
     }
 
diff --git a/src/smsg/rpcsmessage.cpp b/src/smsg/rpcsmessage.cpp
index 2705c4b367..22618a2950 100644
--- a/src/smsg/rpcsmessage.cpp
+++ b/src/smsg/rpcsmessage.cpp
@@ -1089,8 +1089,7 @@ static UniValue smsgfund(const JSONRPCRequest &request)
     if (v_psmsgs.size() < 1) {
         throw JSONRPCError(RPC_INVALID_PARAMETER, "Must specify one or more message ids");
     }
-    size_t max_output_size = GetAdjustedTime() >= Params().GetConsensus().smsg_fee_rate_fix_time ? MAX_DATA_OUTPUT_SIZE : MAX_DATA_OUTPUT_SIZE_OLD;
-    size_t max_messages = (max_output_size - 1) / 24;
+    size_t max_messages = (MAX_DATA_OUTPUT_SIZE - 1) / 24;
     if (v_psmsgs.size() > max_messages) {
         throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Too many messages, max %d", max_messages));
     }

From d145a71b2934708efe4c13f73fde3b885658c8e8 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Tue, 8 Feb 2022 10:53:13 +0200
Subject: [PATCH 08/57] validation: New checkpoints

---
 src/chainparams.cpp | 22 ++++++++++++----------
 1 file changed, 12 insertions(+), 10 deletions(-)

diff --git a/src/chainparams.cpp b/src/chainparams.cpp
index d015891be8..05f3b53736 100644
--- a/src/chainparams.cpp
+++ b/src/chainparams.cpp
@@ -497,8 +497,8 @@ class CMainParams : public CChainParams {
         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].min_activation_height = 709632; // Approximately November 12th, 2021
 
         // The best chain should have at least this much work.
-        consensus.nMinimumChainWork = uint256S("0x0000000000000000000000000000000000000000000000e7759137502a14b078");
-        consensus.defaultAssumeValid = uint256S("0x4e43167170e4639dbb1fdb84cb5735853f9595ff42713c143b70fd0625a382cd"); // 1102310
+        consensus.nMinimumChainWork = uint256S("0x0000000000000000000000000000000000000000000000ebfc82a6882c940700");
+        consensus.defaultAssumeValid = uint256S("0x6b13071bc3f5689a3f8a29808f726654283714461076ea890f4272574ff2659f"); // 1117588
 
         consensus.nMinRCTOutputDepth = 12;
 
@@ -607,13 +607,14 @@ class CMainParams : public CChainParams {
                 { 1026710,  uint256S("0xdcbe7be05060974cca33a52790e047a73358812102a97cd5b3089f2469bd6601")},
                 { 1075660,  uint256S("0x1357966bfddceb8ea97f15da76e61087be6254d0b62ce9d4959ceee9b75c89f3")},
                 { 1102310,  uint256S("0x4e43167170e4639dbb1fdb84cb5735853f9595ff42713c143b70fd0625a382cd")},
+                { 1117588,  uint256S("0x6b13071bc3f5689a3f8a29808f726654283714461076ea890f4272574ff2659f")},
             }
         };
 
         chainTxData = ChainTxData {
-            // Data from rpc: getchaintxstats 4096 4e43167170e4639dbb1fdb84cb5735853f9595ff42713c143b70fd0625a382cd
-            /* nTime    */ 1642340432,
-            /* nTxCount */ 1345742,
+            // Data from rpc: getchaintxstats 4096 6b13071bc3f5689a3f8a29808f726654283714461076ea890f4272574ff2659f
+            /* nTime    */ 1644310000,
+            /* nTxCount */ 1369222,
             /* dTxRate  */ 0.01
         };
     }
@@ -698,8 +699,8 @@ class CTestNetParams : public CChainParams {
         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].min_activation_height = 0; // No activation delay
 
         // The best chain should have at least this much work.
-        consensus.nMinimumChainWork = uint256S("0x000000000000000000000000000000000000000000000015c1cd69e130305e0f");
-        consensus.defaultAssumeValid = uint256S("0x62ca4edbeb88e371d36052f7bbb52a598b1ac13d9269b5205ba7ed228d8b742a"); // 1029738
+        consensus.nMinimumChainWork = uint256S("0x00000000000000000000000000000000000000000000001641346b2186c891b2");
+        consensus.defaultAssumeValid = uint256S("0xc8b34db63fb6ec97b557a969065e56167030c36c12b7c988561736ad3a5488c0"); // 1044185
 
         consensus.nMinRCTOutputDepth = 12;
 
@@ -785,13 +786,14 @@ class CTestNetParams : public CChainParams {
                 {909640, uint256S("0xe2e1880d525c93e24ca2d0d494fe78624ad28c4ce778f987504582b7404bcb71")},
                 {1010348, uint256S("0x12e6a081d1874b3dfff99e120b8e22599e15730c23c88805740c507c11c91809")},
                 {1029738, uint256S("0x62ca4edbeb88e371d36052f7bbb52a598b1ac13d9269b5205ba7ed228d8b742a")},
+                {1044185, uint256S("0xc8b34db63fb6ec97b557a969065e56167030c36c12b7c988561736ad3a5488c0")},
             }
         };
 
         chainTxData = ChainTxData{
-            // Data from rpc: getchaintxstats 4096 62ca4edbeb88e371d36052f7bbb52a598b1ac13d9269b5205ba7ed228d8b742a
-            /* nTime    */ 1642340464,
-            /* nTxCount */ 1093189,
+            // Data from rpc: getchaintxstats 4096 c8b34db63fb6ec97b557a969065e56167030c36c12b7c988561736ad3a5488c0
+            /* nTime    */ 1644310032,
+            /* nTxCount */ 1108010,
             /* dTxRate  */ 0.002
         };
     }

From f25566c151bf5a00bfbf00636379ed0dc35a4e1b Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Fri, 11 Feb 2022 00:31:24 +0200
Subject: [PATCH 09/57] wallet: Disable p2sh-p2wpkh addresses.

---
 doc/release-notes-particl.md                  |  5 ++++-
 src/test/particlchain_tests.cpp               |  4 ++--
 src/wallet/rpcwallet.cpp                      |  2 +-
 test/functional/feature_ins_addressindex.py   |  5 -----
 test/functional/wallet_part_segwit_scripts.py | 18 ++++++++++++------
 5 files changed, 19 insertions(+), 15 deletions(-)

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index dd7957ea45..bd67d7f428 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -1,6 +1,7 @@
 
 0.21.2.6
 ==============
+
 - wallet:
   - Add minimum and maximumAmount to fundrawtransactionfrom and sendtypeto
   - Add includeWatching option to sendtypeto
@@ -73,9 +74,11 @@
     - Nonce is calculated as ECDH(ephem_secret + tweak, scan_public_key) and recovered with ECDH(scan_secret_key, ephem_public_key + G * tweak)
 
 
-0.19.2.19
+0.19.2.20
 ==============
+
 - Raised min protocol version to 90014
+- Disable p2sh-p2wpkh addresses.
 
 
 0.19.2.19
diff --git a/src/test/particlchain_tests.cpp b/src/test/particlchain_tests.cpp
index 508bd2ab29..85635dcf66 100644
--- a/src/test/particlchain_tests.cpp
+++ b/src/test/particlchain_tests.cpp
@@ -467,8 +467,8 @@ BOOST_AUTO_TEST_CASE(taproot)
     std::vector<std::vector<unsigned char> > solutions;
     s << OP_1 << ToByteVector(uint256::ZERO);
     BOOST_CHECK_EQUAL(Solver(s, solutions), TxoutType::WITNESS_V1_TAPROOT);
-    BOOST_CHECK_EQUAL(solutions.size(), 1U);
-    BOOST_CHECK(solutions[0] == ToByteVector(uint256::ZERO));
+    BOOST_CHECK_EQUAL(solutions.size(), 2U);
+    BOOST_CHECK(solutions[1] == ToByteVector(uint256::ZERO));
 
     CKey k1, k2, k3;
     InsecureNewKey(k1, true);
diff --git a/src/wallet/rpcwallet.cpp b/src/wallet/rpcwallet.cpp
index 478bba1a1c..bac6763046 100644
--- a/src/wallet/rpcwallet.cpp
+++ b/src/wallet/rpcwallet.cpp
@@ -379,7 +379,7 @@ static RPCHelpMan getnewaddress()
         bool f256bit = request.params.size() > 3 ? GetBool(request.params[3]) : false;
 
         if (output_type == OutputType::P2SH_SEGWIT) {
-            //throw JSONRPCError(RPC_INVALID_PARAMETER, "Valid address_types are \"legacy\" and \"bech32\"");
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "p2sh-segwit is disabled");
         }
         if (f256bit && output_type != OutputType::LEGACY) {
             throw JSONRPCError(RPC_INVALID_PARAMETER, "256bit must be used with address_type \"legacy\"");
diff --git a/test/functional/feature_ins_addressindex.py b/test/functional/feature_ins_addressindex.py
index 19d0a5cea7..73a15eb8c0 100755
--- a/test/functional/feature_ins_addressindex.py
+++ b/test/functional/feature_ins_addressindex.py
@@ -340,17 +340,12 @@ def run_test(self):
         self.log.info("Testing Bitcoin segwit addresses...")
 
         addr_sw_bech32 = nodes[2].getnewaddress('segwit script', False, False, False, 'bech32')
-        addr_sw_p2sh = nodes[2].getnewaddress('segwit script', False, False, False, 'p2sh-segwit')
         nodes[0].sendtoaddress(addr_sw_bech32, 1.0)
-        nodes[0].sendtoaddress(addr_sw_p2sh, 1.0)
 
         self.sync_all()
         mempool_sw_b = nodes[1].getaddressmempool({'addresses': [addr_sw_bech32]})
         assert(len(mempool_sw_b) == 1)
         assert(mempool_sw_b[0]['address'] == addr_sw_bech32)
-        mempool_sw_p = nodes[1].getaddressmempool({'addresses': [addr_sw_p2sh]})
-        assert(len(mempool_sw_p) == 1)
-        assert(mempool_sw_p[0]['address'] == addr_sw_p2sh)
 
         inputs = [{'txid': mempool_sw_b[0]['txid'], 'vout': mempool_sw_b[0]['index']}]
         outputs = {nodes[0].getnewaddress(): 0.99}
diff --git a/test/functional/wallet_part_segwit_scripts.py b/test/functional/wallet_part_segwit_scripts.py
index b2be43bde8..d5fdd78896 100755
--- a/test/functional/wallet_part_segwit_scripts.py
+++ b/test/functional/wallet_part_segwit_scripts.py
@@ -35,14 +35,20 @@ def run_test(self):
         nodes[1].sendtoaddress(addr_part_native, 1)
 
         self.log.info('Test Bitcoin native segwit, p2wpkh')
-        addr_sw_bech32 = nodes[2].getnewaddress('segwit script', False, False, False, 'bech32')
+        addr_sw_bech32 = nodes[2].getnewaddress('btc native segwit', False, False, False, 'bech32')
         nodes[2].manageaddressbook('newsend', addr_sw_bech32)
         nodes[1].sendtoaddress(addr_sw_bech32, 2)
 
         self.log.info('Test Bitcoin embedded segwit')
-        addr_sw_p2sh = nodes[2].getnewaddress('segwit script', False, False, False, 'p2sh-segwit')
-        nodes[2].manageaddressbook('newsend', addr_sw_p2sh)
-        nodes[1].sendtoaddress(addr_sw_p2sh, 3)
+        try:
+            addr_sw_p2sh = nodes[2].getnewaddress('segwit script', False, False, False, 'p2sh-segwit')
+            assert(False)
+        except Exception as e:
+            assert('p2sh-segwit is disabled' in str(e))
+
+        addr_sw_pk2 = nodes[2].getnewaddress('pk2', False, False, False, 'bech32')
+        nodes[2].manageaddressbook('newsend', addr_sw_pk2)
+        nodes[1].sendtoaddress(addr_sw_pk2, 3)
 
         ro = nodes[2].getaddressinfo(addr_part_native)
         assert(ro['iswitness'] == False)
@@ -52,8 +58,8 @@ def run_test(self):
         assert(ro['witness_version'] == 0)
         pk1 = ro['pubkey']
 
-        ro = nodes[2].getaddressinfo(addr_sw_p2sh)
-        assert(ro['script'] == 'witness_v0_keyhash')
+        ro = nodes[2].getaddressinfo(addr_sw_pk2)
+        assert(ro['witness_version'] == 0)
         pk2 = ro['pubkey']
 
         self.log.info('Test P2SH')

From 3089e6d84cd41b1b7457be8a7b8c20756b0f30a7 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Tue, 8 Feb 2022 13:55:04 +0200
Subject: [PATCH 10/57] wallet: Match std::filesystem::canonical

---
 src/wallet/load.cpp | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/src/wallet/load.cpp b/src/wallet/load.cpp
index a4daa87740..11464fd8cf 100644
--- a/src/wallet/load.cpp
+++ b/src/wallet/load.cpp
@@ -25,6 +25,17 @@ bool VerifyWallets(interfaces::Chain& chain)
         boost::system::error_code error;
         // The canonical path cleans the path, preventing >1 Berkeley environment instances for the same directory
         fs::path canonical_wallet_dir = fs::canonical(wallet_dir, error);
+
+        // Ensure trailing slash is stripped as std::filesystem::canonical would do
+        std::string canonical_wallet_dir_string = canonical_wallet_dir.string();
+        if (!canonical_wallet_dir_string.empty() &&
+            canonical_wallet_dir_string != "/" &&
+            !part::endsWith(canonical_wallet_dir_string, ":\\") &&
+            (canonical_wallet_dir_string.back() == '/' || canonical_wallet_dir_string.back() == '\\')) {
+            canonical_wallet_dir_string.erase(canonical_wallet_dir_string.size() - 1);
+            canonical_wallet_dir = canonical_wallet_dir_string;
+        }
+
         if (error || !fs::exists(wallet_dir)) {
             chain.initError(strprintf(_("Specified -walletdir \"%s\" does not exist"), wallet_dir.string()));
             return false;

From ab5e8b9bd30beceffdb83e5a65693b3ba14e8394 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Fri, 11 Feb 2022 01:52:02 +0200
Subject: [PATCH 11/57] test: boost::filesystem::create_directory ->
 create_directories

---
 test/functional/wallet_multiwallet.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/test/functional/wallet_multiwallet.py b/test/functional/wallet_multiwallet.py
index 24ecbcc895..bd8d21f94d 100755
--- a/test/functional/wallet_multiwallet.py
+++ b/test/functional/wallet_multiwallet.py
@@ -138,7 +138,7 @@ def wallet_file(name):
 
         # should raise rpc error if wallet path can't be created
         err_code = -4 if self.options.descriptors else -1
-        assert_raises_rpc_error(err_code, "boost::filesystem::create_directory:", self.nodes[0].createwallet, "w8/bad")
+        assert_raises_rpc_error(err_code, "boost::filesystem::create_director", self.nodes[0].createwallet, "w8/bad")
 
         # check that all requested wallets were created
         self.stop_node(0)

From f4b7c846094e32a6d19dde81162bc147cad168ce Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Fri, 11 Feb 2022 09:24:42 +0200
Subject: [PATCH 12/57] qt: 'Import Chain' defaults to disabled.

---
 doc/release-notes-particl.md   | 1 +
 src/qt/forms/mnemonicdialog.ui | 6 +++---
 2 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index bd67d7f428..b7403ae440 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -79,6 +79,7 @@
 
 - Raised min protocol version to 90014
 - Disable p2sh-p2wpkh addresses.
+- qt: 'Import Chain' defaults to disabled.
 
 
 0.19.2.19
diff --git a/src/qt/forms/mnemonicdialog.ui b/src/qt/forms/mnemonicdialog.ui
index 66440cd814..7c6df1094d 100644
--- a/src/qt/forms/mnemonicdialog.ui
+++ b/src/qt/forms/mnemonicdialog.ui
@@ -60,17 +60,17 @@
          <item row="1" column="0">
           <widget class="QLabel" name="importChainLabel">
            <property name="text">
-            <string>Import Chain</string>
+            <string>Create Import Chain</string>
            </property>
           </widget>
          </item>
          <item row="1" column="1">
           <widget class="QCheckBox" name="chkImportChain">
            <property name="toolTip">
-            <string>Only needed if you're importing </string>
+            <string>Only needed if you're importing from the previous chain</string>
            </property>
            <property name="checked">
-            <bool>true</bool>
+            <bool>false</bool>
            </property>
           </widget>
          </item>

From a619ec5bffa0121df7408fb41d396b0109542078 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Wed, 16 Feb 2022 19:27:20 +0200
Subject: [PATCH 13/57] wallet: Set default ring size to 12 to match Particl
 Desktop.

Issue #78
---
 doc/release-notes-particl.md | 1 +
 src/anon.h                   | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index b7403ae440..1f258265e7 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -80,6 +80,7 @@
 - Raised min protocol version to 90014
 - Disable p2sh-p2wpkh addresses.
 - qt: 'Import Chain' defaults to disabled.
+- wallet, qt: Default ring size set to 12 to match Particl Desktop.
 
 
 0.19.2.19
diff --git a/src/anon.h b/src/anon.h
index 4f6eb2b7e6..7b643854af 100644
--- a/src/anon.h
+++ b/src/anon.h
@@ -28,7 +28,7 @@ const size_t MAX_ANON_INPUTS = 32; // To raise see MLSAG_MAX_ROWS also
 
 const size_t ANON_FEE_MULTIPLIER = 2;
 
-const size_t DEFAULT_RING_SIZE = 5;
+const size_t DEFAULT_RING_SIZE = 12;
 const size_t DEFAULT_INPUTS_PER_SIG = 1;
 
 bool CheckAnonInputMempoolConflicts(const CTxIn &txin, const uint256 txhash, CTxMemPool *pmempool, TxValidationState &state);

From 7143b807e70e33b1095103a0f8c33e1c4f5fc713 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Sun, 20 Feb 2022 23:03:09 +0200
Subject: [PATCH 14/57] wallet: Fix BTC segwit address path and label in
 getaddressinfo.

---
 doc/release-notes-particl.md                  |  1 +
 src/wallet/hdwallet.cpp                       | 83 ++++++++++---------
 src/wallet/hdwallet.h                         |  4 +-
 src/wallet/rpchdwallet.cpp                    |  7 +-
 src/wallet/rpcwallet.cpp                      |  7 +-
 test/functional/wallet_part_segwit_scripts.py |  7 ++
 6 files changed, 65 insertions(+), 44 deletions(-)

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index 1f258265e7..ab727acb61 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -81,6 +81,7 @@
 - Disable p2sh-p2wpkh addresses.
 - qt: 'Import Chain' defaults to disabled.
 - wallet, qt: Default ring size set to 12 to match Particl Desktop.
+- wallet: Fix BTC segwit address path and label in getaddressinfo.
 
 
 0.19.2.19
diff --git a/src/wallet/hdwallet.cpp b/src/wallet/hdwallet.cpp
index a37ffb373a..c9ab5d3f70 100644
--- a/src/wallet/hdwallet.cpp
+++ b/src/wallet/hdwallet.cpp
@@ -2069,19 +2069,21 @@ isminetype CHDWallet::IsMine(const CScript &scriptPubKey, CKeyID &keyID,
             isInvalid = true;
             return ISMINE_NO;
         }
-        if ((mine = HaveKey(keyID, pak, pasc, pa)))
+        if ((mine = HaveKey(keyID, pak, pasc, pa))) {
             return mine;
+        }
         break;
     case TxoutType::PUBKEYHASH:
     case TxoutType::TIMELOCKED_PUBKEYHASH:
     case TxoutType::PUBKEYHASH256:
-        if (vSolutions[0].size() == 20)
+        if (vSolutions[0].size() == 20) {
             keyID = CKeyID(uint160(vSolutions[0]));
-        else
-        if (vSolutions[0].size() == 32)
+        } else
+        if (vSolutions[0].size() == 32) {
             keyID = CKeyID(uint256(vSolutions[0]));
-        else
+        } else {
             return ISMINE_NO;
+        }
         if (sigversion != SigVersion::BASE) {
             CPubKey pubkey;
             if (GetPubKey(keyID, pubkey) && !pubkey.IsCompressed()) {
@@ -2098,13 +2100,14 @@ isminetype CHDWallet::IsMine(const CScript &scriptPubKey, CKeyID &keyID,
     case TxoutType::SCRIPTHASH256:
     {
         CScriptID scriptID;
-        if (vSolutions[0].size() == 20)
+        if (vSolutions[0].size() == 20) {
             scriptID = CScriptID(uint160(vSolutions[0]));
-        else
-        if (vSolutions[0].size() == 32)
+        } else
+        if (vSolutions[0].size() == 32) {
             scriptID.Set(uint256(vSolutions[0]));
-        else
+        } else {
             return ISMINE_NO;
+        }
         CScript subscript;
         std::unique_ptr<SigningProvider> provider = GetSolvingProvider(subscript);
         if (provider && provider->GetCScript(scriptID, subscript)) {
@@ -2118,10 +2121,22 @@ isminetype CHDWallet::IsMine(const CScript &scriptPubKey, CKeyID &keyID,
         break;
     }
     case TxoutType::WITNESS_V0_KEYHASH:
+    {
+        keyID = CKeyID(uint160(vSolutions[0]));
+        if ((mine = HaveKey(keyID, pak, pasc, pa))) {
+            return mine;
+        }
+        break;
+    }
     case TxoutType::WITNESS_V0_SCRIPTHASH:
-        LogPrintf("%s: Ignoring WITNESS_V0 script type.\n", __func__); // shouldn't happen
+        LogPrintf("%s: Ignoring WITNESS_V0_SCRIPTHASH script type.\n", __func__); // shouldn't happen
+        return ISMINE_NO;
+    case TxoutType::WITNESS_V1_TAPROOT:
+        LogPrintf("%s: Ignoring WITNESS_V1_TAPROOT script type.\n", __func__); // shouldn't happen
+        return ISMINE_NO;
+    case TxoutType::WITNESS_UNKNOWN:
+        LogPrintf("%s: Ignoring WITNESS_UNKNOWN script type.\n", __func__); // shouldn't happen
         return ISMINE_NO;
-
     case TxoutType::MULTISIG:
     case TxoutType::TIMELOCKED_MULTISIG:
     {
@@ -7967,7 +7982,7 @@ int CHDWallet::ExtKeyGetIndex(CExtKeyAccount *sea, uint32_t &index)
 };
 
 int CHDWallet::NewKeyFromAccount(CHDWalletDB *pwdb, const CKeyID &idAccount, CPubKey &pkOut,
-    bool fInternal, bool fHardened, bool f256bit, bool fBech32, const char *plabel)
+    bool fInternal, bool fHardened, bool f256bit, bool fBech32, const char *plabel, OutputType output_type)
 {
     // If plabel is not null, add to m_address_book
 
@@ -8048,6 +8063,9 @@ int CHDWallet::NewKeyFromAccount(CHDWalletDB *pwdb, const CKeyID &idAccount, CPu
             vPath.clear();
         }
 
+        if (output_type == OutputType::BECH32) {
+            SetAddressBook(pwdb, WitnessV0KeyHash(pkOut), plabel, "receive", vPath, false);
+        } else
         if (f256bit) {
             CKeyID256 idKey256 = pkOut.GetID256();
             SetAddressBook(pwdb, idKey256, plabel, "receive", vPath, false, fBech32);
@@ -8059,7 +8077,7 @@ int CHDWallet::NewKeyFromAccount(CHDWalletDB *pwdb, const CKeyID &idAccount, CPu
     return 0;
 };
 
-int CHDWallet::NewKeyFromAccount(CPubKey &pkOut, bool fInternal, bool fHardened, bool f256bit, bool fBech32, const char *plabel)
+int CHDWallet::NewKeyFromAccount(CPubKey &pkOut, bool fInternal, bool fHardened, bool f256bit, bool fBech32, const char *plabel, OutputType output_type)
 {
     {
         LOCK(cs_wallet);
@@ -8069,7 +8087,7 @@ int CHDWallet::NewKeyFromAccount(CPubKey &pkOut, bool fInternal, bool fHardened,
             return werrorN(1, "%s TxnBegin failed.", __func__);
         }
 
-        if (0 != NewKeyFromAccount(&wdb, idDefaultAccount, pkOut, fInternal, fHardened, f256bit, fBech32, plabel)) {
+        if (0 != NewKeyFromAccount(&wdb, idDefaultAccount, pkOut, fInternal, fHardened, f256bit, fBech32, plabel, output_type)) {
             wdb.TxnAbort();
             return 1;
         }
@@ -12603,8 +12621,7 @@ bool CHDWallet::AbandonTransaction(const uint256 &hashTx)
 
     todo.insert(hashTx);
 
-    while (!todo.empty())
-    {
+    while (!todo.empty()) {
         uint256 now = *todo.begin();
         todo.erase(now);
         done.insert(now);
@@ -12617,8 +12634,8 @@ bool CHDWallet::AbandonTransaction(const uint256 &hashTx)
                 continue;
             }
 
-            if (!rtx.IsAbandoned()
-                && currentconfirm == 0) {
+            if (!rtx.IsAbandoned() &&
+                currentconfirm == 0) {
                 // If the orig tx was not in block/mempool, none of its spends can be in mempool
                 assert(!InMempool(now));
                 rtx.nIndex = -1;
@@ -12628,19 +12645,16 @@ bool CHDWallet::AbandonTransaction(const uint256 &hashTx)
             }
 
         } else
-        if ((mwi = mapWallet.find(now)) != mapWallet.end())
-        {
+        if ((mwi = mapWallet.find(now)) != mapWallet.end()) {
             CWalletTx &wtx = mwi->second;
             int currentconfirm = wtx.GetDepthInMainChain();
-            if (currentconfirm > 0)
-            {
+            if (currentconfirm > 0) {
                 WalletLogPrintf("ERROR: %s - Txn %s is %d blocks deep.\n", __func__, now.ToString(), currentconfirm);
                 continue;
-            };
+            }
 
-            if (!wtx.isAbandoned()
-                && currentconfirm == 0)
-            {
+            if (!wtx.isAbandoned() &&
+                currentconfirm == 0) {
                 // AbandonTransaction can happen before CWallet::transactionRemovedFromMempool is called
                 wtx.fInMempool = InMempool(wtx.GetHash());
 
@@ -12668,10 +12682,10 @@ bool CHDWallet::AbandonTransaction(const uint256 &hashTx)
         };
 
         TxSpends::const_iterator iter = mapTxSpends.lower_bound(COutPoint(hashTx, 0));
-        while (iter != mapTxSpends.end() && iter->first.hash == now)
-        {
-            if (!done.count(iter->second))
+        while (iter != mapTxSpends.end() && iter->first.hash == now) {
+            if (!done.count(iter->second)) {
                 todo.insert(iter->second);
+            }
             iter++;
         };
     };
@@ -12790,23 +12804,20 @@ void CHDWallet::SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator> r
 
     int nMinOrderPos = std::numeric_limits<int>::max();
     const CWalletTx* copyFrom = nullptr;
-    for (TxSpends::iterator it = range.first; it != range.second; ++it)
-    {
+    for (TxSpends::iterator it = range.first; it != range.second; ++it) {
         const uint256& hash = it->second;
         CWalletTx *wtx = GetWalletTx(hash);
         if (!wtx)
             continue;
 
         int n = wtx->nOrderPos;
-        if (n < nMinOrderPos)
-        {
+        if (n < nMinOrderPos) {
             nMinOrderPos = n;
             copyFrom = wtx;
         }
     }
     // Now copy data from copyFrom to rest:
-    for (TxSpends::iterator it = range.first; it != range.second; ++it)
-    {
+    for (TxSpends::iterator it = range.first; it != range.second; ++it) {
         const uint256& hash = it->second;
 
         CWalletTx* copyTo = GetWalletTx(hash);
@@ -12856,7 +12867,6 @@ bool CHDWallet::SetSetting(const std::string &setting, const UniValue &json)
     if (!wdb.WriteWalletSetting(setting, sJson)) {
         return false;
     }
-
     return true;
 };
 
@@ -12869,7 +12879,6 @@ bool CHDWallet::EraseSetting(const std::string &setting)
     if (!wdb.EraseWalletSetting(setting)) {
         return false;
     }
-
     return true;
 };
 
diff --git a/src/wallet/hdwallet.h b/src/wallet/hdwallet.h
index dbc0cdf522..50a3d4d515 100644
--- a/src/wallet/hdwallet.h
+++ b/src/wallet/hdwallet.h
@@ -303,8 +303,8 @@ class CHDWallet : public CWallet
     int ExtKeyGetIndex(CHDWalletDB *pwdb, CExtKeyAccount *sea, uint32_t &index, bool &fUpdate) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
     int ExtKeyGetIndex(CExtKeyAccount *sea, uint32_t &index);
 
-    int NewKeyFromAccount(CHDWalletDB *pwdb, const CKeyID &idAccount, CPubKey &pkOut, bool fInternal, bool fHardened, bool f256bit=false, bool fBech32=false, const char *plabel=nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
-    int NewKeyFromAccount(CPubKey &pkOut, bool fInternal=false, bool fHardened=false, bool f256bit=false, bool fBech32=false, const char *plabel=nullptr); // wrapper - use default account
+    int NewKeyFromAccount(CHDWalletDB *pwdb, const CKeyID &idAccount, CPubKey &pkOut, bool fInternal, bool fHardened, bool f256bit=false, bool fBech32=false, const char *plabel=nullptr, OutputType output_type=OutputType::LEGACY) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
+    int NewKeyFromAccount(CPubKey &pkOut, bool fInternal=false, bool fHardened=false, bool f256bit=false, bool fBech32=false, const char *plabel=nullptr, OutputType output_type=OutputType::LEGACY); // wrapper - use default account
 
     int NewStealthKeyFromAccount(CHDWalletDB *pwdb, const CKeyID &idAccount, const std::string &sLabel, CEKAStealthKey &akStealthOut, uint32_t nPrefixBits, const char *pPrefix, bool fBech32=false, uint32_t *pscankey_num=nullptr, bool add_to_lookahead=true) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
     int NewStealthKeyFromAccount(const std::string &sLabel, CEKAStealthKey &akStealthOut, uint32_t nPrefixBits, const char *pPrefix, bool fBech32=false); // wrapper - use default account
diff --git a/src/wallet/rpchdwallet.cpp b/src/wallet/rpchdwallet.cpp
index cfa2e999e1..902cf3ca0a 100644
--- a/src/wallet/rpchdwallet.cpp
+++ b/src/wallet/rpchdwallet.cpp
@@ -4178,9 +4178,11 @@ static UniValue manageaddressbook(const JSONRPCRequest &request)
         EnsureWalletIsUnlocked(pwallet);
     }
 
+    bool label_was_set = false;
     bool fHavePurpose = false;
     if (request.params.size() > 2) {
         sLabel = request.params[2].get_str();
+        label_was_set = true;
     }
     if (request.params.size() > 3) {
         sPurpose = request.params[3].get_str();
@@ -4290,12 +4292,13 @@ static UniValue manageaddressbook(const JSONRPCRequest &request)
         // Only update the purpose field if address does not yet exist
         if (mabi != pwallet->m_address_book.end()) {
             sPurpose = ""; // "" means don't change purpose
+            if (!label_was_set) {
+                sLabel = mabi->second.GetLabel();
+            }
         }
-
         if (!pwallet->SetAddressBook(dest, sLabel, sPurpose)) {
             throw JSONRPCError(RPC_WALLET_ERROR, "SetAddressBook failed.");
         }
-
         if (mabi != pwallet->m_address_book.end()) {
             sPurpose = mabi->second.purpose;
         }
diff --git a/src/wallet/rpcwallet.cpp b/src/wallet/rpcwallet.cpp
index bac6763046..3efd4fa3f1 100644
--- a/src/wallet/rpcwallet.cpp
+++ b/src/wallet/rpcwallet.cpp
@@ -399,7 +399,7 @@ static RPCHelpMan getnewaddress()
                 throw JSONRPCError(RPC_WALLET_ERROR, "No default account set.");
             }
         }
-        if (0 != phdw->NewKeyFromAccount(newKey, false, fHardened, f256bit, fBech32, label.c_str())) {
+        if (0 != phdw->NewKeyFromAccount(newKey, false, fHardened, f256bit, fBech32, label.c_str(), output_type)) {
             throw JSONRPCError(RPC_WALLET_ERROR, "NewKeyFromAccount failed.");
         }
 
@@ -4901,8 +4901,9 @@ RPCHelpMan getaddressinfo()
                 }
             }
         } else
-        if (dest.type() == typeid(PKHash)
-            || dest.type() == typeid(CKeyID256)) {
+        if (dest.type() == typeid(PKHash) ||
+            dest.type() == typeid(CKeyID256) ||
+            dest.type() == typeid(WitnessV0KeyHash)) {
             CKeyID idk;
             const CEKAKey *pak = nullptr;
             const CEKASCKey *pasc = nullptr;
diff --git a/test/functional/wallet_part_segwit_scripts.py b/test/functional/wallet_part_segwit_scripts.py
index d5fdd78896..aa316ed3de 100755
--- a/test/functional/wallet_part_segwit_scripts.py
+++ b/test/functional/wallet_part_segwit_scripts.py
@@ -51,11 +51,18 @@ def run_test(self):
         nodes[1].sendtoaddress(addr_sw_pk2, 3)
 
         ro = nodes[2].getaddressinfo(addr_part_native)
+        assert(ro['path'] == 'm/0/0')
         assert(ro['iswitness'] == False)
+        assert(ro['ischange'] == False)
+        assert('addr_part_native' in ro['labels'])
         pk0 = ro['pubkey']
 
         ro = nodes[2].getaddressinfo(addr_sw_bech32)
+        assert(ro['path'] == 'm/0/1')
+        assert(ro['iswitness'] == True)
+        assert(ro['ischange'] == False)
         assert(ro['witness_version'] == 0)
+        assert('btc native segwit' in ro['labels'])
         pk1 = ro['pubkey']
 
         ro = nodes[2].getaddressinfo(addr_sw_pk2)

From 399bcd66270609f35b3c981bc47df3e7033222b6 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Thu, 24 Feb 2022 00:32:14 +0200
Subject: [PATCH 15/57] wallet: Fix receiving anon txns on locked wallet and
 new address.

---
 doc/release-notes-particl.md |  6 +++
 src/wallet/hdwallet.cpp      | 89 +++++++++++++++++++-----------------
 src/wallet/hdwallet.h        |  2 +
 3 files changed, 56 insertions(+), 41 deletions(-)

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index ab727acb61..e661fb8c82 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -1,4 +1,10 @@
 
+0.21.2.7
+==============
+
+- wallet: Fix receiving anon txns on locked wallet and new address.
+
+
 0.21.2.6
 ==============
 
diff --git a/src/wallet/hdwallet.cpp b/src/wallet/hdwallet.cpp
index c9ab5d3f70..d13214a253 100644
--- a/src/wallet/hdwallet.cpp
+++ b/src/wallet/hdwallet.cpp
@@ -3010,7 +3010,7 @@ void CHDWallet::ParseAddressForMetaData(const CTxDestination &addr, COutputRecor
         CStealthAddressIndexed sxi;
         sx.ToRaw(sxi.addrRaw);
         uint32_t sxId;
-        if (GetStealthKeyIndex(sxi, sxId)){
+        if (GetStealthKeyIndex(sxi, sxId)) {
             rec.vPath.resize(5);
             rec.vPath[0] = ORA_STEALTH;
             memcpy(&rec.vPath[1], &sxId, 4);
@@ -9270,19 +9270,25 @@ bool CHDWallet::IndexStealthKey(CHDWalletDB *pwdb, uint160 &hash, const CStealth
     return true;
 };
 
-bool CHDWallet::GetStealthKeyIndex(const CStealthAddressIndexed &sxi, uint32_t &id)
+bool CHDWallet::GetStealthKeyIndex(CHDWalletDB *pwdb, const CStealthAddressIndexed &sxi, uint32_t &id)
 {
-    LOCK(cs_wallet);
-    uint160 hash = Hash160(sxi.addrRaw);
+    AssertLockHeld(cs_wallet);
 
-    CHDWalletDB wdb(*database);
-    if (wdb.ReadStealthAddressIndexReverse(hash, id)) {
+    uint160 hash = Hash160(sxi.addrRaw);
+    if (pwdb->ReadStealthAddressIndexReverse(hash, id)) {
         return true;
     }
 
-    return IndexStealthKey(&wdb, hash, sxi, id);
+    return IndexStealthKey(pwdb, hash, sxi, id);
 };
 
+bool CHDWallet::GetStealthKeyIndex(const CStealthAddressIndexed &sxi, uint32_t &id)
+{
+    LOCK(cs_wallet);
+    CHDWalletDB wdb(*database);
+
+    return GetStealthKeyIndex(&wdb, sxi, id);
+};
 
 bool CHDWallet::UpdateStealthAddressIndex(const CKeyID &idK, const CStealthAddressIndexed &sxi, uint32_t &id)
 {
@@ -9322,11 +9328,9 @@ bool CHDWallet::GetStealthByIndex(uint32_t sxId, CStealthAddress &sx) const
     if (!wdb.ReadStealthAddressIndex(sxId, sxi)) {
         return false;
     }
-
     if (sxi.addrRaw.size() < MIN_STEALTH_RAW_SIZE) {
         return werror("%s: Incorrect size for stealthId: %u", __func__, sxId);
     }
-
     if (0 != sx.FromRaw(&sxi.addrRaw[0], sxi.addrRaw.size())) {
         return werror("%s: FromRaw failed for stealthId: %u", __func__, sxId);
     }
@@ -9334,26 +9338,22 @@ bool CHDWallet::GetStealthByIndex(uint32_t sxId, CStealthAddress &sx) const
     return true;
 };
 
-bool CHDWallet::GetStealthLinked(const CKeyID &idK, CStealthAddress &sx) const
+bool CHDWallet::GetStealthLinked(CHDWalletDB *pwdb, const CKeyID &idK, CStealthAddress &sx) const
 {
-    LOCK(cs_wallet);
-
-    CHDWalletDB wdb(*database);
+    assert(pwdb);
+    AssertLockHeld(cs_wallet);
 
     uint32_t sxId;
-    if (!wdb.ReadStealthAddressLink(idK, sxId)) {
+    if (!pwdb->ReadStealthAddressLink(idK, sxId)) {
         return false;
     }
-
     CStealthAddressIndexed sxi;
-    if (!wdb.ReadStealthAddressIndex(sxId, sxi)) {
+    if (!pwdb->ReadStealthAddressIndex(sxId, sxi)) {
         return false;
     }
-
     if (sxi.addrRaw.size() < MIN_STEALTH_RAW_SIZE) {
         return werror("%s: Incorrect size for stealthId: %u", __func__, sxId);
     }
-
     if (0 != sx.FromRaw(&sxi.addrRaw[0], sxi.addrRaw.size())) {
         return werror("%s: FromRaw failed for stealthId: %u", __func__, sxId);
     }
@@ -9361,6 +9361,14 @@ bool CHDWallet::GetStealthLinked(const CKeyID &idK, CStealthAddress &sx) const
     return true;
 };
 
+bool CHDWallet::GetStealthLinked(const CKeyID &idK, CStealthAddress &sx) const
+{
+    LOCK(cs_wallet);
+    CHDWalletDB wdb(*database);
+
+    return GetStealthLinked(&wdb, idK, sx);
+};
+
 bool CHDWallet::GetStealthSecret(const CStealthAddress &sx, CKey &key_out) const
 {
     if (sx.scan_pubkey.size() != 33) {
@@ -9569,10 +9577,9 @@ bool CHDWallet::ProcessLockedBlindedOutputs()
         }
 
         MapRecords_t::iterator mir;
-
         mir = mapRecords.find(op.hash);
-        if (mir == mapRecords.end()
-            || !wdb.ReadStoredTx(op.hash, stx)) {
+        if (mir == mapRecords.end() ||
+            !wdb.ReadStoredTx(op.hash, stx)) {
             WalletLogPrintf("%s: Error: mapRecord not found for %s.\n", __func__, op.ToString());
             continue;
         }
@@ -9600,15 +9607,15 @@ bool CHDWallet::ProcessLockedBlindedOutputs()
         pout->n = op.n;
         switch (txout->nVersion) {
             case OUTPUT_CT:
-                if (OwnBlindOut(&wdb, op.hash, (CTxOutCT*)txout.get(), nullptr, n, *pout, stx, fUpdated)
-                    && !fHave) {
+                if (OwnBlindOut(&wdb, op.hash, (CTxOutCT*)txout.get(), nullptr, n, *pout, stx, fUpdated) &&
+                    !fHave) {
                     fUpdated = true;
                     rtx.InsertOutput(*pout);
                 }
                 break;
             case OUTPUT_RINGCT:
-                if (OwnAnonOut(&wdb, op.hash, (CTxOutRingCT*)txout.get(), nullptr, n, *pout, stx, fUpdated)
-                    && !fHave) {
+                if (OwnAnonOut(&wdb, op.hash, (CTxOutRingCT*)txout.get(), nullptr, n, *pout, stx, fUpdated) &&
+                    !fHave) {
                     fUpdated = true;
                     rtx.InsertOutput(*pout);
                 }
@@ -9627,8 +9634,8 @@ bool CHDWallet::ProcessLockedBlindedOutputs()
                 ProcessPlaceholder(*stx.tx.get(), rtx);
             }
 
-            if (!wdb.WriteTxRecord(op.hash, rtx)
-                || !wdb.WriteStoredTx(op.hash, stx)) {
+            if (!wdb.WriteTxRecord(op.hash, rtx) ||
+                !wdb.WriteStoredTx(op.hash, stx)) {
                 return false;
             }
 
@@ -9645,8 +9652,8 @@ bool CHDWallet::ProcessLockedBlindedOutputs()
 
     // Trigger a rescan from the deepest anon out, spend info may need to be updated
     // Only possible if outputs were spent from a different wallet.
-    if (!m_is_only_instance
-        && earliest_anon_out_time != std::numeric_limits<int64_t>::max()) {
+    if (!m_is_only_instance &&
+        earliest_anon_out_time != std::numeric_limits<int64_t>::max()) {
         WalletRescanReserver reserver(*this);
         if (!reserver.reserve()) {
             WalletLogPrintf("%s: Wallet is currently rescanning.\n", __func__);
@@ -9811,9 +9818,9 @@ bool CHDWallet::ProcessStealthOutput(const CTxDestination &address,
     CKeyID ckidMatch = ToKeyID(boost::get<PKHash>(address));
     if (HaveKey(ckidMatch)) {
         CStealthAddress sx;
-        if (fNeedShared
-            && GetStealthLinked(ckidMatch, sx)
-            && GetStealthAddressScanKey(sx)) {
+        if (fNeedShared &&
+            GetStealthLinked(ckidMatch, sx) &&
+            GetStealthAddressScanKey(sx)) {
             if (StealthShared(sx.scan_secret, vchEphemPK, sShared) != 0) {
                 WalletLogPrintf("%s: StealthShared failed.\n", __func__);
                 //continue;
@@ -10781,7 +10788,7 @@ int CHDWallet::OwnBlindOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOu
             CStealthAddress sx;
             CKey scan_secret;
 
-            if (GetStealthLinked(idk, sx) &&
+            if (GetStealthLinked(pwdb, idk, sx) &&
                 GetStealthSecret(sx, scan_secret)) {
 
                 // pk_tweaked = pkEphem + G * tweak
@@ -10871,8 +10878,8 @@ int CHDWallet::OwnAnonOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOut
 
     if (IsLocked()) {
         COutPoint op(txhash, rout.n);
-        if ((rout.nFlags & ORF_LOCKED)
-            && !pwdb->HaveLockedAnonOut(op)) {
+        if ((rout.nFlags & ORF_LOCKED) &&
+            !pwdb->HaveLockedAnonOut(op)) {
             rout.nValue = 0;
             fUpdated = true;
             if (LogAcceptCategory(BCLog::HDWALLET)) WalletLogPrintf("%s: Adding locked anon output %s, %d.\n", __func__, txhash.ToString(), rout.n);
@@ -10916,7 +10923,7 @@ int CHDWallet::OwnAnonOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOut
         if (rewind_rv < 1) {
             CStealthAddress sx;
             CKey scan_secret;
-            if (GetStealthLinked(idk, sx) &&
+            if (GetStealthLinked(pwdb, idk, sx) &&
                 GetStealthSecret(sx, scan_secret)) {
 
                 // pk_tweaked = pkEphem + G * tweak
@@ -10950,9 +10957,9 @@ int CHDWallet::OwnAnonOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOut
         ExtractNarration(nonce, pout->vData, rout.sNarration);
     } else
     if (1 != secp256k1_rangeproof_rewind(secp256k1_ctx_blind,
-        blindOut, &amountOut, msg, &mlen, nonce.begin(),
-        &min_value, &max_value,
-        &pout->commitment, pout->vRangeproof.data(), pout->vRangeproof.size(),
+                blindOut, &amountOut, msg, &mlen, nonce.begin(),
+                &min_value, &max_value,
+                &pout->commitment, pout->vRangeproof.data(), pout->vRangeproof.size(),
         nullptr, 0,
         secp256k1_generator_h)) {
         return werrorN(0, "%s: secp256k1_rangeproof_rewind failed.", __func__);
@@ -10969,11 +10976,11 @@ int CHDWallet::OwnAnonOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOut
 
     if (rout.vPath.size() == 0) {
         CStealthAddress sx;
-        if (GetStealthLinked(idk, sx)) {
+        if (GetStealthLinked(pwdb, idk, sx)) {
             CStealthAddressIndexed sxi;
             sx.ToRaw(sxi.addrRaw);
             uint32_t sxId;
-            if (GetStealthKeyIndex(sxi, sxId)) {
+            if (GetStealthKeyIndex(pwdb, sxi, sxId)) {
                 rout.vPath.resize(5);
                 rout.vPath[0] = ORA_STEALTH;
                 memcpy(&rout.vPath[1], &sxId, 4);
diff --git a/src/wallet/hdwallet.h b/src/wallet/hdwallet.h
index 50a3d4d515..e83faf6be1 100644
--- a/src/wallet/hdwallet.h
+++ b/src/wallet/hdwallet.h
@@ -365,9 +365,11 @@ class CHDWallet : public CWallet
     int LoadStealthAddresses();
     int LoadMasterKeys();
     bool IndexStealthKey(CHDWalletDB *pwdb, uint160 &hash, const CStealthAddressIndexed &sxi, uint32_t &id) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
+    bool GetStealthKeyIndex(CHDWalletDB *pwdb, const CStealthAddressIndexed &sxi, uint32_t &id) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
     bool GetStealthKeyIndex(const CStealthAddressIndexed &sxi, uint32_t &id);
     bool UpdateStealthAddressIndex(const CKeyID &idK, const CStealthAddressIndexed &sxi, uint32_t &id); // Get stealth index or create new index if none found
     bool GetStealthByIndex(uint32_t sxId, CStealthAddress &sx) const;
+    bool GetStealthLinked(CHDWalletDB *pwdb, const CKeyID &idK, CStealthAddress &sx) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
     bool GetStealthLinked(const CKeyID &idK, CStealthAddress &sx) const;
     bool GetStealthSecret(const CStealthAddress &sx, CKey &key_out) const;
     bool ProcessLockedStealthOutputs() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);

From 347df5e0ee25c92b05f1b70a3c093e1e8efedb62 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Thu, 24 Feb 2022 00:34:50 +0200
Subject: [PATCH 16/57] wallet: Fix passing anon_ring_size parameter to
 fundrawtransactionfrom.

---
 doc/release-notes-particl.md                  |  1 +
 src/wallet/hdwallet.cpp                       |  5 +-
 src/wallet/rpchdwallet.cpp                    | 14 ++---
 test/functional/feature_part_anon.py          | 51 +++++++++++++++----
 test/functional/p2p_part_disable_types.py     | 16 +++---
 .../functional/rpc_part_filtertransactions.py |  2 +-
 .../functional/rpc_part_tracefrozenoutputs.py |  2 +-
 .../functional/test_framework/test_particl.py | 14 ++++-
 8 files changed, 74 insertions(+), 31 deletions(-)

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index e661fb8c82..043db6151e 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -3,6 +3,7 @@
 ==============
 
 - wallet: Fix receiving anon txns on locked wallet and new address.
+- wallet: Fix passing anon_ring_size parameter to fundrawtransactionfrom.
 
 
 0.21.2.6
diff --git a/src/wallet/hdwallet.cpp b/src/wallet/hdwallet.cpp
index d13214a253..d058d16c14 100644
--- a/src/wallet/hdwallet.cpp
+++ b/src/wallet/hdwallet.cpp
@@ -11149,6 +11149,7 @@ bool CHDWallet::AddToRecord(CTransactionRecord &rtxIn, const CTransaction &tx, C
         vEphemPath = mvi->second;
 
         if (vEphemPath.size() != 12) { // accid / chainchild / start
+            WalletLogPrintf("Error: Bad vEphemPath.size() %s.\n", txhash.ToString());
             return false;
         }
 
@@ -11275,8 +11276,8 @@ bool CHDWallet::AddToRecord(CTransactionRecord &rtxIn, const CTransaction &tx, C
         }
 
         stx.tx = MakeTransactionRef(tx);
-        if (!wdb.WriteTxRecord(txhash, rtx)
-            || !wdb.WriteStoredTx(txhash, stx)) {
+        if (!wdb.WriteTxRecord(txhash, rtx) ||
+            !wdb.WriteStoredTx(txhash, stx)) {
             return false;
         }
     }
diff --git a/src/wallet/rpchdwallet.cpp b/src/wallet/rpchdwallet.cpp
index 902cf3ca0a..8525586e08 100644
--- a/src/wallet/rpchdwallet.cpp
+++ b/src/wallet/rpchdwallet.cpp
@@ -7088,16 +7088,16 @@ static UniValue debugwallet(const JSONRPCRequest &request)
                         }
                         continue;
                     }
-                    if ((r.nType == OUTPUT_CT || r.nType == OUTPUT_RINGCT)
-                        && (r.nFlags & ORF_OWNED || r.nFlags & ORF_STAKEONLY)
-                        && !pwallet->IsSpent(txhash, r.n)) {
+                    if ((r.nType == OUTPUT_CT || r.nType == OUTPUT_RINGCT) &&
+                        (r.nFlags & ORF_OWNED || r.nFlags & ORF_STAKEONLY) &&
+                        !pwallet->IsSpent(txhash, r.n)) {
                         uint256 tmp;
                         if (!stx.GetBlind(r.n, tmp.begin())) {
                             add_error("Missing blinding factor.", txhash, r.n);
                         }
                     }
-                    if (r.nType == OUTPUT_RINGCT
-                        && (r.nFlags & ORF_OWNED)) {
+                    if (r.nType == OUTPUT_RINGCT &&
+                        (r.nFlags & ORF_OWNED)) {
                         CCmpPubKey anon_pubkey, ki;
                         if (!stx.GetAnonPubkey(r.n, anon_pubkey)) {
                             add_error("Could not get anon pubkey.", txhash, r.n);
@@ -8629,8 +8629,8 @@ static UniValue fundrawtransactionfrom(const JSONRPCRequest& request)
                 {"estimate_mode", UniValueType(UniValue::VSTR)},
                 {"avoid_reuse", UniValueType(UniValue::VBOOL)},
                 {"sign_tx", UniValueType(UniValue::VBOOL)},
-                {"anon_ring_size", UniValueType(UniValue::VBOOL)},
-                {"anon_inputs_per_sig", UniValueType(UniValue::VBOOL)},
+                {"anon_ring_size", UniValueType(UniValue::VNUM)},
+                {"anon_inputs_per_sig", UniValueType(UniValue::VNUM)},
                 {"blind_watchonly_visible", UniValueType(UniValue::VBOOL)},
                 {"minimumAmount", UniValueType()},
                 {"maximumAmount", UniValueType()},
diff --git a/test/functional/feature_part_anon.py b/test/functional/feature_part_anon.py
index 6dce1e6f4d..db1207d4d9 100755
--- a/test/functional/feature_part_anon.py
+++ b/test/functional/feature_part_anon.py
@@ -1,5 +1,5 @@
 #!/usr/bin/env python3
-# Copyright (c) 2017-2021 The Particl Core developers
+# Copyright (c) 2017-2022 The Particl Core developers
 # Distributed under the MIT software license, see the accompanying
 # file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
@@ -8,8 +8,7 @@
 from test_framework.util import assert_raises_rpc_error
 from test_framework.address import base58_to_byte
 from test_framework.key import SECP256K1, ECPubKey
-from test_framework.messages import COIN
-from test_framework.messages import sha256
+from test_framework.messages import COIN, sha256
 
 
 class AnonTest(ParticlTestFramework):
@@ -70,7 +69,7 @@ def run_test(self):
         for txnHash in txnHashes:
             assert(txnHash in ro['tx'])
 
-        txnHash = nodes[1].sendanontoanon(sxAddrTo0_1, 1, '', '', False, 'node1 -> node0 a->a')
+        txnHash = nodes[1].sendanontoanon(sxAddrTo0_1, 1, '', '', False, 'node1 -> node0 a->a', 5, 1))
         txnHashes = [txnHash,]
 
         assert(self.wait_for_mempool(nodes[0], txnHash))
@@ -92,8 +91,8 @@ def run_test(self):
         ro = nodes[1].sendtypeto('anon', 'part', outputs, 'comment_to', 'comment_from', 4, 32, True)
         assert(ro['bytes'] > 0)
 
-        txnHashes.append(nodes[1].sendtypeto('anon', 'part', outputs))
-        txnHashes.append(nodes[1].sendtypeto('anon', 'anon', [{'address': sxAddrTo1_1, 'amount': 1},]))
+        txnHashes.append(nodes[1].sendtypeto('anon', 'part', outputs, '', '', 5))
+        txnHashes.append(nodes[1].sendtypeto('anon', 'anon', [{'address': sxAddrTo1_1, 'amount': 1},], '', '', 5))
 
         for txhash in txnHashes:
             assert(self.wait_for_mempool(nodes[0], txhash))
@@ -184,7 +183,7 @@ def run_test(self):
         # Skip initial rescan by passing -1 as scan_chain_from
         w1_3.extkeyimportmaster('drip fog service village program equip minute dentist series hawk crop sphere olympic lazy garbage segment fox library good alley steak jazz force inmate',
             '', False, 'imported key', 'imported acc', -1)
-        w1_3.getnewstealthaddress('lblsx11')
+        sxaddr1_3 = w1_3.getnewstealthaddress('lblsx11')
         w1_3.walletsettings('other', {'onlyinstance': False})
         w1_3.walletlock()
         assert(w1_3.getwalletinfo()['encryptionstatus'] == 'Locked')
@@ -195,10 +194,42 @@ def run_test(self):
         wi_1_3 = w1_3.getwalletinfo()
         assert(wi_1_3['anon_balance'] == wi_1['anon_balance'])
 
+
         # Coverage
         w1_3.sendanontoblind(sxAddrTo0_1, 1.0)
         w1_3.sendanontopart(sxAddrTo0_1, 1.0)
 
+        self.log.info('Test receiving from locked wallet')
+        sxaddr_to = w1_3.getnewstealthaddress('locked receive')
+        w1_3.walletlock()
+        nodes[1].createwallet('test_genesis_coins_2')
+        w1_4 = nodes[1].get_wallet_rpc('test_genesis_coins_2')
+        self.import_genesis_coins_b(w1_4)
+        assert(w1_3.getwalletinfo()['encryptionstatus'] == 'Locked')
+        txid = w1_4.sendtypeto('part', 'anon', [{'address': sxaddr_to, 'amount': 5}, ])
+        assert(self.wait_for_wtx(w1_3, txid))
+
+        ft = w1_3.filtertransactions()
+        found_tx = False
+        for tx in ft:
+            if tx['txid'] == txid:
+                assert(tx['requires_unlock'] == 'true')
+                found_tx = True
+                break
+        assert(found_tx)
+
+        w1_3.walletpassphrase('test', 30)
+
+        ft = w1_3.filtertransactions()
+        found_tx = False
+        for tx in ft:
+            if tx['txid'] == txid:
+                assert('requires_unlock' not in tx)
+                found_tx = True
+                break
+        assert(found_tx)
+
+
         self.log.info('Test sendtypeto coincontrol')
         w1_inputs = w1_2.listunspentanon()
         assert(len(w1_inputs) > 1)
@@ -245,7 +276,7 @@ def run_test(self):
         },]
         tx = nodes[0].createrawparttransaction([], outputs)
 
-        options = {'sign_tx': True}
+        options = {'sign_tx': True, 'anon_ring_size': 5}
         tx_signed = nodes[0].fundrawtransactionfrom('anon', tx['hex'], {}, tx['amounts'], options)
         txid = nodes[0].sendrawtransaction(tx_signed['hex'])
         self.stakeBlocks(1)
@@ -324,9 +355,9 @@ def run_test(self):
             }],
             'feeRate': 0.001,
             'sign_tx': True,
+            'anon_ring_size': 5,
         }
-        input_amounts = {
-        }
+        input_amounts = {}
         used_input = (txid, found_output)
 
         tx_signed = nodes[0].fundrawtransactionfrom('anon', tx['hex'], input_amounts, tx['amounts'], options)
diff --git a/test/functional/p2p_part_disable_types.py b/test/functional/p2p_part_disable_types.py
index 47092c983f..dc6032356d 100755
--- a/test/functional/p2p_part_disable_types.py
+++ b/test/functional/p2p_part_disable_types.py
@@ -47,9 +47,9 @@ def run_test(self):
         self.stakeBlocks(2)
 
         txids = []
-        txids.append(nodes[1].sendtypeto('anon', 'part', [{'address': sx1, 'amount': 1},]))
-        txids.append(nodes[1].sendtypeto('anon', 'blind', [{'address': sx1, 'amount': 1},]))
-        txids.append(nodes[1].sendtypeto('anon', 'anon', [{'address': sx1, 'amount': 1},]))
+        txids.append(nodes[1].sendtypeto('anon', 'part', [{'address': sx1, 'amount': 1},], '', '', 5))
+        txids.append(nodes[1].sendtypeto('anon', 'blind', [{'address': sx1, 'amount': 1},], '', '', 5))
+        txids.append(nodes[1].sendtypeto('anon', 'anon', [{'address': sx1, 'amount': 1},], '', '', 5))
         txids.append(nodes[1].sendtypeto('blind', 'part', [{'address': sx1, 'amount': 1},]))
         txids.append(nodes[1].sendtypeto('blind', 'anon', [{'address': sx1, 'amount': 1},]))
 
@@ -83,12 +83,12 @@ def run_test(self):
         except Exception:
             pass
         try:
-            nodes[1].sendtypeto('anon', 'part', [{'address': sx1, 'amount': 1},])
+            nodes[1].sendtypeto('anon', 'part', [{'address': sx1, 'amount': 1},], '', '', 5)
             assert(False)
         except Exception:
             pass
         try:
-            nodes[1].sendtypeto('anon', 'anon', [{'address': sx1, 'amount': 1},])
+            nodes[1].sendtypeto('anon', 'anon', [{'address': sx1, 'amount': 1},], '', '', 5)
             assert(False)
         except Exception:
             pass
@@ -99,13 +99,13 @@ def run_test(self):
             pass
 
         txids = []
-        txids.append(nodes[0].sendtypeto('anon', 'anon', [{'address': sx1, 'amount': 1},]))
+        txids.append(nodes[0].sendtypeto('anon', 'anon', [{'address': sx1, 'amount': 1},], '', '', 5))
         txids.append(nodes[0].sendtypeto('part', 'anon', [{'address': sx1, 'amount': 1},]))
-        txids.append(nodes[0].sendtypeto('anon', 'part', [{'address': sx1, 'amount': 1},]))
+        txids.append(nodes[0].sendtypeto('anon', 'part', [{'address': sx1, 'amount': 1},], '', '', 5))
         txids.append(nodes[0].sendtypeto('part', 'blind', [{'address': sx1, 'amount': 1},]))
         txids.append(nodes[0].sendtypeto('blind', 'part', [{'address': sx1, 'amount': 1},]))
         txids.append(nodes[0].sendtypeto('blind', 'anon', [{'address': sx1, 'amount': 1},]))
-        txids.append(nodes[0].sendtypeto('anon', 'blind', [{'address': sx1, 'amount': 1},]))
+        txids.append(nodes[0].sendtypeto('anon', 'blind', [{'address': sx1, 'amount': 1},], '', '', 5))
 
         for txid in txids:
             rtx = nodes[0].getrawtransaction(txid)
diff --git a/test/functional/rpc_part_filtertransactions.py b/test/functional/rpc_part_filtertransactions.py
index b92edd75e4..c21cb8032b 100755
--- a/test/functional/rpc_part_filtertransactions.py
+++ b/test/functional/rpc_part_filtertransactions.py
@@ -39,7 +39,7 @@ def run_test(self):
         selfStealth    = nodes[0].getnewstealthaddress('stealth')
         selfSpending   = nodes[0].getnewaddress('spending', 'false', 'false', 'true')
         targetAddress  = nodes[1].getnewaddress('target')
-        targetStealth  = nodes[1].getnewstealthaddress('taret stealth')
+        targetStealth  = nodes[1].getnewstealthaddress('target stealth')
         stakingAddress = nodes[2].getnewaddress('staking')
 
         # Simple PART transaction
diff --git a/test/functional/rpc_part_tracefrozenoutputs.py b/test/functional/rpc_part_tracefrozenoutputs.py
index 2ca8107e16..e05934fe03 100644
--- a/test/functional/rpc_part_tracefrozenoutputs.py
+++ b/test/functional/rpc_part_tracefrozenoutputs.py
@@ -51,7 +51,7 @@ def run_test(self):
             nodes[0].sendrawtransaction(nodes[1].getrawtransaction(txid_b2a))
         self.stakeBlocks(2)
 
-        txid_a2a = w1_2.sendtypeto('anon', 'anon', [{'address': w1_0_addr, 'amount': 20}])
+        txid_a2a = w1_2.sendtypeto('anon', 'anon', [{'address': w1_0_addr, 'amount': 20}], '', '', 5)
         nodes[0].sendrawtransaction(nodes[1].getrawtransaction(txid_a2a))
         self.stakeBlocks(2)
 
diff --git a/test/functional/test_framework/test_particl.py b/test/functional/test_framework/test_particl.py
index dc996eef94..90b0b3879a 100644
--- a/test/functional/test_framework/test_particl.py
+++ b/test/functional/test_framework/test_particl.py
@@ -85,11 +85,11 @@ def wait_for_height(self, node, nHeight, nTries=500):
                 return True
         return False
 
-    def wait_for_mempool(self, node, txnHash, nTries=50):
+    def wait_for_mempool(self, node, txid, nTries=50):
         for i in range(50):
             time.sleep(0.5)
             try:
-                ro = node.getmempoolentry(txnHash)
+                ro = node.getmempoolentry(txid)
 
                 if ro['vsize'] >= 100 and ro['height'] >= 0:
                     return True
@@ -97,6 +97,16 @@ def wait_for_mempool(self, node, txnHash, nTries=50):
                 continue
         return False
 
+    def wait_for_wtx(self, node, txid, nTries=20):
+        for i in range(50):
+            time.sleep(0.5)
+            try:
+                rv = node.gettransaction(txid)
+                return True
+            except:
+                continue
+        return False
+
     def waitForSmsgExchange(self, nMessages, nodeA, nodeB):
         nodes = self.nodes
 

From fc661f7b43ce22cc1d58aa25aa49f56b3a7cfc85 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Thu, 24 Feb 2022 02:39:10 +0200
Subject: [PATCH 17/57] build: Raise version to 0.21.2.7

---
 configure.ac                                |   2 +-
 contrib/gitian-descriptors/gitian-linux.yml |   2 +-
 contrib/gitian-descriptors/gitian-osx.yml   |   2 +-
 contrib/gitian-descriptors/gitian-win.yml   |   2 +-
 doc/man/particl-cli.1                       |  92 ++--
 doc/man/particl-qt.1                        | 486 ++++++++++----------
 doc/man/particl-tx.1                        |  66 +--
 doc/man/particl-wallet.1                    |  44 +-
 doc/man/particld.1                          | 476 +++++++++----------
 doc/release-notes-particl.md                |   5 +
 src/qt/locale/bitcoin_en.ts                 |  12 +-
 11 files changed, 597 insertions(+), 592 deletions(-)

diff --git a/configure.ac b/configure.ac
index e8ff9bbcb7..807c44f6f1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2,7 +2,7 @@ AC_PREREQ([2.69])
 define(_CLIENT_VERSION_MAJOR, 0)
 define(_CLIENT_VERSION_MINOR, 21)
 define(_CLIENT_VERSION_REVISION, 2)
-define(_CLIENT_VERSION_PARTICL, 6)
+define(_CLIENT_VERSION_PARTICL, 7)
 define(_CLIENT_VERSION_BUILD, 0)
 define(_CLIENT_VERSION_RC, 0)
 define(_CLIENT_VERSION_IS_RELEASE, true)
diff --git a/contrib/gitian-descriptors/gitian-linux.yml b/contrib/gitian-descriptors/gitian-linux.yml
index f9ea40aa61..483e3fcc3b 100644
--- a/contrib/gitian-descriptors/gitian-linux.yml
+++ b/contrib/gitian-descriptors/gitian-linux.yml
@@ -1,5 +1,5 @@
 ---
-name: "particl-linux-0.21.2.6"
+name: "particl-linux-0.21.2.7"
 enable_cache: true
 sudo: true
 distro: "ubuntu"
diff --git a/contrib/gitian-descriptors/gitian-osx.yml b/contrib/gitian-descriptors/gitian-osx.yml
index c6e5e6efc7..8e583a7284 100644
--- a/contrib/gitian-descriptors/gitian-osx.yml
+++ b/contrib/gitian-descriptors/gitian-osx.yml
@@ -1,5 +1,5 @@
 ---
-name: "particl-osx-0.21.2.6"
+name: "particl-osx-0.21.2.7"
 enable_cache: true
 distro: "ubuntu"
 suites:
diff --git a/contrib/gitian-descriptors/gitian-win.yml b/contrib/gitian-descriptors/gitian-win.yml
index 986286391f..98521293c0 100644
--- a/contrib/gitian-descriptors/gitian-win.yml
+++ b/contrib/gitian-descriptors/gitian-win.yml
@@ -1,5 +1,5 @@
 ---
-name: "particl-win-0.21.2.6"
+name: "particl-win-0.21.2.7"
 enable_cache: true
 sudo: true
 distro: "ubuntu"
diff --git a/doc/man/particl-cli.1 b/doc/man/particl-cli.1
index 45ce87129d..96fbbea324 100644
--- a/doc/man/particl-cli.1
+++ b/doc/man/particl-cli.1
@@ -1,7 +1,7 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.48.5.
-.TH PARTICL-CLI "1" "October 2021" "particl-cli v0.21.2.6.0" "User Commands"
+.TH PARTICL-CLI "1" "February 2022" "particl-cli v0.21.2.7" "User Commands"
 .SH NAME
-particl-cli \- manual page for particl-cli v0.21.2.6.0
+particl-cli  manual page for particl-cli v0.21.2.7
 .SH SYNOPSIS
 .B particl-cli
 [\fI\,options\/\fR] \fI\,<command> \/\fR[\fI\,params\/\fR]  \fI\,Send command to Particl Core\/\fR
@@ -15,109 +15,109 @@ particl-cli \- manual page for particl-cli v0.21.2.6.0
 .B particl-cli
 [\fI\,options\/\fR] \fI\,help <command>      Get help for a command\/\fR
 .SH DESCRIPTION
-Particl Core RPC client version v0.21.2.6.0
+Particl Core RPC client version v0.21.2.7
 .SH OPTIONS
 .HP
-\-?
+?
 .IP
 Print this help message and exit
 .HP
-\fB\-conf=\fR<file>
+\fBconf=\fR<file>
 .IP
 Specify configuration file. Relative paths will be prefixed by datadir
 location. (default: particl.conf)
 .HP
-\fB\-datadir=\fR<dir>
+\fBdatadir=\fR<dir>
 .IP
 Specify data directory
 .HP
-\fB\-generate\fR
+\fBgenerate\fR
 .IP
 Generate blocks immediately, equivalent to RPC generatenewaddress
 followed by RPC generatetoaddress. Optional positional integer
 arguments are number of blocks to generate (default: 1) and
 maximum iterations to try (default: 1000000), equivalent to RPC
 generatetoaddress nblocks and maxtries arguments. Example:
-bitcoin\-cli \fB\-generate\fR 4 1000
+bitcoincli \fBgenerate\fR 4 1000
 .HP
-\fB\-getinfo\fR
+\fBgetinfo\fR
 .IP
 Get general information from the remote server. Note that unlike
-server\-side RPC calls, the results of \fB\-getinfo\fR is the result of
-multiple non\-atomic requests. Some entries in the result may
+serverside RPC calls, the results of \fBgetinfo\fR is the result of
+multiple nonatomic requests. Some entries in the result may
 represent results from different states (e.g. wallet balance may
 be as of a different block from the chain state reported)
 .HP
-\fB\-named\fR
+\fBnamed\fR
 .IP
 Pass named instead of positional arguments (default: false)
 .HP
-\fB\-netinfo\fR
+\fBnetinfo\fR
 .IP
 Get network peer connection information from the remote server. An
 optional integer argument from 0 to 4 can be passed for different
 peers listings (default: 0).
 .HP
-\fB\-rpcclienttimeout=\fR<n>
+\fBrpcclienttimeout=\fR<n>
 .IP
 Timeout in seconds during HTTP requests, or 0 for no timeout. (default:
 900)
 .HP
-\fB\-rpcconnect=\fR<ip>
+\fBrpcconnect=\fR<ip>
 .IP
 Send commands to node running on <ip> (default: 127.0.0.1)
 .HP
-\fB\-rpccookiefile=\fR<loc>
+\fBrpccookiefile=\fR<loc>
 .IP
 Location of the auth cookie. Relative paths will be prefixed by a
-net\-specific datadir location. (default: data dir)
+netspecific datadir location. (default: data dir)
 .HP
-\fB\-rpcpassword=\fR<pw>
+\fBrpcpassword=\fR<pw>
 .IP
-Password for JSON\-RPC connections
+Password for JSONRPC connections
 .HP
-\fB\-rpcport=\fR<port>
+\fBrpcport=\fR<port>
 .IP
-Connect to JSON\-RPC on <port> (default: 51735, testnet: 51935, signet:
+Connect to JSONRPC on <port> (default: 51735, testnet: 51935, signet:
 31932, regtest: 51936)
 .HP
-\fB\-rpcuser=\fR<user>
+\fBrpcuser=\fR<user>
 .IP
-Username for JSON\-RPC connections
+Username for JSONRPC connections
 .HP
-\fB\-rpcwait\fR
+\fBrpcwait\fR
 .IP
 Wait for RPC server to start
 .HP
-\fB\-rpcwallet=\fR<walletname>
+\fBrpcwallet=\fR<walletname>
 .IP
-Send RPC for non\-default wallet on RPC server (needs to exactly match
-corresponding \fB\-wallet\fR option passed to particld). This changes
+Send RPC for nondefault wallet on RPC server (needs to exactly match
+corresponding \fBwallet\fR option passed to particld). This changes
 the RPC endpoint used, e.g.
 http://127.0.0.1:51735/wallet/<walletname>
 .HP
-\fB\-stdin\fR
+\fBstdin\fR
 .IP
-Read extra arguments from standard input, one per line until EOF/Ctrl\-D
+Read extra arguments from standard input, one per line until EOF/CtrlD
 (recommended for sensitive information such as passphrases). When
-combined with \fB\-stdinrpcpass\fR, the first line from standard input
+combined with \fBstdinrpcpass\fR, the first line from standard input
 is used for the RPC password.
 .HP
-\fB\-stdinrpcpass\fR
+\fBstdinrpcpass\fR
 .IP
 Read RPC password from standard input as a single line. When combined
-with \fB\-stdin\fR, the first line from standard input is used for the
-RPC password. When combined with \fB\-stdinwalletpassphrase\fR,
-\fB\-stdinrpcpass\fR consumes the first line, and \fB\-stdinwalletpassphrase\fR
+with \fBstdin\fR, the first line from standard input is used for the
+RPC password. When combined with \fBstdinwalletpassphrase\fR,
+\fBstdinrpcpass\fR consumes the first line, and \fBstdinwalletpassphrase\fR
 consumes the second.
 .HP
-\fB\-stdinwalletpassphrase\fR
+\fBstdinwalletpassphrase\fR
 .IP
 Read wallet passphrase from standard input as a single line. When
-combined with \fB\-stdin\fR, the first line from standard input is used
+combined with \fBstdin\fR, the first line from standard input is used
 for the wallet passphrase.
 .HP
-\fB\-version\fR
+\fBversion\fR
 .IP
 Print version and exit
 .PP
@@ -125,34 +125,34 @@ Debugging/Testing options:
 .PP
 Chain selection options:
 .HP
-\fB\-chain=\fR<chain>
+\fBchain=\fR<chain>
 .IP
 Use the chain <chain> (default: main). Allowed values: main, test,
 signet, regtest
 .HP
-\fB\-signet\fR
+\fBsignet\fR
 .IP
-Use the signet chain. Equivalent to \fB\-chain\fR=\fI\,signet\/\fR. Note that the network
-is defined by the \fB\-signetchallenge\fR parameter
+Use the signet chain. Equivalent to \fBchain\fR=\fI\,signet\/\fR. Note that the network
+is defined by the \fBsignetchallenge\fR parameter
 .HP
-\fB\-signetchallenge\fR
+\fBsignetchallenge\fR
 .IP
 Blocks must satisfy the given script to be considered valid (only for
 signet networks; defaults to the global default signet test
 network challenge)
 .HP
-\fB\-signetseednode\fR
+\fBsignetseednode\fR
 .IP
 Specify a seed node for the signet network, in the hostname[:port]
 format, e.g. sig.net:1234 (may be used multiple times to specify
 multiple seed nodes; defaults to the global default signet test
 network seed node(s))
 .HP
-\fB\-testnet\fR
+\fBtestnet\fR
 .IP
-Use the test chain. Equivalent to \fB\-chain\fR=\fI\,test\/\fR.
+Use the test chain. Equivalent to \fBchain\fR=\fI\,test\/\fR.
 .SH COPYRIGHT
-Copyright (C) 2017-2021 The Particl Core developers
+Copyright (C) 2017-2022 The Particl Core developers
 Copyright (C) 2009-2021 The Bitcoin Core developers
 
 Please contribute if you find Particl Core useful. Visit <https://particl.io/>
diff --git a/doc/man/particl-qt.1 b/doc/man/particl-qt.1
index d477cebd3c..38acaf9165 100644
--- a/doc/man/particl-qt.1
+++ b/doc/man/particl-qt.1
@@ -1,235 +1,235 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.48.5.
-.TH PARTICL-QT "1" "October 2021" "particl-qt v0.21.2.6.0" "User Commands"
+.TH PARTICL-QT "1" "February 2022" "particl-qt v0.21.2.7" "User Commands"
 .SH NAME
-particl-qt \- manual page for particl-qt v0.21.2.6.0
+particl-qt  manual page for particl-qt v0.21.2.7
 .SH SYNOPSIS
 .B particl-qt
 [\fI\,command-line options\/\fR]
 .SH DESCRIPTION
-Particl Core version v0.21.2.6.0
+Particl Core version v0.21.2.7
 .SH OPTIONS
 .HP
-\-?
+?
 .IP
 Print this help message and exit
 .HP
-\fB\-addressindex\fR
+\fBaddressindex\fR
 .IP
 Maintain a full address index, used to query for the balance, txids and
 unspent outputs for addresses (default: 0)
 .HP
-\fB\-alertnotify=\fR<cmd>
+\fBalertnotify=\fR<cmd>
 .IP
 Execute command when a relevant alert is received or we see a really
 long fork (%s in cmd is replaced by message)
 .HP
-\fB\-assumevalid=\fR<hex>
+\fBassumevalid=\fR<hex>
 .IP
 If this block is in the chain assume that it and its ancestors are valid
 and potentially skip their script verification (0 to verify all,
 default:
-dcbe7be05060974cca33a52790e047a73358812102a97cd5b3089f2469bd6601,
+6b13071bc3f5689a3f8a29808f726654283714461076ea890f4272574ff2659f,
 testnet:
-9313d6187a7b8bdd18f988d159331702ead08fe8001e602d5a42cb3a60f8313e,
+c8b34db63fb6ec97b557a969065e56167030c36c12b7c988561736ad3a5488c0,
 signet:
 0000002a1de0f46379358c1fd09906f7ac59adf3712323ed90eb59e4c183c020)
 .HP
-\fB\-balancesindex\fR
+\fBbalancesindex\fR
 .IP
 Maintain a balances index per block (default: 0)
 .HP
-\fB\-blockfilterindex=\fR<type>
+\fBblockfilterindex=\fR<type>
 .IP
 Maintain an index of compact filters by block (default: 0, values:
 basic). If <type> is not supplied or if <type> = 1, indexes for
 all known types are enabled.
 .HP
-\fB\-blocknotify=\fR<cmd>
+\fBblocknotify=\fR<cmd>
 .IP
 Execute command when the best block changes (%s in cmd is replaced by
 block hash)
 .HP
-\fB\-blockreconstructionextratxn=\fR<n>
+\fBblockreconstructionextratxn=\fR<n>
 .IP
 Extra transactions to keep in memory for compact block reconstructions
 (default: 100)
 .HP
-\fB\-blocksdir=\fR<dir>
+\fBblocksdir=\fR<dir>
 .IP
 Specify directory to hold blocks subdirectory for *.dat files (default:
 <datadir>)
 .HP
-\fB\-blocksonly\fR
+\fBblocksonly\fR
 .IP
 Whether to reject transactions from network peers. Automatic broadcast
 and rebroadcast of any transactions from inbound peers is
 disabled, unless the peer has the 'forcerelay' permission. RPC
 transactions are not affected. (default: 0)
 .HP
-\fB\-conf=\fR<file>
+\fBconf=\fR<file>
 .IP
-Specify path to read\-only configuration file. Relative paths will be
+Specify path to readonly configuration file. Relative paths will be
 prefixed by datadir location. (default: particl.conf)
 .HP
-\fB\-csindex\fR
+\fBcsindex\fR
 .IP
 Maintain an index of outputs by coldstaking address (default: 0)
 .HP
-\fB\-cswhitelist\fR
+\fBcswhitelist\fR
 .IP
 Only index coldstaked outputs with matching stake address. Can be
 specified multiple times.
 .HP
-\fB\-daemon\fR
+\fBdaemon\fR
 .IP
 Run in the background as a daemon and accept commands
 .HP
-\fB\-datadir=\fR<dir>
+\fBdatadir=\fR<dir>
 .IP
 Specify data directory
 .HP
-\fB\-dbcache=\fR<n>
+\fBdbcache=\fR<n>
 .IP
 Maximum database cache size <n> MiB (4 to 16384, default: 450). In
 addition, unused mempool memory is shared for this cache (see
-\fB\-maxmempool\fR).
+\fBmaxmempool\fR).
 .HP
-\fB\-dbcompression\fR
+\fBdbcompression\fR
 .IP
-Database compression parameter passed to level\-db (default: false)
+Database compression parameter passed to leveldb (default: false)
 .HP
-\fB\-dbmaxopenfiles\fR
+\fBdbmaxopenfiles\fR
 .IP
-Maximum number of open files parameter passed to level\-db (default: 64)
+Maximum number of open files parameter passed to leveldb (default: 64)
 .HP
-\fB\-debuglogfile=\fR<file>
+\fBdebuglogfile=\fR<file>
 .IP
 Specify location of debug log file. Relative paths will be prefixed by a
-net\-specific datadir location. (\fB\-nodebuglogfile\fR to disable;
+netspecific datadir location. (\fBnodebuglogfile\fR to disable;
 default: debug.log)
 .HP
-\fB\-includeconf=\fR<file>
+\fBincludeconf=\fR<file>
 .IP
-Specify additional configuration file, relative to the \fB\-datadir\fR path
+Specify additional configuration file, relative to the \fBdatadir\fR path
 (only useable from configuration file, not command line)
 .HP
-\fB\-loadblock=\fR<file>
+\fBloadblock=\fR<file>
 .IP
 Imports blocks from external file on startup
 .HP
-\fB\-maxmempool=\fR<n>
+\fBmaxmempool=\fR<n>
 .IP
 Keep the transaction memory pool below <n> megabytes (default: 300)
 .HP
-\fB\-maxorphantx=\fR<n>
+\fBmaxorphantx=\fR<n>
 .IP
 Keep at most <n> unconnectable transactions in memory (default: 100)
 .HP
-\fB\-mempoolexpiry=\fR<n>
+\fBmempoolexpiry=\fR<n>
 .IP
 Do not keep transactions in the mempool longer than <n> hours (default:
 336)
 .HP
-\fB\-par=\fR<n>
+\fBpar=\fR<n>
 .IP
-Set the number of script verification threads (\fB\-4\fR to 15, 0 = auto, <0 =
+Set the number of script verification threads (\fB4\fR to 15, 0 = auto, <0 =
 leave that many cores free, default: 0)
 .HP
-\fB\-persistmempool\fR
+\fBpersistmempool\fR
 .IP
 Whether to save the mempool on shutdown and load on restart (default: 1)
 .HP
-\fB\-pid=\fR<file>
+\fBpid=\fR<file>
 .IP
-Specify pid file. Relative paths will be prefixed by a net\-specific
+Specify pid file. Relative paths will be prefixed by a netspecific
 datadir location. (default: particl.pid)
 .HP
-\fB\-prune=\fR<n>
+\fBprune=\fR<n>
 .IP
 Reduce storage requirements by enabling pruning (deleting) of old
 blocks. This allows the pruneblockchain RPC to be called to
 delete specific blocks, and enables automatic pruning of old
 blocks if a target size in MiB is provided. This mode is
-incompatible with \fB\-txindex\fR and \fB\-rescan\fR. Warning: Reverting this
-setting requires re\-downloading the entire blockchain. (default:
+incompatible with \fBtxindex\fR and \fBrescan\fR. Warning: Reverting this
+setting requires redownloading the entire blockchain. (default:
 0 = disable pruning blocks, 1 = allow manual pruning via RPC,
 >=550 = automatically prune block files to stay under the
 specified target size in MiB)
 .HP
-\fB\-reindex\fR
+\fBreindex\fR
 .IP
 Rebuild chain state and block index from the blk*.dat files on disk
 .HP
-\fB\-reindex\-chainstate\fR
+\fBreindexchainstate\fR
 .IP
 Rebuild chain state from the currently indexed blocks. When in pruning
-mode or if blocks on disk might be corrupted, use full \fB\-reindex\fR
+mode or if blocks on disk might be corrupted, use full \fBreindex\fR
 instead.
 .HP
-\fB\-settings=\fR<file>
+\fBsettings=\fR<file>
 .IP
 Specify path to dynamic settings data file. Can be disabled with
-\fB\-nosettings\fR. File is written at runtime and not meant to be
+\fBnosettings\fR. File is written at runtime and not meant to be
 edited by users (use particl.conf instead for custom settings).
 Relative paths will be prefixed by datadir location. (default:
 settings.json)
 .HP
-\fB\-skiprangeproofverify\fR
+\fBskiprangeproofverify\fR
 .IP
 Skip verifying rangeproofs when reindexing or importing.
 .HP
-\fB\-spentindex\fR
+\fBspentindex\fR
 .IP
 Maintain a full spent index, used to query the spending txid and input
 index for an outpoint (default: 0)
 .HP
-\fB\-startupnotify=\fR<cmd>
+\fBstartupnotify=\fR<cmd>
 .IP
 Execute command on startup.
 .HP
-\fB\-sysperms\fR
+\fBsysperms\fR
 .IP
 Create new files with system default permissions, instead of umask 077
 (only effective with disabled wallet functionality)
 .HP
-\fB\-timestampindex\fR
+\fBtimestampindex\fR
 .IP
 Maintain a timestamp index for block hashes, used to query blocks hashes
 by a range of timestamps (default: 0)
 .HP
-\fB\-txindex\fR
+\fBtxindex\fR
 .IP
 Maintain a full transaction index, used by the getrawtransaction rpc
 call (default: 0)
 .HP
-\fB\-version\fR
+\fBversion\fR
 .IP
 Print version and exit
 .PP
 Connection options:
 .HP
-\fB\-addnode=\fR<ip>
+\fBaddnode=\fR<ip>
 .IP
 Add a node to connect to and attempt to keep the connection open (see
 the `addnode` RPC command help for more info). This option can be
 specified multiple times to add multiple nodes.
 .HP
-\fB\-asmap=\fR<file>
+\fBasmap=\fR<file>
 .IP
 Specify asn mapping used for bucketing of the peers (default:
-ip_asn.map). Relative paths will be prefixed by the net\-specific
+ip_asn.map). Relative paths will be prefixed by the netspecific
 datadir location.
 .HP
-\fB\-banscore=\fR<n>
+\fBbanscore=\fR<n>
 .IP
 Threshold for disconnecting misbehaving peers (default: 100)
 .HP
-\fB\-bantime=\fR<n>
+\fBbantime=\fR<n>
 .IP
 Default duration (in seconds) of manually configured bans (default:
 86400)
 .HP
-\fB\-bind=\fR<addr>[:<port>][=onion]
+\fBbind=\fR<addr>[:<port>][=onion]
 .IP
 Bind to given address and always listen on it (default: 0.0.0.0). Use
 [host]:port notation for IPv6. Append =onion to tag any incoming
@@ -237,202 +237,202 @@ connections to that address and port as incoming Tor connections
 (default: 127.0.0.1:51734=onion, testnet: 127.0.0.1:51934=onion,
 signet: 127.0.0.1:31934=onion, regtest: 127.0.0.1:51931=onion)
 .HP
-\fB\-connect=\fR<ip>
+\fBconnect=\fR<ip>
 .IP
-Connect only to the specified node; \fB\-noconnect\fR disables automatic
+Connect only to the specified node; \fBnoconnect\fR disables automatic
 connections (the rules for this peer are the same as for
-\fB\-addnode\fR). This option can be specified multiple times to connect
+\fBaddnode\fR). This option can be specified multiple times to connect
 to multiple nodes.
 .HP
-\fB\-discover\fR
+\fBdiscover\fR
 .IP
-Discover own IP addresses (default: 1 when listening and no \fB\-externalip\fR
-or \fB\-proxy\fR)
+Discover own IP addresses (default: 1 when listening and no \fBexternalip\fR
+or \fBproxy\fR)
 .HP
-\fB\-dns\fR
+\fBdns\fR
 .IP
-Allow DNS lookups for \fB\-addnode\fR, \fB\-seednode\fR and \fB\-connect\fR (default: 1)
+Allow DNS lookups for \fBaddnode\fR, \fBseednode\fR and \fBconnect\fR (default: 1)
 .HP
-\fB\-dnsseed\fR
+\fBdnsseed\fR
 .IP
 Query for peer addresses via DNS lookup, if low on addresses (default: 1
-unless \fB\-connect\fR used)
+unless \fBconnect\fR used)
 .HP
-\fB\-externalip=\fR<ip>
+\fBexternalip=\fR<ip>
 .IP
 Specify your own public address
 .HP
-\fB\-findpeers\fR
+\fBfindpeers\fR
 .IP
 Node will search for peers (default: 1)
 .HP
-\fB\-forcednsseed\fR
+\fBforcednsseed\fR
 .IP
 Always query for peer addresses via DNS lookup (default: 0)
 .HP
-\fB\-listen\fR
+\fBlisten\fR
 .IP
-Accept connections from outside (default: 1 if no \fB\-proxy\fR or \fB\-connect\fR)
+Accept connections from outside (default: 1 if no \fBproxy\fR or \fBconnect\fR)
 .HP
-\fB\-listenonion\fR
+\fBlistenonion\fR
 .IP
 Automatically create Tor hidden service (default: 1)
 .HP
-\fB\-lookuptorcontrolhost=\fR<protocol>
+\fBlookuptorcontrolhost=\fR<protocol>
 .IP
-Allow a hostname to be specified for the \fB\-torcontrol\fR option. Must be
+Allow a hostname to be specified for the \fBtorcontrol\fR option. Must be
 "any", "ipv4", or "ipv6" (default: )
 .HP
-\fB\-maxconnections=\fR<n>
+\fBmaxconnections=\fR<n>
 .IP
 Maintain at most <n> connections to peers (default: 125)
 .HP
-\fB\-maxreceivebuffer=\fR<n>
+\fBmaxreceivebuffer=\fR<n>
 .IP
-Maximum per\-connection receive buffer, <n>*1000 bytes (default: 5000)
+Maximum perconnection receive buffer, <n>*1000 bytes (default: 5000)
 .HP
-\fB\-maxsendbuffer=\fR<n>
+\fBmaxsendbuffer=\fR<n>
 .IP
-Maximum per\-connection send buffer, <n>*1000 bytes (default: 1000)
+Maximum perconnection send buffer, <n>*1000 bytes (default: 1000)
 .HP
-\fB\-maxtimeadjustment\fR
+\fBmaxtimeadjustment\fR
 .IP
 Maximum allowed median peer time offset adjustment. Local perspective of
 time may be influenced by peers forward or backward by this
 amount. (default: 4200 seconds)
 .HP
-\fB\-maxuploadtarget=\fR<n>
+\fBmaxuploadtarget=\fR<n>
 .IP
 Tries to keep outbound traffic under the given target (in MiB per 24h).
 Limit does not apply to peers with 'download' permission. 0 = no
 limit (default: 0)
 .HP
-\fB\-networkactive\fR
+\fBnetworkactive\fR
 .IP
 Enable all P2P network activity (default: 1). Can be changed by the
 setnetworkactive RPC command
 .HP
-\fB\-onion=\fR<ip:port>
+\fBonion=\fR<ip:port>
 .IP
 Use separate SOCKS5 proxy to reach peers via Tor hidden services, set
-\fB\-noonion\fR to disable (default: \fB\-proxy\fR)
+\fBnoonion\fR to disable (default: \fBproxy\fR)
 .HP
-\fB\-onlynet=\fR<net>
+\fBonlynet=\fR<net>
 .IP
 Make outgoing connections only through network <net> (ipv4, ipv6 or
 onion). Incoming connections are not affected by this option.
 This option can be specified multiple times to allow multiple
 networks.
 .HP
-\fB\-peerblockfilters\fR
+\fBpeerblockfilters\fR
 .IP
 Serve compact block filters to peers per BIP 157 (default: 0)
 .HP
-\fB\-peerbloomfilters\fR
+\fBpeerbloomfilters\fR
 .IP
 Support filtering of blocks and transaction with bloom filters (default:
 0)
 .HP
-\fB\-peertimeout=\fR<n>
+\fBpeertimeout=\fR<n>
 .IP
 Specify p2p connection timeout in seconds. This option determines the
 amount of time a peer may be inactive before the connection to it
 is dropped. (minimum: 1, default: 60)
 .HP
-\fB\-permitbaremultisig\fR
+\fBpermitbaremultisig\fR
 .IP
-Relay non\-P2SH multisig (default: 1)
+Relay nonP2SH multisig (default: 1)
 .HP
-\fB\-port=\fR<port>
+\fBport=\fR<port>
 .IP
 Listen for connections on <port>. Nodes not using the default ports
 (default: 51738, testnet: 51938, signet: 38333, regtest: 11938)
 are unlikely to get incoming connections.
 .HP
-\fB\-proxy=\fR<ip:port>
+\fBproxy=\fR<ip:port>
 .IP
-Connect through SOCKS5 proxy, set \fB\-noproxy\fR to disable (default:
+Connect through SOCKS5 proxy, set \fBnoproxy\fR to disable (default:
 disabled)
 .HP
-\fB\-proxyrandomize\fR
+\fBproxyrandomize\fR
 .IP
 Randomize credentials for every proxy connection. This enables Tor
 stream isolation (default: 1)
 .HP
-\fB\-seednode=\fR<ip>
+\fBseednode=\fR<ip>
 .IP
 Connect to a node to retrieve peer addresses, and disconnect. This
 option can be specified multiple times to connect to multiple
 nodes.
 .HP
-\fB\-timeout=\fR<n>
+\fBtimeout=\fR<n>
 .IP
 Specify connection timeout in milliseconds (minimum: 1, default: 5000)
 .HP
-\fB\-torcontrol=\fR<ip>:<port>
+\fBtorcontrol=\fR<ip>:<port>
 .IP
 Tor control port to use if onion listening enabled (default:
 127.0.0.1:9051)
 .HP
-\fB\-torpassword=\fR<pass>
+\fBtorpassword=\fR<pass>
 .IP
 Tor control port password (default: empty)
 .HP
-\fB\-upnp\fR
+\fBupnp\fR
 .IP
 Use UPnP to map the listening port (default: 0)
 .HP
-\fB\-whitebind=\fR<[permissions@]addr>
+\fBwhitebind=\fR<[permissions@]addr>
 .IP
 Bind to the given address and add permission flags to the peers
 connecting to it. Use [host]:port notation for IPv6. Allowed
 permissions: bloomfilter (allow requesting BIP37 filtered blocks
 and transactions), noban (do not ban for misbehavior; implies
 download), forcerelay (relay transactions that are already in the
-mempool; implies relay), relay (relay even in \fB\-blocksonly\fR mode,
+mempool; implies relay), relay (relay even in \fBblocksonly\fR mode,
 and unlimited transaction announcements), mempool (allow
 requesting BIP35 mempool contents), download (allow getheaders
 during IBD, no disconnect after maxuploadtarget limit), addr
 (responses to GETADDR avoid hitting the cache and contain random
-records with the most up\-to\-date info). Specify multiple
+records with the most uptodate info). Specify multiple
 permissions separated by commas (default:
 download,noban,mempool,relay). Can be specified multiple times.
 .HP
-\fB\-whitelist=\fR<[permissions@]IP address or network>
+\fBwhitelist=\fR<[permissions@]IP address or network>
 .IP
 Add permission flags to the peers connecting from the given IP address
-(e.g. 1.2.3.4) or CIDR\-notated network (e.g. 1.2.3.0/24). Uses
-the same permissions as \fB\-whitebind\fR. Can be specified multiple
+(e.g. 1.2.3.4) or CIDRnotated network (e.g. 1.2.3.0/24). Uses
+the same permissions as \fBwhitebind\fR. Can be specified multiple
 times.
 .PP
 Wallet options:
 .HP
-\fB\-addresstype\fR
+\fBaddresstype\fR
 .IP
-What type of addresses to use ("legacy", "p2sh\-segwit", or "bech32",
+What type of addresses to use ("legacy", "p2shsegwit", or "bech32",
 default: "bech32")
 .HP
-\fB\-avoidpartialspends\fR
+\fBavoidpartialspends\fR
 .IP
 Group outputs by address, selecting all or none, instead of selecting on
-a per\-output basis. Privacy is improved as an address is only
+a peroutput basis. Privacy is improved as an address is only
 used once (unless someone sends to it after spending from it),
 but may result in slightly higher fees as suboptimal coin
 selection may result due to the added limitation (default: 0
 (always enabled for wallets with "avoid_reuse" enabled))
 .HP
-\fB\-changetype\fR
+\fBchangetype\fR
 .IP
-What type of change to use ("legacy", "p2sh\-segwit", or "bech32").
-Default is same as \fB\-addresstype\fR, except when
-\fB\-addresstype\fR=\fI\,p2sh\-segwit\/\fR a native segwit output is used when
+What type of change to use ("legacy", "p2shsegwit", or "bech32").
+Default is same as \fBaddresstype\fR, except when
+\fBaddresstype\fR=\fI\,p2shsegwit\/\fR a native segwit output is used when
 sending to a native segwit address)
 .HP
-\fB\-disablewallet\fR
+\fBdisablewallet\fR
 .IP
 Do not load the wallet and disable wallet RPC calls
 .HP
-\fB\-discardfee=\fR<amt>
+\fBdiscardfee=\fR<amt>
 .IP
 The fee rate (in PART/kB) that indicates your tolerance for discarding
 change by adding it to the fee (default: 0.0001). Note: An output
@@ -440,66 +440,66 @@ is discarded if it is dust at this rate, but we will always
 discard up to the dust relay fee and a discard fee above that is
 limited by the fee estimate for the longest target
 .HP
-\fB\-fallbackfee=\fR<amt>
+\fBfallbackfee=\fR<amt>
 .IP
 A fee rate (in PART/kB) that will be used when fee estimation has
 insufficient data. 0 to entirely disable the fallbackfee feature.
 (default: 0.00)
 .HP
-\fB\-keypool=\fR<n>
+\fBkeypool=\fR<n>
 .IP
 Set key pool size to <n> (default: 1000). Warning: Smaller sizes may
 increase the risk of losing funds when restoring from an old
 backup, if none of the addresses in the original keypool have
 been used.
 .HP
-\fB\-maxapsfee=\fR<n>
+\fBmaxapsfee=\fR<n>
 .IP
 Spend up to this amount in additional (absolute) fees (in PART) if it
 allows the use of partial spend avoidance (default: 0.00)
 .HP
-\fB\-mintxfee=\fR<amt>
+\fBmintxfee=\fR<amt>
 .IP
 Fees (in PART/kB) smaller than this are considered zero fee for
 transaction creation (default: 0.002)
 .HP
-\fB\-paytxfee=\fR<amt>
+\fBpaytxfee=\fR<amt>
 .IP
 Fee (in PART/kB) to add to transactions you send (default: 0.00)
 .HP
-\fB\-rescan\fR
+\fBrescan\fR
 .IP
 Rescan the block chain for missing wallet transactions on startup
 .HP
-\fB\-spendzeroconfchange\fR
+\fBspendzeroconfchange\fR
 .IP
 Spend unconfirmed change when sending transactions (default: 1)
 .HP
-\fB\-txconfirmtarget=\fR<n>
+\fBtxconfirmtarget=\fR<n>
 .IP
 If paytxfee is not set, include enough fee so transactions begin
 confirmation on average within n blocks (default: 6)
 .HP
-\fB\-wallet=\fR<path>
+\fBwallet=\fR<path>
 .IP
 Specify wallet path to load at startup. Can be used multiple times to
 load multiple wallets. Path is to a directory containing wallet
 data and log files. If the path is not absolute, it is
 interpreted relative to <walletdir>. This only loads existing
 wallets and does not create new ones. For backwards compatibility
-this also accepts names of existing top\-level data files in
+this also accepts names of existing toplevel data files in
 <walletdir>.
 .HP
-\fB\-walletbroadcast\fR
+\fBwalletbroadcast\fR
 .IP
 Make the wallet broadcast transactions (default: 1)
 .HP
-\fB\-walletdir=\fR<dir>
+\fBwalletdir=\fR<dir>
 .IP
 Specify directory to hold wallets (default: <datadir>/wallets if it
 exists, otherwise <datadir>)
 .HP
-\fB\-walletnotify=\fR<cmd>
+\fBwalletnotify=\fR<cmd>
 .IP
 Execute command when a wallet transaction changes. %s in cmd is replaced
 by TxID and %w is replaced by wallet name. %w is not currently
@@ -507,81 +507,81 @@ implemented on windows. On systems where %w is supported, it
 should NOT be quoted because this would break shell escaping used
 to invoke the command.
 .HP
-\fB\-walletrbf\fR
+\fBwalletrbf\fR
 .IP
-Send transactions with full\-RBF opt\-in enabled (RPC only, default: 0)
+Send transactions with fullRBF optin enabled (RPC only, default: 0)
 .PP
 ZeroMQ notification options:
 .HP
-\fB\-newserverkeypairzmq\fR
+\fBnewserverkeypairzmq\fR
 .IP
 Generate new key pair for CurveZMQ, print and exit.
 .HP
-\fB\-serverkeyzmq=\fR<secret_key>
+\fBserverkeyzmq=\fR<secret_key>
 .IP
 Base64 encoded string of the z85 encoded secret key for CurveZMQ.
 .HP
-\fB\-whitelistzmq=\fR<IP address or network>
+\fBwhitelistzmq=\fR<IP address or network>
 .IP
 Whitelist peers connecting from the given IP address (e.g. 1.2.3.4) or
 CIDR notated network (e.g. 1.2.3.0/24). Can be specified multiple
 times.
 .HP
-\fB\-zmqpubhashblock=\fR<address>
+\fBzmqpubhashblock=\fR<address>
 .IP
 Enable publish hash block in <address>
 .HP
-\fB\-zmqpubhashblockhwm=\fR<n>
+\fBzmqpubhashblockhwm=\fR<n>
 .IP
 Set publish hash block outbound message high water mark (default: 1000)
 .HP
-\fB\-zmqpubhashtx=\fR<address>
+\fBzmqpubhashtx=\fR<address>
 .IP
 Enable publish hash transaction in <address>
 .HP
-\fB\-zmqpubhashtxhwm=\fR<n>
+\fBzmqpubhashtxhwm=\fR<n>
 .IP
 Set publish hash transaction outbound message high water mark (default:
 1000)
 .HP
-\fB\-zmqpubhashwtx=\fR<address>
+\fBzmqpubhashwtx=\fR<address>
 .IP
 Enable publish hash transaction received by wallets in <address>
 .HP
-\fB\-zmqpubrawblock=\fR<address>
+\fBzmqpubrawblock=\fR<address>
 .IP
 Enable publish raw block in <address>
 .HP
-\fB\-zmqpubrawblockhwm=\fR<n>
+\fBzmqpubrawblockhwm=\fR<n>
 .IP
 Set publish raw block outbound message high water mark (default: 1000)
 .HP
-\fB\-zmqpubrawtx=\fR<address>
+\fBzmqpubrawtx=\fR<address>
 .IP
 Enable publish raw transaction in <address>
 .HP
-\fB\-zmqpubrawtxhwm=\fR<n>
+\fBzmqpubrawtxhwm=\fR<n>
 .IP
 Set publish raw transaction outbound message high water mark (default:
 1000)
 .HP
-\fB\-zmqpubsequence=\fR<address>
+\fBzmqpubsequence=\fR<address>
 .IP
 Enable publish hash block and tx sequence in <address>
 .HP
-\fB\-zmqpubsequencehwm=\fR<n>
+\fBzmqpubsequencehwm=\fR<n>
 .IP
 Set publish hash sequence message high water mark (default: 1000)
 .HP
-\fB\-zmqpubsmsg=\fR<address>
+\fBzmqpubsmsg=\fR<address>
 .IP
 Enable publish secure message in <address>
 .PP
 Debugging/Testing options:
 .HP
-\fB\-debug=\fR<category>
+\fBdebug=\fR<category>
 .IP
-Output debugging information (default: \fB\-nodebug\fR, supplying <category> is
+Output debugging information (default: \fBnodebug\fR, supplying <category> is
 optional). If <category> is not supplied or if <category> = 1,
 output all debugging information. <category> can be: net, tor,
 mempool, http, bench, zmq, walletdb, rpc, estimatefee, addrman,
@@ -589,104 +589,104 @@ selectcoins, reindex, cmpctblock, rand, prune, proxy, mempoolrej,
 libevent, coindb, qt, leveldb, validation, smsg, ringct, pos,
 hdwallet.
 .HP
-\fB\-debugexclude=\fR<category>
+\fBdebugexclude=\fR<category>
 .IP
 Exclude debugging information for a category. Can be used in conjunction
-with \fB\-debug\fR=\fI\,1\/\fR to output debug logs for all categories except one
+with \fBdebug\fR=\fI\,1\/\fR to output debug logs for all categories except one
 or more specified categories.
 .HP
-\fB\-help\-debug\fR
+\fBhelpdebug\fR
 .IP
 Print help message with debugging options and exit
 .HP
-\fB\-logips\fR
+\fBlogips\fR
 .IP
 Include IP addresses in debug output (default: 0)
 .HP
-\fB\-logthreadnames\fR
+\fBlogthreadnames\fR
 .IP
 Prepend debug output with name of the originating thread (only available
 on platforms supporting thread_local) (default: 0)
 .HP
-\fB\-logtimestamps\fR
+\fBlogtimestamps\fR
 .IP
 Prepend debug output with timestamp (default: 1)
 .HP
-\fB\-maxtxfee=\fR<amt>
+\fBmaxtxfee=\fR<amt>
 .IP
 Maximum total fees (in PART) to use in a single wallet transaction;
 setting this too low may abort large transactions (default: 0.50)
 .HP
-\fB\-printtoconsole\fR
+\fBprinttoconsole\fR
 .IP
-Send trace/debug info to console (default: 1 when no \fB\-daemon\fR. To disable
-logging to file, set \fB\-nodebuglogfile\fR)
+Send trace/debug info to console (default: 1 when no \fBdaemon\fR. To disable
+logging to file, set \fBnodebuglogfile\fR)
 .HP
-\fB\-shrinkdebugfile\fR
+\fBshrinkdebugfile\fR
 .IP
-Shrink debug.log file on client startup (default: 1 when no \fB\-debug\fR)
+Shrink debug.log file on client startup (default: 1 when no \fBdebug\fR)
 .HP
-\fB\-uacomment=\fR<cmt>
+\fBuacomment=\fR<cmt>
 .IP
 Append comment to the user agent string
 .PP
 Chain selection options:
 .HP
-\fB\-chain=\fR<chain>
+\fBchain=\fR<chain>
 .IP
 Use the chain <chain> (default: main). Allowed values: main, test,
 signet, regtest
 .HP
-\fB\-signet\fR
+\fBsignet\fR
 .IP
-Use the signet chain. Equivalent to \fB\-chain\fR=\fI\,signet\/\fR. Note that the network
-is defined by the \fB\-signetchallenge\fR parameter
+Use the signet chain. Equivalent to \fBchain\fR=\fI\,signet\/\fR. Note that the network
+is defined by the \fBsignetchallenge\fR parameter
 .HP
-\fB\-signetchallenge\fR
+\fBsignetchallenge\fR
 .IP
 Blocks must satisfy the given script to be considered valid (only for
 signet networks; defaults to the global default signet test
 network challenge)
 .HP
-\fB\-signetseednode\fR
+\fBsignetseednode\fR
 .IP
 Specify a seed node for the signet network, in the hostname[:port]
 format, e.g. sig.net:1234 (may be used multiple times to specify
 multiple seed nodes; defaults to the global default signet test
 network seed node(s))
 .HP
-\fB\-testnet\fR
+\fBtestnet\fR
 .IP
-Use the test chain. Equivalent to \fB\-chain\fR=\fI\,test\/\fR.
+Use the test chain. Equivalent to \fBchain\fR=\fI\,test\/\fR.
 .PP
 Node relay options:
 .HP
-\fB\-bytespersigop\fR
+\fBbytespersigop\fR
 .IP
 Equivalent bytes per sigop in transactions for relay and mining
 (default: 20)
 .HP
-\fB\-datacarrier\fR
+\fBdatacarrier\fR
 .IP
 Relay and mine data carrier transactions (default: 1)
 .HP
-\fB\-datacarriersize\fR
+\fBdatacarriersize\fR
 .IP
 Maximum size of data in data carrier transactions we relay and mine
 (default: 83)
 .HP
-\fB\-minrelaytxfee=\fR<amt>
+\fBminrelaytxfee=\fR<amt>
 .IP
 Fees (in PART/kB) smaller than this are considered zero fee for
 relaying, mining and transaction creation (default: 0.00001)
 .HP
-\fB\-whitelistforcerelay\fR
+\fBwhitelistforcerelay\fR
 .IP
 Add 'forcerelay' permission to whitelisted inbound peers with default
 permissions. This will relay transactions even if the
 transactions were already in the mempool. (default: 0)
 .HP
-\fB\-whitelistrelay\fR
+\fBwhitelistrelay\fR
 .IP
 Add 'relay' permission to whitelisted inbound peers with default
 permissions. This will accept relayed transactions even when not
@@ -694,238 +694,238 @@ relaying transactions (default: 1)
 .PP
 Block creation options:
 .HP
-\fB\-blockmaxweight=\fR<n>
+\fBblockmaxweight=\fR<n>
 .IP
 Set maximum BIP141 block weight (default: 3996000)
 .HP
-\fB\-blockmintxfee=\fR<amt>
+\fBblockmintxfee=\fR<amt>
 .IP
 Set lowest fee rate (in PART/kB) for transactions to be included in
 block creation. (default: 0.00001)
 .PP
 RPC server options:
 .HP
-\fB\-acceptanontxn\fR
+\fBacceptanontxn\fR
 .IP
 Relay and mine "anon" transactions (default: 0)
 .HP
-\fB\-acceptblindtxn\fR
+\fBacceptblindtxn\fR
 .IP
 Relay and mine "anon" transactions (default: 0)
 .HP
-\fB\-checkpeerheight\fR
+\fBcheckpeerheight\fR
 .IP
-Consider peer height for initial\-block\-download status (default: true)
+Consider peer height for initialblockdownload status (default: true)
 .HP
-\fB\-displaylocaltime\fR
+\fBdisplaylocaltime\fR
 .IP
 Display human readable time strings in local timezone (default: false)
 .HP
-\fB\-displayutctime\fR
+\fBdisplayutctime\fR
 .IP
 Display human readable time strings in UTC (default: false)
 .HP
-\fB\-rebuildrollingindices\fR
+\fBrebuildrollingindices\fR
 .IP
 Force rebuild of rolling indices (default: false)
 .HP
-\fB\-rest\fR
+\fBrest\fR
 .IP
 Accept public REST requests (default: 0)
 .HP
-\fB\-rpcallowip=\fR<ip>
+\fBrpcallowip=\fR<ip>
 .IP
-Allow JSON\-RPC connections from specified source. Valid for <ip> are a
+Allow JSONRPC connections from specified source. Valid for <ip> are a
 single IP (e.g. 1.2.3.4), a network/netmask (e.g.
 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This
 option can be specified multiple times
 .HP
-\fB\-rpcauth=\fR<userpw>
+\fBrpcauth=\fR<userpw>
 .IP
-Username and HMAC\-SHA\-256 hashed password for JSON\-RPC connections. The
+Username and HMACSHA256 hashed password for JSONRPC connections. The
 field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A
 canonical python script is included in share/rpcauth. The client
 then connects normally using the
 rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This
 option can be specified multiple times
 .HP
-\fB\-rpcbind=\fR<addr>[:port]
+\fBrpcbind=\fR<addr>[:port]
 .IP
-Bind to given address to listen for JSON\-RPC connections. Do not expose
+Bind to given address to listen for JSONRPC connections. Do not expose
 the RPC server to untrusted networks such as the public internet!
-This option is ignored unless \fB\-rpcallowip\fR is also passed. Port is
-optional and overrides \fB\-rpcport\fR. Use [host]:port notation for
+This option is ignored unless \fBrpcallowip\fR is also passed. Port is
+optional and overrides \fBrpcport\fR. Use [host]:port notation for
 IPv6. This option can be specified multiple times (default:
 127.0.0.1 and ::1 i.e., localhost)
 .HP
-\fB\-rpccookiefile=\fR<loc>
+\fBrpccookiefile=\fR<loc>
 .IP
 Location of the auth cookie. Relative paths will be prefixed by a
-net\-specific datadir location. (default: data dir)
+netspecific datadir location. (default: data dir)
 .HP
-\fB\-rpccorsdomain=\fR<domain>
+\fBrpccorsdomain=\fR<domain>
 .IP
-Allow JSON\-RPC connections from specified domain (e.g.
+Allow JSONRPC connections from specified domain (e.g.
 http://localhost:4200 or "*"). This needs to be set if you are
 using the Particl GUI in a browser.
 .HP
-\fB\-rpcpassword=\fR<pw>
+\fBrpcpassword=\fR<pw>
 .IP
-Password for JSON\-RPC connections
+Password for JSONRPC connections
 .HP
-\fB\-rpcport=\fR<port>
+\fBrpcport=\fR<port>
 .IP
-Listen for JSON\-RPC connections on <port> (default: 51735, testnet:
+Listen for JSONRPC connections on <port> (default: 51735, testnet:
 51935, signet: 31932, regtest: 51936)
 .HP
-\fB\-rpcserialversion\fR
+\fBrpcserialversion\fR
 .IP
 Sets the serialization of raw transaction or block hex returned in
-non\-verbose mode, non\-segwit(0) or segwit(1) (default: 1)
+nonverbose mode, nonsegwit(0) or segwit(1) (default: 1)
 .HP
-\fB\-rpcthreads=\fR<n>
+\fBrpcthreads=\fR<n>
 .IP
 Set the number of threads to service RPC calls (default: 4)
 .HP
-\fB\-rpcuser=\fR<user>
+\fBrpcuser=\fR<user>
 .IP
-Username for JSON\-RPC connections
+Username for JSONRPC connections
 .HP
-\fB\-rpcwhitelist=\fR<whitelist>
+\fBrpcwhitelist=\fR<whitelist>
 .IP
 Set a whitelist to filter incoming RPC calls for a specific user. The
 field <whitelist> comes in the format: <USERNAME>:<rpc 1>,<rpc
 2>,...,<rpc n>. If multiple whitelists are set for a given user,
-they are set\-intersected. See \fB\-rpcwhitelistdefault\fR documentation
+they are setintersected. See \fBrpcwhitelistdefault\fR documentation
 for information on default whitelist behavior.
 .HP
-\fB\-rpcwhitelistdefault\fR
+\fBrpcwhitelistdefault\fR
 .IP
 Sets default behavior for rpc whitelisting. Unless rpcwhitelistdefault
-is set to 0, if any \fB\-rpcwhitelist\fR is set, the rpc server acts as
-if all rpc users are subject to empty\-unless\-otherwise\-specified
+is set to 0, if any \fBrpcwhitelist\fR is set, the rpc server acts as
+if all rpc users are subject to emptyunlessotherwisespecified
 whitelists. If rpcwhitelistdefault is set to 1 and no
-\fB\-rpcwhitelist\fR is set, rpc server acts as if all rpc users are
+\fBrpcwhitelist\fR is set, rpc server acts as if all rpc users are
 subject to empty whitelists.
 .HP
-\fB\-server\fR
+\fBserver\fR
 .IP
-Accept command line and JSON\-RPC commands
+Accept command line and JSONRPC commands
 .PP
 UI Options:
 .HP
-\fB\-choosedatadir\fR
+\fBchoosedatadir\fR
 .IP
 Choose data directory on startup (default: 0)
 .HP
-\fB\-lang=\fR<lang>
+\fBlang=\fR<lang>
 .IP
 Set language, for example "de_DE" (default: system locale)
 .HP
-\fB\-min\fR
+\fBmin\fR
 .IP
 Start minimized
 .HP
-\fB\-resetguisettings\fR
+\fBresetguisettings\fR
 .IP
 Reset all settings changed in the GUI
 .HP
-\fB\-splash\fR
+\fBsplash\fR
 .IP
 Show splash screen on startup (default: 1)
 .PP
 SMSG Commands:
 .HP
-\fB\-smsg\fR
+\fBsmsg\fR
 .IP
 Enable secure messaging. (default: true)
 .HP
-\fB\-smsgbantime=\fR<n>
+\fBsmsgbantime=\fR<n>
 .IP
 Number of seconds to ignore misbehaving peers for (default: 28800)
 .HP
-\fB\-smsgmaxreceive=\fR<n>
+\fBsmsgmaxreceive=\fR<n>
 .IP
 Max number of data messages to tolerate from peers, counter decreases
 over time (default: 4000)
 .HP
-\fB\-smsgnotify=\fR<cmd>
+\fBsmsgnotify=\fR<cmd>
 .IP
 Execute command when a message is received. (%s in cmd is replaced by
 receiving address)
 .HP
-\fB\-smsgsaddnewkeys\fR
+\fBsmsgsaddnewkeys\fR
 .IP
 Scan for incoming messages on new wallet keys. (default: false)
 .HP
-\fB\-smsgscanchain\fR
+\fBsmsgscanchain\fR
 .IP
 Scan the block chain for public key addresses on startup. (default:
 false)
 .HP
-\fB\-smsgscanincoming\fR
+\fBsmsgscanincoming\fR
 .IP
 Scan incoming blocks for public key addresses. (default: false)
 .PP
 Particl wallet Commands:
 .HP
-\fB\-createdefaultmasterkey\fR
+\fBcreatedefaultmasterkey\fR
 .IP
 Generate a random master key and main account if no master key exists.
 (default: false)
 .HP
-\fB\-defaultlookaheadsize=\fR<n>
+\fBdefaultlookaheadsize=\fR<n>
 .IP
 Number of keys to load into the lookahead pool per chain. (default: 64)
 .HP
-\fB\-extkeysaveancestors\fR
+\fBextkeysaveancestors\fR
 .IP
 On saving a key from the lookahead pool, save all unsaved keys leading
 up to it too. (default: true)
 .HP
-\fB\-stealthv1lookaheadsize=\fR<n>
+\fBstealthv1lookaheadsize=\fR<n>
 .IP
 Number of V1 stealth keys to look ahead during a rescan. (default: 5)
 .HP
-\fB\-stealthv2lookaheadsize=\fR<n>
+\fBstealthv2lookaheadsize=\fR<n>
 .IP
 Number of V2 stealth keys to look ahead during a rescan. (default: 5)
 .PP
 Staking Commands:
 .HP
-\fB\-minersleep=\fR<n>
+\fBminersleep=\fR<n>
 .IP
 Milliseconds between stake attempts. Lowering this param will not result
 in more stakes. (default: 500)
 .HP
-\fB\-minstakeinterval=\fR<n>
+\fBminstakeinterval=\fR<n>
 .IP
 Minimum time in seconds between successful stakes (default: 0)
 .HP
-\fB\-reservebalance=\fR<amount>
+\fBreservebalance=\fR<amount>
 .IP
 Ensure available balance remains above reservebalance. (default: 0)
 .HP
-\fB\-stakethreadconddelayms\fR
+\fBstakethreadconddelayms\fR
 .IP
 Number of milliseconds to delay staking for on error condition (default:
 60000)
 .HP
-\fB\-staking\fR
+\fBstaking\fR
 .IP
 Stake your coins to support network and gain reward (default: true)
 .HP
-\fB\-stakingthreads\fR
+\fBstakingthreads\fR
 .IP
 Number of threads to start for staking, max 1 per active wallet, will
 divide wallets evenly between threads (default: 1)
 .HP
-\fB\-treasurydonationpercent=\fR<n>
+\fBtreasurydonationpercent=\fR<n>
 .IP
 Percentage of block reward donated to the treasury fund, overridden by
 system minimum. (default: 0)
 .SH COPYRIGHT
-Copyright (C) 2017-2021 The Particl Core developers
+Copyright (C) 2017-2022 The Particl Core developers
 Copyright (C) 2009-2021 The Bitcoin Core developers
 
 Please contribute if you find Particl Core useful. Visit <https://particl.io/>
diff --git a/doc/man/particl-tx.1 b/doc/man/particl-tx.1
index f254749dee..3f90dcb3b3 100644
--- a/doc/man/particl-tx.1
+++ b/doc/man/particl-tx.1
@@ -1,7 +1,7 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.48.5.
-.TH PARTICL-TX "1" "October 2021" "particl-tx v0.21.2.6.0" "User Commands"
+.TH PARTICL-TX "1" "February 2022" "particl-tx v0.21.2.7" "User Commands"
 .SH NAME
-particl-tx \- manual page for particl-tx v0.21.2.6.0
+particl-tx  manual page for particl-tx v0.21.2.7
 .SH SYNOPSIS
 .B particl-tx
 [\fI\,options\/\fR] \fI\,<hex-tx> \/\fR[\fI\,commands\/\fR]  \fI\,Update hex-encoded transaction\/\fR
@@ -9,59 +9,59 @@ particl-tx \- manual page for particl-tx v0.21.2.6.0
 .B particl-tx
 [\fI\,options\/\fR] \fI\,-create \/\fR[\fI\,commands\/\fR]   \fI\,Create hex-encoded transaction\/\fR
 .SH DESCRIPTION
-Particl Core particl\-tx utility version v0.21.2.6.0
+Particl Core particltx utility version v0.21.2.7
 .SH OPTIONS
 .HP
-\-?
+?
 .IP
 Print this help message and exit
 .HP
-\fB\-btcmode\fR
+\fBbtcmode\fR
 .IP
 Create bitcoin transactions by default
 .HP
-\fB\-create\fR
+\fBcreate\fR
 .IP
 Create new, empty TX.
 .HP
-\fB\-json\fR
+\fBjson\fR
 .IP
 Select JSON output
 .HP
-\fB\-txid\fR
+\fBtxid\fR
 .IP
-Output only the hex\-encoded transaction id of the resultant transaction.
+Output only the hexencoded transaction id of the resultant transaction.
 .PP
 Debugging/Testing options:
 .PP
 Chain selection options:
 .HP
-\fB\-chain=\fR<chain>
+\fBchain=\fR<chain>
 .IP
 Use the chain <chain> (default: main). Allowed values: main, test,
 signet, regtest
 .HP
-\fB\-signet\fR
+\fBsignet\fR
 .IP
-Use the signet chain. Equivalent to \fB\-chain\fR=\fI\,signet\/\fR. Note that the network
-is defined by the \fB\-signetchallenge\fR parameter
+Use the signet chain. Equivalent to \fBchain\fR=\fI\,signet\/\fR. Note that the network
+is defined by the \fBsignetchallenge\fR parameter
 .HP
-\fB\-signetchallenge\fR
+\fBsignetchallenge\fR
 .IP
 Blocks must satisfy the given script to be considered valid (only for
 signet networks; defaults to the global default signet test
 network challenge)
 .HP
-\fB\-signetseednode\fR
+\fBsignetseednode\fR
 .IP
 Specify a seed node for the signet network, in the hostname[:port]
 format, e.g. sig.net:1234 (may be used multiple times to specify
 multiple seed nodes; defaults to the global default signet test
 network seed node(s))
 .HP
-\fB\-testnet\fR
+\fBtestnet\fR
 .IP
-Use the test chain. Equivalent to \fB\-chain\fR=\fI\,test\/\fR.
+Use the test chain. Equivalent to \fBchain\fR=\fI\,test\/\fR.
 .PP
 Commands:
 .IP
@@ -95,7 +95,7 @@ Set TX version to N
 .IP
 outaddr=VALUE:ADDRESS
 .IP
-Add address\-based output to TX
+Add addressbased output to TX
 .IP
 outblind=COMMITMENT:SCRIPT:RANGEPROOF[:DATA]
 .IP
@@ -103,41 +103,41 @@ Add blinded output to TX
 .IP
 outdata=[VALUE:]DATA
 .IP
-Add data\-based output to TX
+Add databased output to TX
 .IP
 outdatatype=DATA
 .IP
-Add data\-type output to TX
+Add datatype output to TX
 .IP
 outmultisig=VALUE:REQUIRED:PUBKEYS:PUBKEY1:PUBKEY2:....[:FLAGS]
 .IP
-Add Pay To n\-of\-m Multi\-sig output to TX. n = REQUIRED, m = PUBKEYS.
+Add Pay To nofm Multisig output to TX. n = REQUIRED, m = PUBKEYS.
 Optionally add the "W" flag to produce a
-pay\-to\-witness\-script\-hash output. Optionally add the "S" flag to
-wrap the output in a pay\-to\-script\-hash.
+paytowitnessscripthash output. Optionally add the "S" flag to
+wrap the output in a paytoscripthash.
 .IP
 outpubkey=VALUE:PUBKEY[:FLAGS]
 .IP
-Add pay\-to\-pubkey output to TX. Optionally add the "W" flag to produce a
-pay\-to\-witness\-pubkey\-hash output. Optionally add the "S" flag to
-wrap the output in a pay\-to\-script\-hash.
+Add paytopubkey output to TX. Optionally add the "W" flag to produce a
+paytowitnesspubkeyhash output. Optionally add the "S" flag to
+wrap the output in a paytoscripthash.
 .IP
 outscript=VALUE:SCRIPT[:FLAGS]
 .IP
 Add raw script output to TX. Optionally add the "W" flag to produce a
-pay\-to\-witness\-script\-hash output. Optionally add the "S" flag to
-wrap the output in a pay\-to\-script\-hash.
+paytowitnessscripthash output. Optionally add the "S" flag to
+wrap the output in a paytoscripthash.
 .IP
 replaceable(=N)
 .IP
-Set RBF opt\-in sequence number for input N (if not provided, opt\-in all
+Set RBF optin sequence number for input N (if not provided, optin all
 available inputs)
 .IP
 scriptsig=N:HEX
 .IP
 Add scriptsig data to input N
 .IP
-sign=SIGHASH\-FLAGS
+sign=SIGHASHFLAGS
 .IP
 Add zero or more signatures to transaction. This command requires JSON
 registers:prevtxs=JSON object, privatekeys=JSON object. See
@@ -154,11 +154,11 @@ load=NAME:FILENAME
 .IP
 Load JSON file FILENAME into register NAME
 .IP
-set=NAME:JSON\-STRING
+set=NAME:JSONSTRING
 .IP
-Set register NAME to given JSON\-STRING
+Set register NAME to given JSONSTRING
 .SH COPYRIGHT
-Copyright (C) 2017-2021 The Particl Core developers
+Copyright (C) 2017-2022 The Particl Core developers
 Copyright (C) 2009-2021 The Bitcoin Core developers
 
 Please contribute if you find Particl Core useful. Visit <https://particl.io/>
diff --git a/doc/man/particl-wallet.1 b/doc/man/particl-wallet.1
index d709b49226..5181c6bd19 100644
--- a/doc/man/particl-wallet.1
+++ b/doc/man/particl-wallet.1
@@ -1,69 +1,69 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.48.5.
-.TH PARTICL-WALLET "1" "October 2021" "particl-wallet v0.21.2.6.0" "User Commands"
+.TH PARTICL-WALLET "1" "February 2022" "particl-wallet v0.21.2.7" "User Commands"
 .SH NAME
-particl-wallet \- manual page for particl-wallet v0.21.2.6.0
+particl-wallet  manual page for particl-wallet v0.21.2.7
 .SH DESCRIPTION
-Particl Core particl\-wallet version v0.21.2.6.0
+Particl Core particlwallet version v0.21.2.7
 .PP
-particl\-wallet is an offline tool for creating and interacting with Particl Core wallet files.
-By default particl\-wallet will act on wallets in the default mainnet wallet directory in the datadir.
-To change the target wallet, use the \fB\-datadir\fR, \fB\-wallet\fR and \fB\-testnet\fR/\-regtest arguments.
+particlwallet is an offline tool for creating and interacting with Particl Core wallet files.
+By default particlwallet will act on wallets in the default mainnet wallet directory in the datadir.
+To change the target wallet, use the \fBdatadir\fR, \fBwallet\fR and \fBtestnet\fR/regtest arguments.
 .SS "Usage:"
 .IP
-particl\-wallet [options] <command>
+particlwallet [options] <command>
 .SH OPTIONS
 .HP
-\-?
+?
 .IP
 Print this help message and exit
 .HP
-\fB\-datadir=\fR<dir>
+\fBdatadir=\fR<dir>
 .IP
 Specify data directory
 .HP
-\fB\-wallet=\fR<wallet\-name>
+\fBwallet=\fR<walletname>
 .IP
 Specify wallet name
 .PP
 Debugging/Testing options:
 .HP
-\fB\-debug=\fR<category>
+\fBdebug=\fR<category>
 .IP
 Output debugging information (default: 0).
 .HP
-\fB\-printtoconsole\fR
+\fBprinttoconsole\fR
 .IP
-Send trace/debug info to console (default: 1 when no \fB\-debug\fR is true, 0
+Send trace/debug info to console (default: 1 when no \fBdebug\fR is true, 0
 otherwise).
 .PP
 Chain selection options:
 .HP
-\fB\-chain=\fR<chain>
+\fBchain=\fR<chain>
 .IP
 Use the chain <chain> (default: main). Allowed values: main, test,
 signet, regtest
 .HP
-\fB\-signet\fR
+\fBsignet\fR
 .IP
-Use the signet chain. Equivalent to \fB\-chain\fR=\fI\,signet\/\fR. Note that the network
-is defined by the \fB\-signetchallenge\fR parameter
+Use the signet chain. Equivalent to \fBchain\fR=\fI\,signet\/\fR. Note that the network
+is defined by the \fBsignetchallenge\fR parameter
 .HP
-\fB\-signetchallenge\fR
+\fBsignetchallenge\fR
 .IP
 Blocks must satisfy the given script to be considered valid (only for
 signet networks; defaults to the global default signet test
 network challenge)
 .HP
-\fB\-signetseednode\fR
+\fBsignetseednode\fR
 .IP
 Specify a seed node for the signet network, in the hostname[:port]
 format, e.g. sig.net:1234 (may be used multiple times to specify
 multiple seed nodes; defaults to the global default signet test
 network seed node(s))
 .HP
-\fB\-testnet\fR
+\fBtestnet\fR
 .IP
-Use the test chain. Equivalent to \fB\-chain\fR=\fI\,test\/\fR.
+Use the test chain. Equivalent to \fBchain\fR=\fI\,test\/\fR.
 .PP
 Commands:
 .IP
@@ -84,7 +84,7 @@ salvage
 Attempt to recover private keys from a corrupt wallet. Warning:
 \&'salvage' is experimental.
 .SH COPYRIGHT
-Copyright (C) 2017-2021 The Particl Core developers
+Copyright (C) 2017-2022 The Particl Core developers
 Copyright (C) 2009-2021 The Bitcoin Core developers
 
 Please contribute if you find Particl Core useful. Visit <https://particl.io/>
diff --git a/doc/man/particld.1 b/doc/man/particld.1
index 02f1f685fc..bdc81306b5 100644
--- a/doc/man/particld.1
+++ b/doc/man/particld.1
@@ -1,235 +1,235 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.48.5.
-.TH PARTICLD "1" "October 2021" "particld v0.21.2.6.0" "User Commands"
+.TH PARTICLD "1" "February 2022" "particld v0.21.2.7" "User Commands"
 .SH NAME
-particld \- manual page for particld v0.21.2.6.0
+particld  manual page for particld v0.21.2.7
 .SH SYNOPSIS
 .B particld
 [\fI\,options\/\fR]                     \fI\,Start Particl Core\/\fR
 .SH DESCRIPTION
-Particl Core version v0.21.2.6.0
+Particl Core version v0.21.2.7
 .SH OPTIONS
 .HP
-\-?
+?
 .IP
 Print this help message and exit
 .HP
-\fB\-addressindex\fR
+\fBaddressindex\fR
 .IP
 Maintain a full address index, used to query for the balance, txids and
 unspent outputs for addresses (default: 0)
 .HP
-\fB\-alertnotify=\fR<cmd>
+\fBalertnotify=\fR<cmd>
 .IP
 Execute command when a relevant alert is received or we see a really
 long fork (%s in cmd is replaced by message)
 .HP
-\fB\-assumevalid=\fR<hex>
+\fBassumevalid=\fR<hex>
 .IP
 If this block is in the chain assume that it and its ancestors are valid
 and potentially skip their script verification (0 to verify all,
 default:
-dcbe7be05060974cca33a52790e047a73358812102a97cd5b3089f2469bd6601,
+6b13071bc3f5689a3f8a29808f726654283714461076ea890f4272574ff2659f,
 testnet:
-9313d6187a7b8bdd18f988d159331702ead08fe8001e602d5a42cb3a60f8313e,
+c8b34db63fb6ec97b557a969065e56167030c36c12b7c988561736ad3a5488c0,
 signet:
 0000002a1de0f46379358c1fd09906f7ac59adf3712323ed90eb59e4c183c020)
 .HP
-\fB\-balancesindex\fR
+\fBbalancesindex\fR
 .IP
 Maintain a balances index per block (default: 0)
 .HP
-\fB\-blockfilterindex=\fR<type>
+\fBblockfilterindex=\fR<type>
 .IP
 Maintain an index of compact filters by block (default: 0, values:
 basic). If <type> is not supplied or if <type> = 1, indexes for
 all known types are enabled.
 .HP
-\fB\-blocknotify=\fR<cmd>
+\fBblocknotify=\fR<cmd>
 .IP
 Execute command when the best block changes (%s in cmd is replaced by
 block hash)
 .HP
-\fB\-blockreconstructionextratxn=\fR<n>
+\fBblockreconstructionextratxn=\fR<n>
 .IP
 Extra transactions to keep in memory for compact block reconstructions
 (default: 100)
 .HP
-\fB\-blocksdir=\fR<dir>
+\fBblocksdir=\fR<dir>
 .IP
 Specify directory to hold blocks subdirectory for *.dat files (default:
 <datadir>)
 .HP
-\fB\-blocksonly\fR
+\fBblocksonly\fR
 .IP
 Whether to reject transactions from network peers. Automatic broadcast
 and rebroadcast of any transactions from inbound peers is
 disabled, unless the peer has the 'forcerelay' permission. RPC
 transactions are not affected. (default: 0)
 .HP
-\fB\-conf=\fR<file>
+\fBconf=\fR<file>
 .IP
-Specify path to read\-only configuration file. Relative paths will be
+Specify path to readonly configuration file. Relative paths will be
 prefixed by datadir location. (default: particl.conf)
 .HP
-\fB\-csindex\fR
+\fBcsindex\fR
 .IP
 Maintain an index of outputs by coldstaking address (default: 0)
 .HP
-\fB\-cswhitelist\fR
+\fBcswhitelist\fR
 .IP
 Only index coldstaked outputs with matching stake address. Can be
 specified multiple times.
 .HP
-\fB\-daemon\fR
+\fBdaemon\fR
 .IP
 Run in the background as a daemon and accept commands
 .HP
-\fB\-datadir=\fR<dir>
+\fBdatadir=\fR<dir>
 .IP
 Specify data directory
 .HP
-\fB\-dbcache=\fR<n>
+\fBdbcache=\fR<n>
 .IP
 Maximum database cache size <n> MiB (4 to 16384, default: 450). In
 addition, unused mempool memory is shared for this cache (see
-\fB\-maxmempool\fR).
+\fBmaxmempool\fR).
 .HP
-\fB\-dbcompression\fR
+\fBdbcompression\fR
 .IP
-Database compression parameter passed to level\-db (default: false)
+Database compression parameter passed to leveldb (default: false)
 .HP
-\fB\-dbmaxopenfiles\fR
+\fBdbmaxopenfiles\fR
 .IP
-Maximum number of open files parameter passed to level\-db (default: 64)
+Maximum number of open files parameter passed to leveldb (default: 64)
 .HP
-\fB\-debuglogfile=\fR<file>
+\fBdebuglogfile=\fR<file>
 .IP
 Specify location of debug log file. Relative paths will be prefixed by a
-net\-specific datadir location. (\fB\-nodebuglogfile\fR to disable;
+netspecific datadir location. (\fBnodebuglogfile\fR to disable;
 default: debug.log)
 .HP
-\fB\-includeconf=\fR<file>
+\fBincludeconf=\fR<file>
 .IP
-Specify additional configuration file, relative to the \fB\-datadir\fR path
+Specify additional configuration file, relative to the \fBdatadir\fR path
 (only useable from configuration file, not command line)
 .HP
-\fB\-loadblock=\fR<file>
+\fBloadblock=\fR<file>
 .IP
 Imports blocks from external file on startup
 .HP
-\fB\-maxmempool=\fR<n>
+\fBmaxmempool=\fR<n>
 .IP
 Keep the transaction memory pool below <n> megabytes (default: 300)
 .HP
-\fB\-maxorphantx=\fR<n>
+\fBmaxorphantx=\fR<n>
 .IP
 Keep at most <n> unconnectable transactions in memory (default: 100)
 .HP
-\fB\-mempoolexpiry=\fR<n>
+\fBmempoolexpiry=\fR<n>
 .IP
 Do not keep transactions in the mempool longer than <n> hours (default:
 336)
 .HP
-\fB\-par=\fR<n>
+\fBpar=\fR<n>
 .IP
-Set the number of script verification threads (\fB\-4\fR to 15, 0 = auto, <0 =
+Set the number of script verification threads (\fB4\fR to 15, 0 = auto, <0 =
 leave that many cores free, default: 0)
 .HP
-\fB\-persistmempool\fR
+\fBpersistmempool\fR
 .IP
 Whether to save the mempool on shutdown and load on restart (default: 1)
 .HP
-\fB\-pid=\fR<file>
+\fBpid=\fR<file>
 .IP
-Specify pid file. Relative paths will be prefixed by a net\-specific
+Specify pid file. Relative paths will be prefixed by a netspecific
 datadir location. (default: particl.pid)
 .HP
-\fB\-prune=\fR<n>
+\fBprune=\fR<n>
 .IP
 Reduce storage requirements by enabling pruning (deleting) of old
 blocks. This allows the pruneblockchain RPC to be called to
 delete specific blocks, and enables automatic pruning of old
 blocks if a target size in MiB is provided. This mode is
-incompatible with \fB\-txindex\fR and \fB\-rescan\fR. Warning: Reverting this
-setting requires re\-downloading the entire blockchain. (default:
+incompatible with \fBtxindex\fR and \fBrescan\fR. Warning: Reverting this
+setting requires redownloading the entire blockchain. (default:
 0 = disable pruning blocks, 1 = allow manual pruning via RPC,
 >=550 = automatically prune block files to stay under the
 specified target size in MiB)
 .HP
-\fB\-reindex\fR
+\fBreindex\fR
 .IP
 Rebuild chain state and block index from the blk*.dat files on disk
 .HP
-\fB\-reindex\-chainstate\fR
+\fBreindexchainstate\fR
 .IP
 Rebuild chain state from the currently indexed blocks. When in pruning
-mode or if blocks on disk might be corrupted, use full \fB\-reindex\fR
+mode or if blocks on disk might be corrupted, use full \fBreindex\fR
 instead.
 .HP
-\fB\-settings=\fR<file>
+\fBsettings=\fR<file>
 .IP
 Specify path to dynamic settings data file. Can be disabled with
-\fB\-nosettings\fR. File is written at runtime and not meant to be
+\fBnosettings\fR. File is written at runtime and not meant to be
 edited by users (use particl.conf instead for custom settings).
 Relative paths will be prefixed by datadir location. (default:
 settings.json)
 .HP
-\fB\-skiprangeproofverify\fR
+\fBskiprangeproofverify\fR
 .IP
 Skip verifying rangeproofs when reindexing or importing.
 .HP
-\fB\-spentindex\fR
+\fBspentindex\fR
 .IP
 Maintain a full spent index, used to query the spending txid and input
 index for an outpoint (default: 0)
 .HP
-\fB\-startupnotify=\fR<cmd>
+\fBstartupnotify=\fR<cmd>
 .IP
 Execute command on startup.
 .HP
-\fB\-sysperms\fR
+\fBsysperms\fR
 .IP
 Create new files with system default permissions, instead of umask 077
 (only effective with disabled wallet functionality)
 .HP
-\fB\-timestampindex\fR
+\fBtimestampindex\fR
 .IP
 Maintain a timestamp index for block hashes, used to query blocks hashes
 by a range of timestamps (default: 0)
 .HP
-\fB\-txindex\fR
+\fBtxindex\fR
 .IP
 Maintain a full transaction index, used by the getrawtransaction rpc
 call (default: 0)
 .HP
-\fB\-version\fR
+\fBversion\fR
 .IP
 Print version and exit
 .PP
 Connection options:
 .HP
-\fB\-addnode=\fR<ip>
+\fBaddnode=\fR<ip>
 .IP
 Add a node to connect to and attempt to keep the connection open (see
 the `addnode` RPC command help for more info). This option can be
 specified multiple times to add multiple nodes.
 .HP
-\fB\-asmap=\fR<file>
+\fBasmap=\fR<file>
 .IP
 Specify asn mapping used for bucketing of the peers (default:
-ip_asn.map). Relative paths will be prefixed by the net\-specific
+ip_asn.map). Relative paths will be prefixed by the netspecific
 datadir location.
 .HP
-\fB\-banscore=\fR<n>
+\fBbanscore=\fR<n>
 .IP
 Threshold for disconnecting misbehaving peers (default: 100)
 .HP
-\fB\-bantime=\fR<n>
+\fBbantime=\fR<n>
 .IP
 Default duration (in seconds) of manually configured bans (default:
 86400)
 .HP
-\fB\-bind=\fR<addr>[:<port>][=onion]
+\fBbind=\fR<addr>[:<port>][=onion]
 .IP
 Bind to given address and always listen on it (default: 0.0.0.0). Use
 [host]:port notation for IPv6. Append =onion to tag any incoming
@@ -237,202 +237,202 @@ connections to that address and port as incoming Tor connections
 (default: 127.0.0.1:51734=onion, testnet: 127.0.0.1:51934=onion,
 signet: 127.0.0.1:31934=onion, regtest: 127.0.0.1:51931=onion)
 .HP
-\fB\-connect=\fR<ip>
+\fBconnect=\fR<ip>
 .IP
-Connect only to the specified node; \fB\-noconnect\fR disables automatic
+Connect only to the specified node; \fBnoconnect\fR disables automatic
 connections (the rules for this peer are the same as for
-\fB\-addnode\fR). This option can be specified multiple times to connect
+\fBaddnode\fR). This option can be specified multiple times to connect
 to multiple nodes.
 .HP
-\fB\-discover\fR
+\fBdiscover\fR
 .IP
-Discover own IP addresses (default: 1 when listening and no \fB\-externalip\fR
-or \fB\-proxy\fR)
+Discover own IP addresses (default: 1 when listening and no \fBexternalip\fR
+or \fBproxy\fR)
 .HP
-\fB\-dns\fR
+\fBdns\fR
 .IP
-Allow DNS lookups for \fB\-addnode\fR, \fB\-seednode\fR and \fB\-connect\fR (default: 1)
+Allow DNS lookups for \fBaddnode\fR, \fBseednode\fR and \fBconnect\fR (default: 1)
 .HP
-\fB\-dnsseed\fR
+\fBdnsseed\fR
 .IP
 Query for peer addresses via DNS lookup, if low on addresses (default: 1
-unless \fB\-connect\fR used)
+unless \fBconnect\fR used)
 .HP
-\fB\-externalip=\fR<ip>
+\fBexternalip=\fR<ip>
 .IP
 Specify your own public address
 .HP
-\fB\-findpeers\fR
+\fBfindpeers\fR
 .IP
 Node will search for peers (default: 1)
 .HP
-\fB\-forcednsseed\fR
+\fBforcednsseed\fR
 .IP
 Always query for peer addresses via DNS lookup (default: 0)
 .HP
-\fB\-listen\fR
+\fBlisten\fR
 .IP
-Accept connections from outside (default: 1 if no \fB\-proxy\fR or \fB\-connect\fR)
+Accept connections from outside (default: 1 if no \fBproxy\fR or \fBconnect\fR)
 .HP
-\fB\-listenonion\fR
+\fBlistenonion\fR
 .IP
 Automatically create Tor hidden service (default: 1)
 .HP
-\fB\-lookuptorcontrolhost=\fR<protocol>
+\fBlookuptorcontrolhost=\fR<protocol>
 .IP
-Allow a hostname to be specified for the \fB\-torcontrol\fR option. Must be
+Allow a hostname to be specified for the \fBtorcontrol\fR option. Must be
 "any", "ipv4", or "ipv6" (default: )
 .HP
-\fB\-maxconnections=\fR<n>
+\fBmaxconnections=\fR<n>
 .IP
 Maintain at most <n> connections to peers (default: 125)
 .HP
-\fB\-maxreceivebuffer=\fR<n>
+\fBmaxreceivebuffer=\fR<n>
 .IP
-Maximum per\-connection receive buffer, <n>*1000 bytes (default: 5000)
+Maximum perconnection receive buffer, <n>*1000 bytes (default: 5000)
 .HP
-\fB\-maxsendbuffer=\fR<n>
+\fBmaxsendbuffer=\fR<n>
 .IP
-Maximum per\-connection send buffer, <n>*1000 bytes (default: 1000)
+Maximum perconnection send buffer, <n>*1000 bytes (default: 1000)
 .HP
-\fB\-maxtimeadjustment\fR
+\fBmaxtimeadjustment\fR
 .IP
 Maximum allowed median peer time offset adjustment. Local perspective of
 time may be influenced by peers forward or backward by this
 amount. (default: 4200 seconds)
 .HP
-\fB\-maxuploadtarget=\fR<n>
+\fBmaxuploadtarget=\fR<n>
 .IP
 Tries to keep outbound traffic under the given target (in MiB per 24h).
 Limit does not apply to peers with 'download' permission. 0 = no
 limit (default: 0)
 .HP
-\fB\-networkactive\fR
+\fBnetworkactive\fR
 .IP
 Enable all P2P network activity (default: 1). Can be changed by the
 setnetworkactive RPC command
 .HP
-\fB\-onion=\fR<ip:port>
+\fBonion=\fR<ip:port>
 .IP
 Use separate SOCKS5 proxy to reach peers via Tor hidden services, set
-\fB\-noonion\fR to disable (default: \fB\-proxy\fR)
+\fBnoonion\fR to disable (default: \fBproxy\fR)
 .HP
-\fB\-onlynet=\fR<net>
+\fBonlynet=\fR<net>
 .IP
 Make outgoing connections only through network <net> (ipv4, ipv6 or
 onion). Incoming connections are not affected by this option.
 This option can be specified multiple times to allow multiple
 networks.
 .HP
-\fB\-peerblockfilters\fR
+\fBpeerblockfilters\fR
 .IP
 Serve compact block filters to peers per BIP 157 (default: 0)
 .HP
-\fB\-peerbloomfilters\fR
+\fBpeerbloomfilters\fR
 .IP
 Support filtering of blocks and transaction with bloom filters (default:
 0)
 .HP
-\fB\-peertimeout=\fR<n>
+\fBpeertimeout=\fR<n>
 .IP
 Specify p2p connection timeout in seconds. This option determines the
 amount of time a peer may be inactive before the connection to it
 is dropped. (minimum: 1, default: 60)
 .HP
-\fB\-permitbaremultisig\fR
+\fBpermitbaremultisig\fR
 .IP
-Relay non\-P2SH multisig (default: 1)
+Relay nonP2SH multisig (default: 1)
 .HP
-\fB\-port=\fR<port>
+\fBport=\fR<port>
 .IP
 Listen for connections on <port>. Nodes not using the default ports
 (default: 51738, testnet: 51938, signet: 38333, regtest: 11938)
 are unlikely to get incoming connections.
 .HP
-\fB\-proxy=\fR<ip:port>
+\fBproxy=\fR<ip:port>
 .IP
-Connect through SOCKS5 proxy, set \fB\-noproxy\fR to disable (default:
+Connect through SOCKS5 proxy, set \fBnoproxy\fR to disable (default:
 disabled)
 .HP
-\fB\-proxyrandomize\fR
+\fBproxyrandomize\fR
 .IP
 Randomize credentials for every proxy connection. This enables Tor
 stream isolation (default: 1)
 .HP
-\fB\-seednode=\fR<ip>
+\fBseednode=\fR<ip>
 .IP
 Connect to a node to retrieve peer addresses, and disconnect. This
 option can be specified multiple times to connect to multiple
 nodes.
 .HP
-\fB\-timeout=\fR<n>
+\fBtimeout=\fR<n>
 .IP
 Specify connection timeout in milliseconds (minimum: 1, default: 5000)
 .HP
-\fB\-torcontrol=\fR<ip>:<port>
+\fBtorcontrol=\fR<ip>:<port>
 .IP
 Tor control port to use if onion listening enabled (default:
 127.0.0.1:9051)
 .HP
-\fB\-torpassword=\fR<pass>
+\fBtorpassword=\fR<pass>
 .IP
 Tor control port password (default: empty)
 .HP
-\fB\-upnp\fR
+\fBupnp\fR
 .IP
 Use UPnP to map the listening port (default: 0)
 .HP
-\fB\-whitebind=\fR<[permissions@]addr>
+\fBwhitebind=\fR<[permissions@]addr>
 .IP
 Bind to the given address and add permission flags to the peers
 connecting to it. Use [host]:port notation for IPv6. Allowed
 permissions: bloomfilter (allow requesting BIP37 filtered blocks
 and transactions), noban (do not ban for misbehavior; implies
 download), forcerelay (relay transactions that are already in the
-mempool; implies relay), relay (relay even in \fB\-blocksonly\fR mode,
+mempool; implies relay), relay (relay even in \fBblocksonly\fR mode,
 and unlimited transaction announcements), mempool (allow
 requesting BIP35 mempool contents), download (allow getheaders
 during IBD, no disconnect after maxuploadtarget limit), addr
 (responses to GETADDR avoid hitting the cache and contain random
-records with the most up\-to\-date info). Specify multiple
+records with the most uptodate info). Specify multiple
 permissions separated by commas (default:
 download,noban,mempool,relay). Can be specified multiple times.
 .HP
-\fB\-whitelist=\fR<[permissions@]IP address or network>
+\fBwhitelist=\fR<[permissions@]IP address or network>
 .IP
 Add permission flags to the peers connecting from the given IP address
-(e.g. 1.2.3.4) or CIDR\-notated network (e.g. 1.2.3.0/24). Uses
-the same permissions as \fB\-whitebind\fR. Can be specified multiple
+(e.g. 1.2.3.4) or CIDRnotated network (e.g. 1.2.3.0/24). Uses
+the same permissions as \fBwhitebind\fR. Can be specified multiple
 times.
 .PP
 Wallet options:
 .HP
-\fB\-addresstype\fR
+\fBaddresstype\fR
 .IP
-What type of addresses to use ("legacy", "p2sh\-segwit", or "bech32",
+What type of addresses to use ("legacy", "p2shsegwit", or "bech32",
 default: "bech32")
 .HP
-\fB\-avoidpartialspends\fR
+\fBavoidpartialspends\fR
 .IP
 Group outputs by address, selecting all or none, instead of selecting on
-a per\-output basis. Privacy is improved as an address is only
+a peroutput basis. Privacy is improved as an address is only
 used once (unless someone sends to it after spending from it),
 but may result in slightly higher fees as suboptimal coin
 selection may result due to the added limitation (default: 0
 (always enabled for wallets with "avoid_reuse" enabled))
 .HP
-\fB\-changetype\fR
+\fBchangetype\fR
 .IP
-What type of change to use ("legacy", "p2sh\-segwit", or "bech32").
-Default is same as \fB\-addresstype\fR, except when
-\fB\-addresstype\fR=\fI\,p2sh\-segwit\/\fR a native segwit output is used when
+What type of change to use ("legacy", "p2shsegwit", or "bech32").
+Default is same as \fBaddresstype\fR, except when
+\fBaddresstype\fR=\fI\,p2shsegwit\/\fR a native segwit output is used when
 sending to a native segwit address)
 .HP
-\fB\-disablewallet\fR
+\fBdisablewallet\fR
 .IP
 Do not load the wallet and disable wallet RPC calls
 .HP
-\fB\-discardfee=\fR<amt>
+\fBdiscardfee=\fR<amt>
 .IP
 The fee rate (in PART/kB) that indicates your tolerance for discarding
 change by adding it to the fee (default: 0.0001). Note: An output
@@ -440,66 +440,66 @@ is discarded if it is dust at this rate, but we will always
 discard up to the dust relay fee and a discard fee above that is
 limited by the fee estimate for the longest target
 .HP
-\fB\-fallbackfee=\fR<amt>
+\fBfallbackfee=\fR<amt>
 .IP
 A fee rate (in PART/kB) that will be used when fee estimation has
 insufficient data. 0 to entirely disable the fallbackfee feature.
 (default: 0.00)
 .HP
-\fB\-keypool=\fR<n>
+\fBkeypool=\fR<n>
 .IP
 Set key pool size to <n> (default: 1000). Warning: Smaller sizes may
 increase the risk of losing funds when restoring from an old
 backup, if none of the addresses in the original keypool have
 been used.
 .HP
-\fB\-maxapsfee=\fR<n>
+\fBmaxapsfee=\fR<n>
 .IP
 Spend up to this amount in additional (absolute) fees (in PART) if it
 allows the use of partial spend avoidance (default: 0.00)
 .HP
-\fB\-mintxfee=\fR<amt>
+\fBmintxfee=\fR<amt>
 .IP
 Fees (in PART/kB) smaller than this are considered zero fee for
 transaction creation (default: 0.002)
 .HP
-\fB\-paytxfee=\fR<amt>
+\fBpaytxfee=\fR<amt>
 .IP
 Fee (in PART/kB) to add to transactions you send (default: 0.00)
 .HP
-\fB\-rescan\fR
+\fBrescan\fR
 .IP
 Rescan the block chain for missing wallet transactions on startup
 .HP
-\fB\-spendzeroconfchange\fR
+\fBspendzeroconfchange\fR
 .IP
 Spend unconfirmed change when sending transactions (default: 1)
 .HP
-\fB\-txconfirmtarget=\fR<n>
+\fBtxconfirmtarget=\fR<n>
 .IP
 If paytxfee is not set, include enough fee so transactions begin
 confirmation on average within n blocks (default: 6)
 .HP
-\fB\-wallet=\fR<path>
+\fBwallet=\fR<path>
 .IP
 Specify wallet path to load at startup. Can be used multiple times to
 load multiple wallets. Path is to a directory containing wallet
 data and log files. If the path is not absolute, it is
 interpreted relative to <walletdir>. This only loads existing
 wallets and does not create new ones. For backwards compatibility
-this also accepts names of existing top\-level data files in
+this also accepts names of existing toplevel data files in
 <walletdir>.
 .HP
-\fB\-walletbroadcast\fR
+\fBwalletbroadcast\fR
 .IP
 Make the wallet broadcast transactions (default: 1)
 .HP
-\fB\-walletdir=\fR<dir>
+\fBwalletdir=\fR<dir>
 .IP
 Specify directory to hold wallets (default: <datadir>/wallets if it
 exists, otherwise <datadir>)
 .HP
-\fB\-walletnotify=\fR<cmd>
+\fBwalletnotify=\fR<cmd>
 .IP
 Execute command when a wallet transaction changes. %s in cmd is replaced
 by TxID and %w is replaced by wallet name. %w is not currently
@@ -507,81 +507,81 @@ implemented on windows. On systems where %w is supported, it
 should NOT be quoted because this would break shell escaping used
 to invoke the command.
 .HP
-\fB\-walletrbf\fR
+\fBwalletrbf\fR
 .IP
-Send transactions with full\-RBF opt\-in enabled (RPC only, default: 0)
+Send transactions with fullRBF optin enabled (RPC only, default: 0)
 .PP
 ZeroMQ notification options:
 .HP
-\fB\-newserverkeypairzmq\fR
+\fBnewserverkeypairzmq\fR
 .IP
 Generate new key pair for CurveZMQ, print and exit.
 .HP
-\fB\-serverkeyzmq=\fR<secret_key>
+\fBserverkeyzmq=\fR<secret_key>
 .IP
 Base64 encoded string of the z85 encoded secret key for CurveZMQ.
 .HP
-\fB\-whitelistzmq=\fR<IP address or network>
+\fBwhitelistzmq=\fR<IP address or network>
 .IP
 Whitelist peers connecting from the given IP address (e.g. 1.2.3.4) or
 CIDR notated network (e.g. 1.2.3.0/24). Can be specified multiple
 times.
 .HP
-\fB\-zmqpubhashblock=\fR<address>
+\fBzmqpubhashblock=\fR<address>
 .IP
 Enable publish hash block in <address>
 .HP
-\fB\-zmqpubhashblockhwm=\fR<n>
+\fBzmqpubhashblockhwm=\fR<n>
 .IP
 Set publish hash block outbound message high water mark (default: 1000)
 .HP
-\fB\-zmqpubhashtx=\fR<address>
+\fBzmqpubhashtx=\fR<address>
 .IP
 Enable publish hash transaction in <address>
 .HP
-\fB\-zmqpubhashtxhwm=\fR<n>
+\fBzmqpubhashtxhwm=\fR<n>
 .IP
 Set publish hash transaction outbound message high water mark (default:
 1000)
 .HP
-\fB\-zmqpubhashwtx=\fR<address>
+\fBzmqpubhashwtx=\fR<address>
 .IP
 Enable publish hash transaction received by wallets in <address>
 .HP
-\fB\-zmqpubrawblock=\fR<address>
+\fBzmqpubrawblock=\fR<address>
 .IP
 Enable publish raw block in <address>
 .HP
-\fB\-zmqpubrawblockhwm=\fR<n>
+\fBzmqpubrawblockhwm=\fR<n>
 .IP
 Set publish raw block outbound message high water mark (default: 1000)
 .HP
-\fB\-zmqpubrawtx=\fR<address>
+\fBzmqpubrawtx=\fR<address>
 .IP
 Enable publish raw transaction in <address>
 .HP
-\fB\-zmqpubrawtxhwm=\fR<n>
+\fBzmqpubrawtxhwm=\fR<n>
 .IP
 Set publish raw transaction outbound message high water mark (default:
 1000)
 .HP
-\fB\-zmqpubsequence=\fR<address>
+\fBzmqpubsequence=\fR<address>
 .IP
 Enable publish hash block and tx sequence in <address>
 .HP
-\fB\-zmqpubsequencehwm=\fR<n>
+\fBzmqpubsequencehwm=\fR<n>
 .IP
 Set publish hash sequence message high water mark (default: 1000)
 .HP
-\fB\-zmqpubsmsg=\fR<address>
+\fBzmqpubsmsg=\fR<address>
 .IP
 Enable publish secure message in <address>
 .PP
 Debugging/Testing options:
 .HP
-\fB\-debug=\fR<category>
+\fBdebug=\fR<category>
 .IP
-Output debugging information (default: \fB\-nodebug\fR, supplying <category> is
+Output debugging information (default: \fBnodebug\fR, supplying <category> is
 optional). If <category> is not supplied or if <category> = 1,
 output all debugging information. <category> can be: net, tor,
 mempool, http, bench, zmq, walletdb, rpc, estimatefee, addrman,
@@ -589,104 +589,104 @@ selectcoins, reindex, cmpctblock, rand, prune, proxy, mempoolrej,
 libevent, coindb, qt, leveldb, validation, smsg, ringct, pos,
 hdwallet.
 .HP
-\fB\-debugexclude=\fR<category>
+\fBdebugexclude=\fR<category>
 .IP
 Exclude debugging information for a category. Can be used in conjunction
-with \fB\-debug\fR=\fI\,1\/\fR to output debug logs for all categories except one
+with \fBdebug\fR=\fI\,1\/\fR to output debug logs for all categories except one
 or more specified categories.
 .HP
-\fB\-help\-debug\fR
+\fBhelpdebug\fR
 .IP
 Print help message with debugging options and exit
 .HP
-\fB\-logips\fR
+\fBlogips\fR
 .IP
 Include IP addresses in debug output (default: 0)
 .HP
-\fB\-logthreadnames\fR
+\fBlogthreadnames\fR
 .IP
 Prepend debug output with name of the originating thread (only available
 on platforms supporting thread_local) (default: 0)
 .HP
-\fB\-logtimestamps\fR
+\fBlogtimestamps\fR
 .IP
 Prepend debug output with timestamp (default: 1)
 .HP
-\fB\-maxtxfee=\fR<amt>
+\fBmaxtxfee=\fR<amt>
 .IP
 Maximum total fees (in PART) to use in a single wallet transaction;
 setting this too low may abort large transactions (default: 0.50)
 .HP
-\fB\-printtoconsole\fR
+\fBprinttoconsole\fR
 .IP
-Send trace/debug info to console (default: 1 when no \fB\-daemon\fR. To disable
-logging to file, set \fB\-nodebuglogfile\fR)
+Send trace/debug info to console (default: 1 when no \fBdaemon\fR. To disable
+logging to file, set \fBnodebuglogfile\fR)
 .HP
-\fB\-shrinkdebugfile\fR
+\fBshrinkdebugfile\fR
 .IP
-Shrink debug.log file on client startup (default: 1 when no \fB\-debug\fR)
+Shrink debug.log file on client startup (default: 1 when no \fBdebug\fR)
 .HP
-\fB\-uacomment=\fR<cmt>
+\fBuacomment=\fR<cmt>
 .IP
 Append comment to the user agent string
 .PP
 Chain selection options:
 .HP
-\fB\-chain=\fR<chain>
+\fBchain=\fR<chain>
 .IP
 Use the chain <chain> (default: main). Allowed values: main, test,
 signet, regtest
 .HP
-\fB\-signet\fR
+\fBsignet\fR
 .IP
-Use the signet chain. Equivalent to \fB\-chain\fR=\fI\,signet\/\fR. Note that the network
-is defined by the \fB\-signetchallenge\fR parameter
+Use the signet chain. Equivalent to \fBchain\fR=\fI\,signet\/\fR. Note that the network
+is defined by the \fBsignetchallenge\fR parameter
 .HP
-\fB\-signetchallenge\fR
+\fBsignetchallenge\fR
 .IP
 Blocks must satisfy the given script to be considered valid (only for
 signet networks; defaults to the global default signet test
 network challenge)
 .HP
-\fB\-signetseednode\fR
+\fBsignetseednode\fR
 .IP
 Specify a seed node for the signet network, in the hostname[:port]
 format, e.g. sig.net:1234 (may be used multiple times to specify
 multiple seed nodes; defaults to the global default signet test
 network seed node(s))
 .HP
-\fB\-testnet\fR
+\fBtestnet\fR
 .IP
-Use the test chain. Equivalent to \fB\-chain\fR=\fI\,test\/\fR.
+Use the test chain. Equivalent to \fBchain\fR=\fI\,test\/\fR.
 .PP
 Node relay options:
 .HP
-\fB\-bytespersigop\fR
+\fBbytespersigop\fR
 .IP
 Equivalent bytes per sigop in transactions for relay and mining
 (default: 20)
 .HP
-\fB\-datacarrier\fR
+\fBdatacarrier\fR
 .IP
 Relay and mine data carrier transactions (default: 1)
 .HP
-\fB\-datacarriersize\fR
+\fBdatacarriersize\fR
 .IP
 Maximum size of data in data carrier transactions we relay and mine
 (default: 83)
 .HP
-\fB\-minrelaytxfee=\fR<amt>
+\fBminrelaytxfee=\fR<amt>
 .IP
 Fees (in PART/kB) smaller than this are considered zero fee for
 relaying, mining and transaction creation (default: 0.00001)
 .HP
-\fB\-whitelistforcerelay\fR
+\fBwhitelistforcerelay\fR
 .IP
 Add 'forcerelay' permission to whitelisted inbound peers with default
 permissions. This will relay transactions even if the
 transactions were already in the mempool. (default: 0)
 .HP
-\fB\-whitelistrelay\fR
+\fBwhitelistrelay\fR
 .IP
 Add 'relay' permission to whitelisted inbound peers with default
 permissions. This will accept relayed transactions even when not
@@ -694,216 +694,216 @@ relaying transactions (default: 1)
 .PP
 Block creation options:
 .HP
-\fB\-blockmaxweight=\fR<n>
+\fBblockmaxweight=\fR<n>
 .IP
 Set maximum BIP141 block weight (default: 3996000)
 .HP
-\fB\-blockmintxfee=\fR<amt>
+\fBblockmintxfee=\fR<amt>
 .IP
 Set lowest fee rate (in PART/kB) for transactions to be included in
 block creation. (default: 0.00001)
 .PP
 RPC server options:
 .HP
-\fB\-acceptanontxn\fR
+\fBacceptanontxn\fR
 .IP
 Relay and mine "anon" transactions (default: 0)
 .HP
-\fB\-acceptblindtxn\fR
+\fBacceptblindtxn\fR
 .IP
 Relay and mine "anon" transactions (default: 0)
 .HP
-\fB\-checkpeerheight\fR
+\fBcheckpeerheight\fR
 .IP
-Consider peer height for initial\-block\-download status (default: true)
+Consider peer height for initialblockdownload status (default: true)
 .HP
-\fB\-displaylocaltime\fR
+\fBdisplaylocaltime\fR
 .IP
 Display human readable time strings in local timezone (default: false)
 .HP
-\fB\-displayutctime\fR
+\fBdisplayutctime\fR
 .IP
 Display human readable time strings in UTC (default: false)
 .HP
-\fB\-rebuildrollingindices\fR
+\fBrebuildrollingindices\fR
 .IP
 Force rebuild of rolling indices (default: false)
 .HP
-\fB\-rest\fR
+\fBrest\fR
 .IP
 Accept public REST requests (default: 0)
 .HP
-\fB\-rpcallowip=\fR<ip>
+\fBrpcallowip=\fR<ip>
 .IP
-Allow JSON\-RPC connections from specified source. Valid for <ip> are a
+Allow JSONRPC connections from specified source. Valid for <ip> are a
 single IP (e.g. 1.2.3.4), a network/netmask (e.g.
 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This
 option can be specified multiple times
 .HP
-\fB\-rpcauth=\fR<userpw>
+\fBrpcauth=\fR<userpw>
 .IP
-Username and HMAC\-SHA\-256 hashed password for JSON\-RPC connections. The
+Username and HMACSHA256 hashed password for JSONRPC connections. The
 field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A
 canonical python script is included in share/rpcauth. The client
 then connects normally using the
 rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This
 option can be specified multiple times
 .HP
-\fB\-rpcbind=\fR<addr>[:port]
+\fBrpcbind=\fR<addr>[:port]
 .IP
-Bind to given address to listen for JSON\-RPC connections. Do not expose
+Bind to given address to listen for JSONRPC connections. Do not expose
 the RPC server to untrusted networks such as the public internet!
-This option is ignored unless \fB\-rpcallowip\fR is also passed. Port is
-optional and overrides \fB\-rpcport\fR. Use [host]:port notation for
+This option is ignored unless \fBrpcallowip\fR is also passed. Port is
+optional and overrides \fBrpcport\fR. Use [host]:port notation for
 IPv6. This option can be specified multiple times (default:
 127.0.0.1 and ::1 i.e., localhost)
 .HP
-\fB\-rpccookiefile=\fR<loc>
+\fBrpccookiefile=\fR<loc>
 .IP
 Location of the auth cookie. Relative paths will be prefixed by a
-net\-specific datadir location. (default: data dir)
+netspecific datadir location. (default: data dir)
 .HP
-\fB\-rpccorsdomain=\fR<domain>
+\fBrpccorsdomain=\fR<domain>
 .IP
-Allow JSON\-RPC connections from specified domain (e.g.
+Allow JSONRPC connections from specified domain (e.g.
 http://localhost:4200 or "*"). This needs to be set if you are
 using the Particl GUI in a browser.
 .HP
-\fB\-rpcpassword=\fR<pw>
+\fBrpcpassword=\fR<pw>
 .IP
-Password for JSON\-RPC connections
+Password for JSONRPC connections
 .HP
-\fB\-rpcport=\fR<port>
+\fBrpcport=\fR<port>
 .IP
-Listen for JSON\-RPC connections on <port> (default: 51735, testnet:
+Listen for JSONRPC connections on <port> (default: 51735, testnet:
 51935, signet: 31932, regtest: 51936)
 .HP
-\fB\-rpcserialversion\fR
+\fBrpcserialversion\fR
 .IP
 Sets the serialization of raw transaction or block hex returned in
-non\-verbose mode, non\-segwit(0) or segwit(1) (default: 1)
+nonverbose mode, nonsegwit(0) or segwit(1) (default: 1)
 .HP
-\fB\-rpcthreads=\fR<n>
+\fBrpcthreads=\fR<n>
 .IP
 Set the number of threads to service RPC calls (default: 4)
 .HP
-\fB\-rpcuser=\fR<user>
+\fBrpcuser=\fR<user>
 .IP
-Username for JSON\-RPC connections
+Username for JSONRPC connections
 .HP
-\fB\-rpcwhitelist=\fR<whitelist>
+\fBrpcwhitelist=\fR<whitelist>
 .IP
 Set a whitelist to filter incoming RPC calls for a specific user. The
 field <whitelist> comes in the format: <USERNAME>:<rpc 1>,<rpc
 2>,...,<rpc n>. If multiple whitelists are set for a given user,
-they are set\-intersected. See \fB\-rpcwhitelistdefault\fR documentation
+they are setintersected. See \fBrpcwhitelistdefault\fR documentation
 for information on default whitelist behavior.
 .HP
-\fB\-rpcwhitelistdefault\fR
+\fBrpcwhitelistdefault\fR
 .IP
 Sets default behavior for rpc whitelisting. Unless rpcwhitelistdefault
-is set to 0, if any \fB\-rpcwhitelist\fR is set, the rpc server acts as
-if all rpc users are subject to empty\-unless\-otherwise\-specified
+is set to 0, if any \fBrpcwhitelist\fR is set, the rpc server acts as
+if all rpc users are subject to emptyunlessotherwisespecified
 whitelists. If rpcwhitelistdefault is set to 1 and no
-\fB\-rpcwhitelist\fR is set, rpc server acts as if all rpc users are
+\fBrpcwhitelist\fR is set, rpc server acts as if all rpc users are
 subject to empty whitelists.
 .HP
-\fB\-server\fR
+\fBserver\fR
 .IP
-Accept command line and JSON\-RPC commands
+Accept command line and JSONRPC commands
 .PP
 SMSG Commands:
 .HP
-\fB\-smsg\fR
+\fBsmsg\fR
 .IP
 Enable secure messaging. (default: true)
 .HP
-\fB\-smsgbantime=\fR<n>
+\fBsmsgbantime=\fR<n>
 .IP
 Number of seconds to ignore misbehaving peers for (default: 28800)
 .HP
-\fB\-smsgmaxreceive=\fR<n>
+\fBsmsgmaxreceive=\fR<n>
 .IP
 Max number of data messages to tolerate from peers, counter decreases
 over time (default: 4000)
 .HP
-\fB\-smsgnotify=\fR<cmd>
+\fBsmsgnotify=\fR<cmd>
 .IP
 Execute command when a message is received. (%s in cmd is replaced by
 receiving address)
 .HP
-\fB\-smsgsaddnewkeys\fR
+\fBsmsgsaddnewkeys\fR
 .IP
 Scan for incoming messages on new wallet keys. (default: false)
 .HP
-\fB\-smsgscanchain\fR
+\fBsmsgscanchain\fR
 .IP
 Scan the block chain for public key addresses on startup. (default:
 false)
 .HP
-\fB\-smsgscanincoming\fR
+\fBsmsgscanincoming\fR
 .IP
 Scan incoming blocks for public key addresses. (default: false)
 .PP
 Particl wallet Commands:
 .HP
-\fB\-createdefaultmasterkey\fR
+\fBcreatedefaultmasterkey\fR
 .IP
 Generate a random master key and main account if no master key exists.
 (default: false)
 .HP
-\fB\-defaultlookaheadsize=\fR<n>
+\fBdefaultlookaheadsize=\fR<n>
 .IP
 Number of keys to load into the lookahead pool per chain. (default: 64)
 .HP
-\fB\-extkeysaveancestors\fR
+\fBextkeysaveancestors\fR
 .IP
 On saving a key from the lookahead pool, save all unsaved keys leading
 up to it too. (default: true)
 .HP
-\fB\-stealthv1lookaheadsize=\fR<n>
+\fBstealthv1lookaheadsize=\fR<n>
 .IP
 Number of V1 stealth keys to look ahead during a rescan. (default: 5)
 .HP
-\fB\-stealthv2lookaheadsize=\fR<n>
+\fBstealthv2lookaheadsize=\fR<n>
 .IP
 Number of V2 stealth keys to look ahead during a rescan. (default: 5)
 .PP
 Staking Commands:
 .HP
-\fB\-minersleep=\fR<n>
+\fBminersleep=\fR<n>
 .IP
 Milliseconds between stake attempts. Lowering this param will not result
 in more stakes. (default: 500)
 .HP
-\fB\-minstakeinterval=\fR<n>
+\fBminstakeinterval=\fR<n>
 .IP
 Minimum time in seconds between successful stakes (default: 0)
 .HP
-\fB\-reservebalance=\fR<amount>
+\fBreservebalance=\fR<amount>
 .IP
 Ensure available balance remains above reservebalance. (default: 0)
 .HP
-\fB\-stakethreadconddelayms\fR
+\fBstakethreadconddelayms\fR
 .IP
 Number of milliseconds to delay staking for on error condition (default:
 60000)
 .HP
-\fB\-staking\fR
+\fBstaking\fR
 .IP
 Stake your coins to support network and gain reward (default: true)
 .HP
-\fB\-stakingthreads\fR
+\fBstakingthreads\fR
 .IP
 Number of threads to start for staking, max 1 per active wallet, will
 divide wallets evenly between threads (default: 1)
 .HP
-\fB\-treasurydonationpercent=\fR<n>
+\fBtreasurydonationpercent=\fR<n>
 .IP
 Percentage of block reward donated to the treasury fund, overridden by
 system minimum. (default: 0)
 .SH COPYRIGHT
-Copyright (C) 2017-2021 The Particl Core developers
+Copyright (C) 2017-2022 The Particl Core developers
 Copyright (C) 2009-2021 The Bitcoin Core developers
 
 Please contribute if you find Particl Core useful. Visit <https://particl.io/>
diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index 043db6151e..25eca400df 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -4,6 +4,11 @@
 
 - wallet: Fix receiving anon txns on locked wallet and new address.
 - wallet: Fix passing anon_ring_size parameter to fundrawtransactionfrom.
+- Raised min protocol version to 90014
+- Disable p2sh-p2wpkh addresses.
+- qt: 'Import Chain' defaults to disabled.
+- wallet, qt: Default ring size set to 12 to match Particl Desktop.
+- wallet: Fix BTC segwit address path and label in getaddressinfo.
 
 
 0.21.2.6
diff --git a/src/qt/locale/bitcoin_en.ts b/src/qt/locale/bitcoin_en.ts
index 77afa84379..b35e74aaf0 100644
--- a/src/qt/locale/bitcoin_en.ts
+++ b/src/qt/locale/bitcoin_en.ts
@@ -1287,7 +1287,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+88"/>
+        <location line="+91"/>
         <source>The entered address &quot;%1&quot; is not a valid Particl address.</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1307,12 +1307,12 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="-108"/>
+        <location line="-111"/>
         <source>New receiving address</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+113"/>
+        <location line="+116"/>
         <source>New key generation failed.</source>
         <translation type="unfinished"></translation>
     </message>
@@ -1512,12 +1512,12 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>
     </message>
     <message>
         <location line="+7"/>
-        <source>Import Chain</source>
+        <source>Create Import Chain</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
         <location line="+7"/>
-        <source>Only needed if you&apos;re importing </source>
+        <source>Only needed if you&apos;re importing from the previous chain</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
@@ -3295,7 +3295,7 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>
         <translation type="unfinished"></translation>
     </message>
     <message>
-        <location line="+148"/>
+        <location line="+149"/>
         <source>Could not unlock wallet.</source>
         <translation type="unfinished"></translation>
     </message>

From d48cda6abb4a927625cd711f98bbb768f941ce7d Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Thu, 24 Feb 2022 11:41:10 +0200
Subject: [PATCH 18/57] tests: Fix typo

---
 test/functional/feature_part_anon.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/test/functional/feature_part_anon.py b/test/functional/feature_part_anon.py
index db1207d4d9..2f79cb6745 100755
--- a/test/functional/feature_part_anon.py
+++ b/test/functional/feature_part_anon.py
@@ -69,7 +69,7 @@ def run_test(self):
         for txnHash in txnHashes:
             assert(txnHash in ro['tx'])
 
-        txnHash = nodes[1].sendanontoanon(sxAddrTo0_1, 1, '', '', False, 'node1 -> node0 a->a', 5, 1))
+        txnHash = nodes[1].sendanontoanon(sxAddrTo0_1, 1, '', '', False, 'node1 -> node0 a->a', 5, 1)
         txnHashes = [txnHash,]
 
         assert(self.wait_for_mempool(nodes[0], txnHash))

From b41e4329f0743bbe3bda233004e653bb6393ee48 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Wed, 16 Mar 2022 22:17:17 +0200
Subject: [PATCH 19/57] rpc: Show spending txid in debugwallet output.

---
 src/anon.cpp               |  2 +-
 src/wallet/hdwallet.cpp    | 58 ++++++++++++++++++++++++++++++++------
 src/wallet/hdwallet.h      |  1 +
 src/wallet/rpchdwallet.cpp |  9 ++++--
 4 files changed, 58 insertions(+), 12 deletions(-)

diff --git a/src/anon.cpp b/src/anon.cpp
index 9f7c53b6e7..2839e74c6d 100644
--- a/src/anon.cpp
+++ b/src/anon.cpp
@@ -198,7 +198,7 @@ bool VerifyMLSAG(const CTransaction &tx, TxValidationState &state)
             if (pblocktree->ReadRCTKeyImage(ki, ki_data)) {
                 if (LogAcceptCategory(BCLog::RINGCT)) {
                     LogPrintf("%s: Duplicate keyimage detected %s, used in %s.\n", __func__,
-                        HexStr(ki), ki_data.txid.ToString());
+                              HexStr(ki), ki_data.txid.ToString());
                 }
                 if (ki_data.txid == txhash) {
                     if (state.m_check_equal_rct_txid &&
diff --git a/src/wallet/hdwallet.cpp b/src/wallet/hdwallet.cpp
index d058d16c14..38a3bccf7a 100644
--- a/src/wallet/hdwallet.cpp
+++ b/src/wallet/hdwallet.cpp
@@ -2535,9 +2535,9 @@ CAmount CHDWallet::GetSpendableBalance() const
         }
 
         for (const auto &r : rtx.vout) {
-            if (r.nType == OUTPUT_STANDARD
-                && (r.nFlags & ORF_OWNED || r.nFlags & ORF_STAKEONLY)
-                && !IsSpent(txhash, r.n)) {
+            if (r.nType == OUTPUT_STANDARD &&
+                (r.nFlags & ORF_OWNED || r.nFlags & ORF_STAKEONLY) &&
+                 !IsSpent(txhash, r.n)) {
                 nBalance += r.nValue;
             }
         }
@@ -12466,18 +12466,18 @@ bool CHDWallet::IsSpent(const uint256& hash, unsigned int n) const
     std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range;
     range = mapTxSpends.equal_range(outpoint);
 
-    for (TxSpends::const_iterator it = range.first; it != range.second; ++it)
-    {
+    for (TxSpends::const_iterator it = range.first; it != range.second; ++it) {
         const uint256 &wtxid = it->second;
         MapWallet_t::const_iterator mit = mapWallet.find(wtxid);
-        if (mit != mapWallet.end())
-        {
-            if (mit->second.isAbandoned())
+        if (mit != mapWallet.end()) {
+            if (mit->second.isAbandoned()) {
                 continue;
+            }
 
             int depth = mit->second.GetDepthInMainChain();
-            if (depth > 0  || (depth == 0 && !mit->second.isAbandoned()))
+            if (depth > 0 || (depth == 0 && !mit->second.isAbandoned())) {
                 return true; // Spent
+            }
         }
 
         MapRecords_t::const_iterator rit = mapRecords.find(wtxid);
@@ -12496,6 +12496,46 @@ bool CHDWallet::IsSpent(const uint256& hash, unsigned int n) const
     return false;
 };
 
+bool CHDWallet::GetSpendingTxid(const uint256& hash, unsigned int n, uint256 &spent_by_txid) const
+{
+    const COutPoint outpoint(hash, n);
+    if (m_collapsed_txn_inputs.find(outpoint) != m_collapsed_txn_inputs.end()) {
+        return true;
+    }
+    std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range;
+    range = mapTxSpends.equal_range(outpoint);
+
+    for (TxSpends::const_iterator it = range.first; it != range.second; ++it) {
+        const uint256 &wtxid = it->second;
+        MapWallet_t::const_iterator mit = mapWallet.find(wtxid);
+        if (mit != mapWallet.end()) {
+            if (mit->second.isAbandoned()) {
+                continue;
+            }
+
+            int depth = mit->second.GetDepthInMainChain();
+            if (depth > 0 || (depth == 0 && !mit->second.isAbandoned())) {
+                spent_by_txid = wtxid;
+                return true; // Spent
+            }
+        }
+
+        MapRecords_t::const_iterator rit = mapRecords.find(wtxid);
+        if (rit != mapRecords.end()) {
+            if (rit->second.IsAbandoned()) {
+                continue;
+            }
+
+            int depth = GetDepthInMainChain(rit->second);
+            if (depth >= 0) {
+                spent_by_txid = wtxid;
+                return true; // Spent
+            }
+        }
+    }
+    return false;
+};
+
 bool CHDWallet::IsSpentKey(const CScript *pscript) const
 {
     CTxDestination dst;
diff --git a/src/wallet/hdwallet.h b/src/wallet/hdwallet.h
index e83faf6be1..1e694bdedc 100644
--- a/src/wallet/hdwallet.h
+++ b/src/wallet/hdwallet.h
@@ -437,6 +437,7 @@ class CHDWallet : public CWallet
     bool SelectCoinsMinConf(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutputR> vCoins, std::vector<std::pair<MapRecords_t::const_iterator,unsigned int> > &setCoinsRet, CAmount &nValueRet) const;
 
     bool IsSpent(const uint256& hash, unsigned int n) const override EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
+    bool GetSpendingTxid(const uint256& hash, unsigned int n, uint256 &spent_by_txid) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
 
     // Whether this or any UTXO with the same CTxDestination has been spent.
     bool IsSpentKey(const CScript *pscript) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
diff --git a/src/wallet/rpchdwallet.cpp b/src/wallet/rpchdwallet.cpp
index 8525586e08..b496447bcc 100644
--- a/src/wallet/rpchdwallet.cpp
+++ b/src/wallet/rpchdwallet.cpp
@@ -6622,7 +6622,9 @@ static UniValue debugwallet(const JSONRPCRequest &request)
                         "options"},
                 },
                 RPCResults{},
-                RPCExamples{""},
+                RPCExamples{
+                    HelpExampleCli("debugwallet", "\"{\\\"attempt_repair\\\":true}\"")
+                },
             }.Check(request);
 
     std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);
@@ -7115,13 +7117,16 @@ static UniValue debugwallet(const JSONRPCRequest &request)
                         }
                         CAnonKeyImageInfo ki_data;
                         bool spent_in_chain = pblocktree->ReadRCTKeyImage(ki, ki_data);
-                        bool spent_in_wallet = pwallet->IsSpent(txhash, r.n);
+                        uint256 spent_by;
+                        bool spent_in_wallet = pwallet->GetSpendingTxid(txhash, r.n, spent_by);
 
                         if (spent_in_chain && !spent_in_wallet) {
                             add_error("Spent in chain but not wallet.", txhash, r.n);
+                            errors.get(errors.size() - 1).pushKV("spent_by", ki_data.txid.ToString());
                         } else
                         if (!spent_in_chain && spent_in_wallet) {
                             add_error("Spent in wallet but not chain.", txhash, r.n);
+                            errors.get(errors.size() - 1).pushKV("spent_by", spent_by.ToString());
                         }
                     }
                 }

From 1ce7db80584ee5ef32ccd17ca344721595f4c6cc Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Fri, 18 Mar 2022 16:39:12 +0200
Subject: [PATCH 20/57] rpc: Fix bug in filtertransactions hiding txns with
 watchonly inputs and spendable outputs.

---
 doc/release-notes-particl.md |  1 +
 src/wallet/rpchdwallet.cpp   | 41 +++++++++++++++++++++++++++---------
 2 files changed, 32 insertions(+), 10 deletions(-)

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index 25eca400df..152fbff6b3 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -94,6 +94,7 @@
 - qt: 'Import Chain' defaults to disabled.
 - wallet, qt: Default ring size set to 12 to match Particl Desktop.
 - wallet: Fix BTC segwit address path and label in getaddressinfo.
+- rpc: Fix bug in filtertransactions hiding txns with watchonly inputs and spendable outputs.
 
 
 0.19.2.19
diff --git a/src/wallet/rpchdwallet.cpp b/src/wallet/rpchdwallet.cpp
index b496447bcc..657cc3b59b 100644
--- a/src/wallet/rpchdwallet.cpp
+++ b/src/wallet/rpchdwallet.cpp
@@ -3013,10 +3013,12 @@ static bool ParseOutput(
     const CWalletTx           &wtx,
     const isminefilter        &watchonly,
     std::vector<std::string>  &addresses,
-    std::vector<std::string>  &amounts
+    std::vector<std::string>  &amounts,
+    bool                      &watch_only_out
 ) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)
 {
     CBitcoinAddress addr;
+    watch_only_out = false;
 
     std::string sKey = strprintf("n%d", o.vout);
     mapValue_t::const_iterator mvi = wtx.mapValue.find(sKey);
@@ -3030,6 +3032,7 @@ static bool ParseOutput(
     if (o.ismine & ISMINE_WATCH_ONLY) {
         if (watchonly & ISMINE_WATCH_ONLY) {
             output.pushKV("involvesWatchonly", true);
+            watch_only_out = true;
         } else {
             return false;
         }
@@ -3077,9 +3080,6 @@ static void ParseOutputs(
         ISMINE_ALL,
         true);
 
-    if (wtx.IsFromMe(ISMINE_WATCH_ONLY) && !(watchonly & ISMINE_WATCH_ONLY)) {
-        return;
-    }
     if (hide_zero_coinstakes && !listStaked.empty() && nFee == 0) {
         return;
     }
@@ -3094,6 +3094,7 @@ static void ParseOutputs(
     }
 
     // Staked
+    size_t num_watchonly = 0;
     if (!listStaked.empty()) {
         if (wtx.GetDepthInMainChain() < 1) {
             entry.pushKV("category", "orphaned_stake");
@@ -3102,6 +3103,7 @@ static void ParseOutputs(
         }
         for (const auto &s : listStaked) {
             UniValue output(UniValue::VOBJ);
+            bool is_watchonly = false;
             if (!ParseOutput(
                 output,
                 s,
@@ -3109,11 +3111,13 @@ static void ParseOutputs(
                 wtx,
                 watchonly,
                 addresses,
-                amounts)) {
+                amounts,
+                is_watchonly)) {
                 return ;
             }
             output.pushKV("amount", ValueFromAmount(s.amount));
             outputs.push_back(output);
+            num_watchonly += is_watchonly ? 1 : 0;
         }
         amount += -nFee;
     } else {
@@ -3121,18 +3125,22 @@ static void ParseOutputs(
         if (!listSent.empty()) {
             for (const auto &s : listSent) {
                 UniValue output(UniValue::VOBJ);
+                bool is_watchonly = false;
                 if (!ParseOutput(output,
                     s,
                     pwallet,
                     wtx,
                     watchonly,
                     addresses,
-                    amounts)) {
+                    amounts,
+                    is_watchonly)) {
+                    LogPrintf("[rm] ret 4\n");
                     return ;
                 }
                 output.pushKV("amount", ValueFromAmount(-s.amount));
                 amount -= s.amount;
                 outputs.push_back(output);
+                num_watchonly += is_watchonly ? 1 : 0;
             }
         }
 
@@ -3140,6 +3148,7 @@ static void ParseOutputs(
         if (!listReceived.empty()) {
             for (const auto &r : listReceived) {
                 UniValue output(UniValue::VOBJ);
+                bool is_watchonly = false;
                 if (!ParseOutput(
                     output,
                     r,
@@ -3147,8 +3156,8 @@ static void ParseOutputs(
                     wtx,
                     watchonly,
                     addresses,
-                    amounts
-                )) {
+                    amounts,
+                    is_watchonly)) {
                     return ;
                 }
                 if (r.destination.type() == typeid(PKHash)) {
@@ -3171,10 +3180,23 @@ static void ParseOutputs(
                 }
                 if (!fExists) {
                     outputs.push_back(output);
+                    num_watchonly += is_watchonly ? 1 : 0;
                 }
             }
         }
 
+        CAmount debit_watchonly = wtx.GetDebit(ISMINE_WATCH_ONLY);
+        CAmount debit_spendable = wtx.GetDebit(ISMINE_SPENDABLE);
+        if (num_watchonly >= outputs.size()) { // Only has watchonly outputs or none
+            bool from_watchonly_only = debit_watchonly && !debit_spendable;
+            if (from_watchonly_only && !(watchonly & ISMINE_WATCH_ONLY)) {
+                return;
+            }
+        }
+        if (debit_watchonly) {
+            entry.__pushKV("involvesWatchonlyInput", "true");
+        }
+
         if (wtx.IsCoinBase()) {
             if (wtx.GetDepthInMainChain() < 1) {
                 entry.pushKV("category", "orphan");
@@ -3896,8 +3918,7 @@ static UniValue filtertransactions(const JSONRPCRequest &request)
                 ? a[sort].get_real() > b[sort].get_real()
             : sort == "amount"
                 ? a_amount > b_amount
-            : false
-            );
+            : false);
     });
 
     // Filter, skip, count and sum

From 036eab3e97ab014fc0f7e9ec1c3f7cc7a6ba80c0 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Fri, 1 Apr 2022 15:01:38 +0200
Subject: [PATCH 21/57] tests: Add common blocks to p2p_part_fork.py

---
 test/functional/p2p_part_fork.py | 21 +++++++++++++++------
 1 file changed, 15 insertions(+), 6 deletions(-)

diff --git a/test/functional/p2p_part_fork.py b/test/functional/p2p_part_fork.py
index ed8d73ebae..a202b728f2 100755
--- a/test/functional/p2p_part_fork.py
+++ b/test/functional/p2p_part_fork.py
@@ -26,6 +26,8 @@ def setup_network(self, split=False):
         self.connect_nodes_bi(0, 2)
         self.connect_nodes_bi(1, 2)
 
+        self.connect_nodes_bi(0, 3)
+
         self.connect_nodes_bi(3, 4)
         self.connect_nodes_bi(3, 5)
         self.connect_nodes_bi(4, 5)
@@ -47,9 +49,16 @@ def run_test(self):
 
         n0_wi_before = nodes[0].getwalletinfo()
 
+        common_blocks = 5
+        self.stakeBlocks(common_blocks)
+
+        # Disconnect groups
+        self.disconnect_nodes(0, 3)
+        self.disconnect_nodes(0, 3)
+
         # Start staking
-        nBlocksShorterChain = 2
-        nBlocksLongerChain = 5
+        nBlocksShorterChain = common_blocks + 2
+        nBlocksLongerChain = common_blocks + 5
 
         nodes[3].walletsettings('stakelimit', {'height': nBlocksLongerChain})
         nodes[3].reservebalance(False)
@@ -81,7 +90,7 @@ def run_test(self):
         nodes[3].reservebalance(True, 10000000)
 
         node0_chain = []
-        for k in range(1, nBlocksLongerChain+1):
+        for k in range(1, nBlocksLongerChain + 1):
             try:
                 ro = nodes[0].getblockhash(k)
             except JSONRPCException as e:
@@ -91,7 +100,7 @@ def run_test(self):
             print('node0 ', k, ' - ', ro)
 
         node3_chain = []
-        for k in range(1, 6):
+        for k in range(1, nBlocksLongerChain + 1):
             ro = nodes[3].getblockhash(k)
             node3_chain.append(ro)
             print('node3 ', k, ' - ', ro)
@@ -131,9 +140,9 @@ def run_test(self):
 
 
         ro = nodes[0].getblockchaininfo()
-        assert(ro['blocks'] == 5)
+        assert(ro['blocks'] == nBlocksLongerChain)
         ro = nodes[3].getblockchaininfo()
-        assert(ro['blocks'] == 5)
+        assert(ro['blocks'] == nBlocksLongerChain)
 
         # Ensure all valid txns are trusted
         # resendwallettransactions() has a delay

From f6016c6b8a03eb596878772989e7a201d88eb7d1 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Fri, 1 Apr 2022 15:14:53 +0200
Subject: [PATCH 22/57] rpc: Backport fixes

---
 src/insight/rpc.cpp        |  1 +
 src/rpc/rawtransaction.cpp |  1 +
 src/wallet/rpcwallet.cpp   | 47 +++++++++++++++++++-------------------
 3 files changed, 26 insertions(+), 23 deletions(-)

diff --git a/src/insight/rpc.cpp b/src/insight/rpc.cpp
index fdbf0cf2b0..16c489e320 100644
--- a/src/insight/rpc.cpp
+++ b/src/insight/rpc.cpp
@@ -1354,6 +1354,7 @@ UniValue getinsightinfo(const JSONRPCRequest& request)
                     {RPCResult::Type::BOOL, "addressindex", "True if addressindex is enabled"},
                     {RPCResult::Type::BOOL, "spentindex", "True if spentindex is enabled"},
                     {RPCResult::Type::BOOL, "timestampindex", "True if timestampindex is enabled"},
+                    {RPCResult::Type::BOOL, "balancesindex", "True if balancesindex is enabled"},
                     {RPCResult::Type::BOOL, "coldstakeindex", "True if coldstakeindex is enabled"},
                 }
             },
diff --git a/src/rpc/rawtransaction.cpp b/src/rpc/rawtransaction.cpp
index 5e9e49ba32..c9d0a98246 100644
--- a/src/rpc/rawtransaction.cpp
+++ b/src/rpc/rawtransaction.cpp
@@ -51,6 +51,7 @@ void TxToJSONExpanded(const CTransaction& tx, const uint256 hashBlock, const CTx
     entry.pushKV("hash", tx.GetWitnessHash().GetHex());
     entry.pushKV("size", (int)::GetSerializeSize(tx, PROTOCOL_VERSION));
     entry.pushKV("vsize", (int)::GetVirtualTransactionSize(tx));
+    entry.pushKV("weight", GetTransactionWeight(tx));
     entry.pushKV("version", tx.nVersion);
     entry.pushKV("locktime", (int64_t)tx.nLockTime);
 
diff --git a/src/wallet/rpcwallet.cpp b/src/wallet/rpcwallet.cpp
index 3efd4fa3f1..69295e9e46 100644
--- a/src/wallet/rpcwallet.cpp
+++ b/src/wallet/rpcwallet.cpp
@@ -1913,34 +1913,35 @@ static void ListRecord(const CHDWallet *phdw, const uint256 &hash, const CTransa
 
         entry.pushKV("vout", r.n);
 
-        int confirms = phdw->GetDepthInMainChain(rtx);
-        entry.pushKV("confirmations", confirms);
-        if (confirms > 0) {
-            entry.pushKV("blockhash", rtx.blockHash.GetHex());
-            entry.pushKV("blockindex", rtx.nIndex);
-            PushTime(entry, "blocktime", rtx.nBlockTime);
-        } else {
-            entry.pushKV("trusted", phdw->IsTrusted(hash, rtx));
+        if (!r.sNarration.empty()) {
+            entry.pushKV("narration", r.sNarration);
         }
 
-        entry.pushKV("txid", hash.ToString());
-
-        UniValue conflicts(UniValue::VARR);
-        std::set<uint256> setconflicts = phdw->GetConflicts(hash);
-        setconflicts.erase(hash);
-        for (const auto &conflict : setconflicts) {
-            conflicts.push_back(conflict.GetHex());
-        }
-        entry.pushKV("walletconflicts", conflicts);
+        if (fLong) {
+            int confirms = phdw->GetDepthInMainChain(rtx);
+            entry.pushKV("confirmations", confirms);
+            if (confirms > 0) {
+                entry.pushKV("blockhash", rtx.blockHash.GetHex());
+                entry.pushKV("blockindex", rtx.nIndex);
+                PushTime(entry, "blocktime", rtx.nBlockTime);
+            } else {
+                entry.pushKV("trusted", phdw->IsTrusted(hash, rtx));
+            }
 
-        PushTime(entry, "time", rtx.GetTxTime());
+            entry.pushKV("txid", hash.ToString());
 
-        if (!r.sNarration.empty()) {
-            entry.pushKV("narration", r.sNarration);
-        }
+            UniValue conflicts(UniValue::VARR);
+            std::set<uint256> setconflicts = phdw->GetConflicts(hash);
+            setconflicts.erase(hash);
+            for (const auto &conflict : setconflicts) {
+                conflicts.push_back(conflict.GetHex());
+            }
+            entry.pushKV("walletconflicts", conflicts);
 
-        if (r.nFlags & ORF_FROM) {
-            entry.pushKV("abandoned", rtx.IsAbandoned());
+            PushTime(entry, "time", rtx.GetTxTime());
+            if (r.nFlags & ORF_FROM) {
+                entry.pushKV("abandoned", rtx.IsAbandoned());
+            }
         }
 
         ret.push_back(entry);

From d37453da13894ac971abeb7ba71927e7e50fb882 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Mon, 11 Apr 2022 13:40:07 +0200
Subject: [PATCH 23/57] wallet: Fix regression summing balances after fully
 importing watchonly stealthaddress.

---
 doc/release-notes-particl.md             |  6 ++++++
 src/wallet/hdwallet.cpp                  | 14 +++++++-------
 test/functional/wallet_part_watchonly.py | 10 ++++++++++
 3 files changed, 23 insertions(+), 7 deletions(-)

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index 152fbff6b3..38e982662c 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -1,4 +1,10 @@
 
+0.21.2.8
+==============
+
+- wallet: Fix regression summing balances after fully importing watchonly stealthaddress.
+
+
 0.21.2.7
 ==============
 
diff --git a/src/wallet/hdwallet.cpp b/src/wallet/hdwallet.cpp
index 38a3bccf7a..d9bc8a8e82 100644
--- a/src/wallet/hdwallet.cpp
+++ b/src/wallet/hdwallet.cpp
@@ -2720,9 +2720,9 @@ bool CHDWallet::GetBalances(CHDWalletBalances &bal, bool avoid_reuse) const
         //bal.nPartWatchOnlyImmature += wtx.GetImmatureWatchOnlyCredit(*locked_chain);
 
         int depth;
-        if (wtx.IsCoinStake()
-            && (depth = wtx.GetDepthInMainChain()) > 0 // checks for hashunset
-            && wtx.GetBlocksToMaturity() > 0) {
+        if (wtx.IsCoinStake() &&
+            (depth = wtx.GetDepthInMainChain()) > 0 && // checks for hashunset
+             wtx.GetBlocksToMaturity() > 0) {
             CAmount nSpendable, nWatchOnly;
             CHDWallet::GetCredit(*wtx.tx, nSpendable, nWatchOnly);
             bal.nPartStaked += nSpendable;
@@ -10410,8 +10410,7 @@ bool CHDWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, CWalletTx::
         bool fIsFromMe = false;
         MapWallet_t::const_iterator miw;
         MapRecords_t::const_iterator mir;
-        for (const auto &txin : tx.vin)
-        {
+        for (const auto &txin : tx.vin) {
             if (txin.IsAnonInput()) {
                 nRingCT++;
                 uint32_t nInputs, nRingSize;
@@ -10642,6 +10641,7 @@ int CHDWallet::OwnStandardOut(const CTxOutStandard *pout, const CTxOutData *pdat
     rout.nType = OUTPUT_STANDARD;
     if (mine & ISMINE_SPENDABLE) {
         rout.nFlags |= ORF_OWNED;
+        rout.nFlags &= ~(ORF_OWN_WATCH);
     } else
     if (mine & ISMINE_WATCH_COLDSTAKE) {
         rout.nFlags |= ORF_STAKEONLY;
@@ -10717,7 +10717,6 @@ int CHDWallet::OwnBlindOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOu
     };
     */
     rout.nType = OUTPUT_CT;
-
     CKeyID idk;
     const CEKAKey *pak = nullptr;
     const CEKASCKey *pasc = nullptr;
@@ -10732,6 +10731,7 @@ int CHDWallet::OwnBlindOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOu
     }
     if (mine & ISMINE_SPENDABLE) {
         rout.nFlags |= ORF_OWNED;
+        rout.nFlags &= ~(ORF_OWN_WATCH);
     } else {
         rout.nFlags |= ORF_WATCHONLY;
     }
@@ -10859,7 +10859,6 @@ int CHDWallet::OwnAnonOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOut
     CExtKeyAccount *pa = nullptr;
 
     rout.nType = OUTPUT_RINGCT;
-
     isminetype mine = HaveKey(idk, pak, pasc, pa);
     if (!(mine & ISMINE_ALL)) {
         return 0;
@@ -10869,6 +10868,7 @@ int CHDWallet::OwnAnonOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOut
     }
     if (mine & ISMINE_SPENDABLE) {
         rout.nFlags |= ORF_OWNED;
+        rout.nFlags &= ~(ORF_OWN_WATCH);
     } else {
         rout.nFlags |= ORF_WATCHONLY;
     }
diff --git a/test/functional/wallet_part_watchonly.py b/test/functional/wallet_part_watchonly.py
index eb3aeacd9c..697d170ae3 100755
--- a/test/functional/wallet_part_watchonly.py
+++ b/test/functional/wallet_part_watchonly.py
@@ -94,6 +94,7 @@ def run_test(self):
         assert(isclose(w2['mine']['anon_immature'], 0.0))
         assert(isclose(w2['watchonly']['anon_immature'], 10.0))
 
+        self.log.info('Test fully importing the watchonly stealth address')
         nodes[2].importstealthaddress(scan_vk, spend_vk)
         ro = nodes[2].getaddressinfo(sxaddr0)
         assert(ro['ismine'] == True)
@@ -101,6 +102,15 @@ def run_test(self):
 
         nodes[2].rescanblockchain(0)
 
+        w2_balances = nodes[2].getbalances()
+        w2_bm = w2_balances['mine']
+        assert(w2_bm['trusted'] == 1.0 or w2_bm['staked'] > 1.0)
+        assert(isclose(w2_bm['blind_trusted'], 10.0))
+        assert(isclose(w2_bm['anon_immature'], 10.0))
+        w2_bw = w2_balances['watchonly']
+        assert(w2_bw['anon_immature'] == 0.0)
+        assert(w2_bw['anon_immature'] == 0.0)
+
 
 if __name__ == '__main__':
     WalletParticlWatchOnlyTest().main()

From d9f1b81c8ed261b64096a0e08a2342e797313f70 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Mon, 11 Apr 2022 21:31:27 +0200
Subject: [PATCH 24/57] qt: Fix missing anon outputs in coincontrol.

---
 doc/release-notes-particl.md |  1 +
 src/interfaces/wallet.cpp    |  4 +-
 src/primitives/transaction.h |  6 +++
 src/wallet/hdwallet.cpp      | 97 +++++++++++++++++++++++++++++++++---
 src/wallet/hdwallet.h        |  4 +-
 src/wallet/rpchdwallet.cpp   |  1 -
 6 files changed, 103 insertions(+), 10 deletions(-)

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index 38e982662c..b892aa2ffc 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -101,6 +101,7 @@
 - wallet, qt: Default ring size set to 12 to match Particl Desktop.
 - wallet: Fix BTC segwit address path and label in getaddressinfo.
 - rpc: Fix bug in filtertransactions hiding txns with watchonly inputs and spendable outputs.
+- qt: Fix missing anon outputs in coincontrol.
 
 
 0.19.2.19
diff --git a/src/interfaces/wallet.cpp b/src/interfaces/wallet.cpp
index 2144015beb..458b05998a 100644
--- a/src/interfaces/wallet.cpp
+++ b/src/interfaces/wallet.cpp
@@ -576,8 +576,8 @@ class WalletImpl : public Wallet
     CoinsList listCoins(OutputTypes nType) override
     {
         CoinsList result;
-        if (m_wallet_part
-            && nType != OUTPUT_STANDARD) {
+        if (m_wallet_part &&
+            nType != OUTPUT_STANDARD) {
             LOCK(m_wallet_part->cs_wallet);
             for (const auto& entry : m_wallet_part->ListCoins(nType)) {
                 auto& group = result[entry.first];
diff --git a/src/primitives/transaction.h b/src/primitives/transaction.h
index 484f4bcaed..6dab79bdf7 100644
--- a/src/primitives/transaction.h
+++ b/src/primitives/transaction.h
@@ -299,6 +299,7 @@ class CTxOutBase
     virtual std::vector<uint8_t> *GetPData() { return nullptr; };
     virtual const std::vector<uint8_t> *GetPRangeproof() const { return nullptr; };
     virtual const std::vector<uint8_t> *GetPData() const { return nullptr; };
+    virtual bool GetPubKey(CCmpPubKey &pk) const { return false; };
 
     virtual bool GetCTFee(CAmount &nFee) const { return false; };
     virtual bool SetCTFee(CAmount &nFee) { return false; };
@@ -505,6 +506,11 @@ class CTxOutRingCT : public CTxOutBase
     {
         return &vData;
     }
+    bool GetPubKey(CCmpPubKey &pk_) const override
+    {
+        pk_ = pk;
+        return true;
+    }
 };
 
 class CTxOutData : public CTxOutBase
diff --git a/src/wallet/hdwallet.cpp b/src/wallet/hdwallet.cpp
index d9bc8a8e82..4820ddf43c 100644
--- a/src/wallet/hdwallet.cpp
+++ b/src/wallet/hdwallet.cpp
@@ -12233,24 +12233,106 @@ std::map<CTxDestination, std::vector<COutput>> CHDWallet::ListCoins() const
     return result;
 };
 
-bool GetAddress(const CHDWallet *pw, const COutputRecord *pout, CTxDestination &address)
+bool CHDWallet::GetAddressFromOutputRecord(const uint256 &txhash, const COutputRecord *pout, CTxDestination &address) const
 {
     if (ExtractDestination(pout->scriptPubKey, address)) {
         return true;
     }
     if (pout->vPath.size() > 0 && pout->vPath[0] == ORA_STEALTH) {
         if (pout->vPath.size() < 5) {
-            pw->WalletLogPrintf("%s: Warning, malformed vPath.\n", __func__);
+            WalletLogPrintf("%s: Warning, malformed vPath.\n", __func__);
         } else {
             uint32_t sidx;
             memcpy(&sidx, &pout->vPath[1], 4);
             CStealthAddress sx;
-            if (pw->GetStealthByIndex(sidx, sx)) {
+            if (GetStealthByIndex(sidx, sx)) {
                 address = sx;
             }
         }
         return true;
     }
+
+    // If an address can't be found for an RCT output, use the address of the output pubkey.
+    if (pout->nType == OUTPUT_RINGCT) {
+        CTransactionRef tx;
+        if (GetTransaction(txhash, tx)) {
+            if (tx->GetNumVOuts() > pout->n) {
+                CCmpPubKey pk;
+                if (tx->vpout[pout->n]->GetPubKey(pk)) {
+                    CKeyID idk = pk.GetID();
+                    address = PKHash(idk);
+                    return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+bool CHDWallet::GetFirstNonChangeAddress(const uint256 &hash, const CTransactionRecord &txr, const COutputRecord *pout, CTxDestination &address) const
+{
+    AssertLockHeld(cs_wallet);
+
+    const COutputRecord *por = pout;
+    const uint256 *txhash = &hash;
+    const CTransactionRecord *txn_r = &txr;
+    int txo_n = -1;
+    const CWalletTx *prevwtx{nullptr};
+    bool is_record = true;
+
+    auto set_next = [&] (const COutPoint &prevout) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet) {
+        MapWallet_t::const_iterator mwi;
+        MapRecords_t::const_iterator mri;
+        if ((mri = mapRecords.find(prevout.hash)) != mapRecords.end()) {
+            const CTransactionRecord &prevtx = mri->second;
+            const COutputRecord *txo = prevtx.GetOutput(prevout.n);
+            if (txo) {
+                is_record = true;
+                txhash = &prevout.hash;
+                txn_r = &prevtx;
+                por = txo;
+                return true;
+            }
+        } else
+        if ((mwi = mapWallet.find(prevout.hash)) != mapWallet.end()) {
+            prevwtx = &mwi->second;
+            if (prevwtx->tx->vpout.size() > prevout.n &&
+                IsMine(prevwtx->tx->vpout[prevout.n].get())) {
+                is_record = false;
+                txhash = &prevout.hash;
+                txo_n = prevout.n;
+                return true;
+            }
+        }
+        return false;
+    };
+
+    while (true) {
+        if (!is_record) {
+            const CTxOutBase *txo = prevwtx->tx->vpout[txo_n].get();
+            if (IsChange(txo)) {
+                const COutPoint &prevout = prevwtx->tx->vin[0].prevout;
+                if (set_next(prevout)) {
+                    continue;
+                }
+            }
+            return ExtractDestination(*(txo->GetPScriptPubKey()), address);
+        }
+
+        if (por->nType == OUTPUT_RINGCT) {
+            // No point grouping RCT outputs
+            return GetAddressFromOutputRecord(*txhash, por, address);
+        }
+        if (por->nFlags & ORF_CHANGE) {
+            const COutPoint &prevout = txn_r->vin[0];
+            if (set_next(prevout)) {
+                continue;
+            }
+        }
+        return GetAddressFromOutputRecord(*txhash, por, address);
+    }
+
     return false;
 }
 
@@ -12277,9 +12359,12 @@ std::map<CTxDestination, std::vector<COutputR>> CHDWallet::ListCoins(OutputTypes
         }
 
         const COutputRecord *oR = coin.rtx->second.GetOutput(coin.i);
-        GetAddress(this, oR, address);
-
-        result[address].emplace_back(std::move(coin));
+        if (GetFirstNonChangeAddress(coin.rtx->first, coin.rtx->second, oR, address)) {
+            result[address].emplace_back(std::move(coin));
+        } else {
+            // Using CNoDestination as the key corrupts the result map, warn instead
+            WalletLogPrintf("WARNING - Missing address for %s.%d\n", coin.rtx->first.ToString(), coin.i);
+        }
     }
 
     return result;
diff --git a/src/wallet/hdwallet.h b/src/wallet/hdwallet.h
index 1e694bdedc..13504499b3 100644
--- a/src/wallet/hdwallet.h
+++ b/src/wallet/hdwallet.h
@@ -427,10 +427,12 @@ class CHDWallet : public CWallet
 
     void AvailableAnonCoins(std::vector<COutputR> &vCoins, bool fOnlySafe=true, const CCoinControl *coinControl = nullptr, const CAmount& nMinimumAmount = 1, const CAmount& nMaximumAmount = MAX_MONEY, const CAmount& nMinimumSumAmount = MAX_MONEY, const uint64_t& nMaximumCount = 0) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
 
+    const CTxOutBase* FindNonChangeParentOutput(const CTransaction& tx, int output) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
+    bool GetAddressFromOutputRecord(const uint256 &txhash, const COutputRecord *pout, CTxDestination &address) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
+    bool GetFirstNonChangeAddress(const uint256 &hash, const CTransactionRecord &txr, const COutputRecord *pout, CTxDestination &address) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
     /**
      * Return list of available coins and locked coins grouped by non-change output address.
      */
-    const CTxOutBase* FindNonChangeParentOutput(const CTransaction& tx, int output) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
     std::map<CTxDestination, std::vector<COutput>> ListCoins() const override EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
     std::map<CTxDestination, std::vector<COutputR>> ListCoins(OutputTypes nType) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
 
diff --git a/src/wallet/rpchdwallet.cpp b/src/wallet/rpchdwallet.cpp
index 657cc3b59b..c139b53f14 100644
--- a/src/wallet/rpchdwallet.cpp
+++ b/src/wallet/rpchdwallet.cpp
@@ -3134,7 +3134,6 @@ static void ParseOutputs(
                     addresses,
                     amounts,
                     is_watchonly)) {
-                    LogPrintf("[rm] ret 4\n");
                     return ;
                 }
                 output.pushKV("amount", ValueFromAmount(-s.amount));

From 7d414cfc063877fc3e14cad59e28b97d326eea02 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Mon, 11 Apr 2022 21:42:40 +0200
Subject: [PATCH 25/57] validation: New checkpoints

---
 src/chainparams.cpp | 24 +++++++++++++-----------
 1 file changed, 13 insertions(+), 11 deletions(-)

diff --git a/src/chainparams.cpp b/src/chainparams.cpp
index 05f3b53736..9747578efa 100644
--- a/src/chainparams.cpp
+++ b/src/chainparams.cpp
@@ -497,8 +497,8 @@ class CMainParams : public CChainParams {
         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].min_activation_height = 709632; // Approximately November 12th, 2021
 
         // The best chain should have at least this much work.
-        consensus.nMinimumChainWork = uint256S("0x0000000000000000000000000000000000000000000000ebfc82a6882c940700");
-        consensus.defaultAssumeValid = uint256S("0x6b13071bc3f5689a3f8a29808f726654283714461076ea890f4272574ff2659f"); // 1117588
+        consensus.nMinimumChainWork = uint256S("0x0000000000000000000000000000000000000000000000f82647fbb4c6e90493");
+        consensus.defaultAssumeValid = uint256S("0x4e0328ad2e2cb4fe6cb9a46c675a00673ff0e2e3c8185d7055e404adefbc7a96"); // 1159409
 
         consensus.nMinRCTOutputDepth = 12;
 
@@ -608,13 +608,14 @@ class CMainParams : public CChainParams {
                 { 1075660,  uint256S("0x1357966bfddceb8ea97f15da76e61087be6254d0b62ce9d4959ceee9b75c89f3")},
                 { 1102310,  uint256S("0x4e43167170e4639dbb1fdb84cb5735853f9595ff42713c143b70fd0625a382cd")},
                 { 1117588,  uint256S("0x6b13071bc3f5689a3f8a29808f726654283714461076ea890f4272574ff2659f")},
+                { 1159409,  uint256S("0x4e0328ad2e2cb4fe6cb9a46c675a00673ff0e2e3c8185d7055e404adefbc7a96")},
             }
         };
 
         chainTxData = ChainTxData {
-            // Data from rpc: getchaintxstats 4096 6b13071bc3f5689a3f8a29808f726654283714461076ea890f4272574ff2659f
-            /* nTime    */ 1644310000,
-            /* nTxCount */ 1369222,
+            // Data from rpc: getchaintxstats 4096 4e0328ad2e2cb4fe6cb9a46c675a00673ff0e2e3c8185d7055e404adefbc7a96
+            /* nTime    */ 1649705872,
+            /* nTxCount */ 1428812,
             /* dTxRate  */ 0.01
         };
     }
@@ -699,8 +700,8 @@ class CTestNetParams : public CChainParams {
         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].min_activation_height = 0; // No activation delay
 
         // The best chain should have at least this much work.
-        consensus.nMinimumChainWork = uint256S("0x00000000000000000000000000000000000000000000001641346b2186c891b2");
-        consensus.defaultAssumeValid = uint256S("0xc8b34db63fb6ec97b557a969065e56167030c36c12b7c988561736ad3a5488c0"); // 1044185
+        consensus.nMinimumChainWork = uint256S("0x000000000000000000000000000000000000000000000017cad02326f93a294d");
+        consensus.defaultAssumeValid = uint256S("0x1e74a808cc907a48cdaf6f2cf5488a54d64a186fa7d65f5f717b11a8dc37d55e"); // 1086076
 
         consensus.nMinRCTOutputDepth = 12;
 
@@ -787,14 +788,15 @@ class CTestNetParams : public CChainParams {
                 {1010348, uint256S("0x12e6a081d1874b3dfff99e120b8e22599e15730c23c88805740c507c11c91809")},
                 {1029738, uint256S("0x62ca4edbeb88e371d36052f7bbb52a598b1ac13d9269b5205ba7ed228d8b742a")},
                 {1044185, uint256S("0xc8b34db63fb6ec97b557a969065e56167030c36c12b7c988561736ad3a5488c0")},
+                {1086076, uint256S("0x1e74a808cc907a48cdaf6f2cf5488a54d64a186fa7d65f5f717b11a8dc37d55e")},
             }
         };
 
         chainTxData = ChainTxData{
-            // Data from rpc: getchaintxstats 4096 c8b34db63fb6ec97b557a969065e56167030c36c12b7c988561736ad3a5488c0
-            /* nTime    */ 1644310032,
-            /* nTxCount */ 1108010,
-            /* dTxRate  */ 0.002
+            // Data from rpc: getchaintxstats 4096 1e74a808cc907a48cdaf6f2cf5488a54d64a186fa7d65f5f717b11a8dc37d55e
+            /* nTime    */ 1649705808,
+            /* nTxCount */ 1150550,
+            /* dTxRate  */ 0.005
         };
     }
 };

From a84a7efa5ba888dc60a0bcff5fa1bb07f322a758 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Mon, 11 Apr 2022 23:58:25 +0200
Subject: [PATCH 26/57] build: Raise version to 0.21.2.8

---
 configure.ac                                |  2 +-
 contrib/gitian-descriptors/assign_DISTNAME  |  2 ++
 contrib/gitian-descriptors/gitian-linux.yml |  2 +-
 contrib/gitian-descriptors/gitian-osx.yml   |  2 +-
 contrib/gitian-descriptors/gitian-win.yml   |  2 +-
 doc/man/particl-cli.1                       |  8 ++++----
 doc/man/particl-qt.1                        | 12 ++++++------
 doc/man/particl-tx.1                        |  8 ++++----
 doc/man/particl-wallet.1                    |  8 ++++----
 doc/man/particld.1                          | 12 ++++++------
 doc/release-notes-particl.md                |  3 +++
 11 files changed, 33 insertions(+), 28 deletions(-)

diff --git a/configure.ac b/configure.ac
index 807c44f6f1..47cb70803f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2,7 +2,7 @@ AC_PREREQ([2.69])
 define(_CLIENT_VERSION_MAJOR, 0)
 define(_CLIENT_VERSION_MINOR, 21)
 define(_CLIENT_VERSION_REVISION, 2)
-define(_CLIENT_VERSION_PARTICL, 7)
+define(_CLIENT_VERSION_PARTICL, 8)
 define(_CLIENT_VERSION_BUILD, 0)
 define(_CLIENT_VERSION_RC, 0)
 define(_CLIENT_VERSION_IS_RELEASE, true)
diff --git a/contrib/gitian-descriptors/assign_DISTNAME b/contrib/gitian-descriptors/assign_DISTNAME
index 75936dbe88..b71a4c1c30 100755
--- a/contrib/gitian-descriptors/assign_DISTNAME
+++ b/contrib/gitian-descriptors/assign_DISTNAME
@@ -9,4 +9,6 @@ if RECENT_TAG="$(git describe --exact-match HEAD)"; then
 else
     VERSION="$(git rev-parse --short=12 HEAD)"
 fi
+# git describe isn't detecting the tag in gitian
+VERSION="0.21.2.8"
 DISTNAME="particl-${VERSION}"
diff --git a/contrib/gitian-descriptors/gitian-linux.yml b/contrib/gitian-descriptors/gitian-linux.yml
index 483e3fcc3b..f46ec375f2 100644
--- a/contrib/gitian-descriptors/gitian-linux.yml
+++ b/contrib/gitian-descriptors/gitian-linux.yml
@@ -1,5 +1,5 @@
 ---
-name: "particl-linux-0.21.2.7"
+name: "particl-linux-0.21.2.8"
 enable_cache: true
 sudo: true
 distro: "ubuntu"
diff --git a/contrib/gitian-descriptors/gitian-osx.yml b/contrib/gitian-descriptors/gitian-osx.yml
index 8e583a7284..30d3151354 100644
--- a/contrib/gitian-descriptors/gitian-osx.yml
+++ b/contrib/gitian-descriptors/gitian-osx.yml
@@ -1,5 +1,5 @@
 ---
-name: "particl-osx-0.21.2.7"
+name: "particl-osx-0.21.2.8"
 enable_cache: true
 distro: "ubuntu"
 suites:
diff --git a/contrib/gitian-descriptors/gitian-win.yml b/contrib/gitian-descriptors/gitian-win.yml
index 98521293c0..0cd0c62554 100644
--- a/contrib/gitian-descriptors/gitian-win.yml
+++ b/contrib/gitian-descriptors/gitian-win.yml
@@ -1,5 +1,5 @@
 ---
-name: "particl-win-0.21.2.7"
+name: "particl-win-0.21.2.8"
 enable_cache: true
 sudo: true
 distro: "ubuntu"
diff --git a/doc/man/particl-cli.1 b/doc/man/particl-cli.1
index 96fbbea324..a7403d1601 100644
--- a/doc/man/particl-cli.1
+++ b/doc/man/particl-cli.1
@@ -1,7 +1,7 @@
-.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.48.5.
-.TH PARTICL-CLI "1" "February 2022" "particl-cli v0.21.2.7" "User Commands"
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
+.TH PARTICL-CLI "1" "April 2022" "particl-cli v0.21.2.8" "User Commands"
 .SH NAME
-particl-cli  manual page for particl-cli v0.21.2.7
+particl-cli  manual page for particl-cli v0.21.2.8
 .SH SYNOPSIS
 .B particl-cli
 [\fI\,options\/\fR] \fI\,<command> \/\fR[\fI\,params\/\fR]  \fI\,Send command to Particl Core\/\fR
@@ -15,7 +15,7 @@ particl-cli  manual page for particl-cli v0.21.2.7
 .B particl-cli
 [\fI\,options\/\fR] \fI\,help <command>      Get help for a command\/\fR
 .SH DESCRIPTION
-Particl Core RPC client version v0.21.2.7
+Particl Core RPC client version v0.21.2.8
 .SH OPTIONS
 .HP
 ?
diff --git a/doc/man/particl-qt.1 b/doc/man/particl-qt.1
index 38acaf9165..bddbf5eec6 100644
--- a/doc/man/particl-qt.1
+++ b/doc/man/particl-qt.1
@@ -1,12 +1,12 @@
-.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.48.5.
-.TH PARTICL-QT "1" "February 2022" "particl-qt v0.21.2.7" "User Commands"
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
+.TH PARTICL-QT "1" "April 2022" "particl-qt v0.21.2.8" "User Commands"
 .SH NAME
-particl-qt  manual page for particl-qt v0.21.2.7
+particl-qt  manual page for particl-qt v0.21.2.8
 .SH SYNOPSIS
 .B particl-qt
 [\fI\,command-line options\/\fR]
 .SH DESCRIPTION
-Particl Core version v0.21.2.7
+Particl Core version v0.21.2.8
 .SH OPTIONS
 .HP
 ?
@@ -28,9 +28,9 @@ long fork (%s in cmd is replaced by message)
 If this block is in the chain assume that it and its ancestors are valid
 and potentially skip their script verification (0 to verify all,
 default:
-6b13071bc3f5689a3f8a29808f726654283714461076ea890f4272574ff2659f,
+4e0328ad2e2cb4fe6cb9a46c675a00673ff0e2e3c8185d7055e404adefbc7a96,
 testnet:
-c8b34db63fb6ec97b557a969065e56167030c36c12b7c988561736ad3a5488c0,
+1e74a808cc907a48cdaf6f2cf5488a54d64a186fa7d65f5f717b11a8dc37d55e,
 signet:
 0000002a1de0f46379358c1fd09906f7ac59adf3712323ed90eb59e4c183c020)
 .HP
diff --git a/doc/man/particl-tx.1 b/doc/man/particl-tx.1
index 3f90dcb3b3..3cc758bcec 100644
--- a/doc/man/particl-tx.1
+++ b/doc/man/particl-tx.1
@@ -1,7 +1,7 @@
-.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.48.5.
-.TH PARTICL-TX "1" "February 2022" "particl-tx v0.21.2.7" "User Commands"
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
+.TH PARTICL-TX "1" "April 2022" "particl-tx v0.21.2.8" "User Commands"
 .SH NAME
-particl-tx  manual page for particl-tx v0.21.2.7
+particl-tx  manual page for particl-tx v0.21.2.8
 .SH SYNOPSIS
 .B particl-tx
 [\fI\,options\/\fR] \fI\,<hex-tx> \/\fR[\fI\,commands\/\fR]  \fI\,Update hex-encoded transaction\/\fR
@@ -9,7 +9,7 @@ particl-tx  manual page for particl-tx v0.21.2.7
 .B particl-tx
 [\fI\,options\/\fR] \fI\,-create \/\fR[\fI\,commands\/\fR]   \fI\,Create hex-encoded transaction\/\fR
 .SH DESCRIPTION
-Particl Core particltx utility version v0.21.2.7
+Particl Core particltx utility version v0.21.2.8
 .SH OPTIONS
 .HP
 ?
diff --git a/doc/man/particl-wallet.1 b/doc/man/particl-wallet.1
index 5181c6bd19..307650226b 100644
--- a/doc/man/particl-wallet.1
+++ b/doc/man/particl-wallet.1
@@ -1,9 +1,9 @@
-.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.48.5.
-.TH PARTICL-WALLET "1" "February 2022" "particl-wallet v0.21.2.7" "User Commands"
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
+.TH PARTICL-WALLET "1" "April 2022" "particl-wallet v0.21.2.8" "User Commands"
 .SH NAME
-particl-wallet  manual page for particl-wallet v0.21.2.7
+particl-wallet  manual page for particl-wallet v0.21.2.8
 .SH DESCRIPTION
-Particl Core particlwallet version v0.21.2.7
+Particl Core particlwallet version v0.21.2.8
 .PP
 particlwallet is an offline tool for creating and interacting with Particl Core wallet files.
 By default particlwallet will act on wallets in the default mainnet wallet directory in the datadir.
diff --git a/doc/man/particld.1 b/doc/man/particld.1
index bdc81306b5..02ccd315a6 100644
--- a/doc/man/particld.1
+++ b/doc/man/particld.1
@@ -1,12 +1,12 @@
-.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.48.5.
-.TH PARTICLD "1" "February 2022" "particld v0.21.2.7" "User Commands"
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
+.TH PARTICLD "1" "April 2022" "particld v0.21.2.8" "User Commands"
 .SH NAME
-particld  manual page for particld v0.21.2.7
+particld  manual page for particld v0.21.2.8
 .SH SYNOPSIS
 .B particld
 [\fI\,options\/\fR]                     \fI\,Start Particl Core\/\fR
 .SH DESCRIPTION
-Particl Core version v0.21.2.7
+Particl Core version v0.21.2.8
 .SH OPTIONS
 .HP
 ?
@@ -28,9 +28,9 @@ long fork (%s in cmd is replaced by message)
 If this block is in the chain assume that it and its ancestors are valid
 and potentially skip their script verification (0 to verify all,
 default:
-6b13071bc3f5689a3f8a29808f726654283714461076ea890f4272574ff2659f,
+4e0328ad2e2cb4fe6cb9a46c675a00673ff0e2e3c8185d7055e404adefbc7a96,
 testnet:
-c8b34db63fb6ec97b557a969065e56167030c36c12b7c988561736ad3a5488c0,
+1e74a808cc907a48cdaf6f2cf5488a54d64a186fa7d65f5f717b11a8dc37d55e,
 signet:
 0000002a1de0f46379358c1fd09906f7ac59adf3712323ed90eb59e4c183c020)
 .HP
diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index b892aa2ffc..b04328b9ce 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -3,6 +3,9 @@
 ==============
 
 - wallet: Fix regression summing balances after fully importing watchonly stealthaddress.
+- rpc: Fix bug in filtertransactions hiding txns with watchonly inputs and spendable outputs.
+- qt: Fix missing anon outputs in coincontrol.
+- New checkpoints.
 
 
 0.21.2.7

From aff138f6f8a3e20782d7d29ee342c9a7016a02a3 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Wed, 13 Apr 2022 16:50:01 +0200
Subject: [PATCH 27/57] smsg: Fix log messages.

---
 src/secp256k1/.gitignore |  1 +
 src/smsg/rpcsmessage.cpp | 70 +++++++++++++++++++++++++++++++---------
 src/smsg/smessage.cpp    |  7 +++-
 3 files changed, 62 insertions(+), 16 deletions(-)

diff --git a/src/secp256k1/.gitignore b/src/secp256k1/.gitignore
index ccdef02b29..1d90795472 100644
--- a/src/secp256k1/.gitignore
+++ b/src/secp256k1/.gitignore
@@ -36,6 +36,7 @@ libtool
 src/libsecp256k1-config.h
 src/libsecp256k1-config.h.in
 src/ecmult_static_context.h
+build-aux/ar-lib
 build-aux/config.guess
 build-aux/config.sub
 build-aux/depcomp
diff --git a/src/smsg/rpcsmessage.cpp b/src/smsg/rpcsmessage.cpp
index 22618a2950..d5e887777c 100644
--- a/src/smsg/rpcsmessage.cpp
+++ b/src/smsg/rpcsmessage.cpp
@@ -1239,15 +1239,34 @@ static UniValue smsginbox(const JSONRPCRequest &request)
                 },
                 RPCResult{
                     RPCResult::Type::OBJ, "", "", {
-                        {RPCResult::Type::STR_HEX, "msgid", "Message id"},
-                        {RPCResult::Type::STR, "version", "The message version"},
-                        {RPCResult::Type::STR, "received", "Time the message was received"},
-                        {RPCResult::Type::STR, "sent", "Time the message was sent"},
-                        {RPCResult::Type::NUM, "daysretention", "DEPRECATED Number of days message will stay in the network for"},
-                        {RPCResult::Type::NUM, "ttl", "Seconds message will stay in the network for"},
-                        {RPCResult::Type::STR, "from", "Address the message was sent from"},
-                        {RPCResult::Type::STR, "to", "Address the message was sent to"},
-                        {RPCResult::Type::STR, "text", "Message text"},
+                        {RPCResult::Type::STR, "result", "No of messages or error"},
+                        {RPCResult::Type::ARR, "messages", /*optional=*/true, "", {
+                            {RPCResult::Type::OBJ, "", "", {
+                                {RPCResult::Type::STR_HEX, "msgid", "Message id"},
+                                {RPCResult::Type::STR, "version", "The message version"},
+                                {RPCResult::Type::NUM_TIME, "received", /*optional=*/true, "Time the message was received"},
+                                {RPCResult::Type::STR, "received_local", /*optional=*/true, "Time the message was received"},
+                                {RPCResult::Type::STR, "received_utc", /*optional=*/true, "Time the message was received"},
+                                {RPCResult::Type::NUM_TIME, "sent", /*optional=*/true, "Time the message was sent"},
+                                {RPCResult::Type::STR, "sent_local", /*optional=*/true, "Time the message was sent"},
+                                {RPCResult::Type::STR, "sent_utc", /*optional=*/true, "Time the message was sent"},
+                                {RPCResult::Type::NUM, "daysretention", /*optional=*/true, "DEPRECATED Number of days message will stay in the network for"},
+                                {RPCResult::Type::NUM, "ttl", /*optional=*/true, "Seconds message will stay in the network for"},
+                                {RPCResult::Type::NUM_TIME, "expiration", /*optional=*/true, "Time Expired"},
+                                {RPCResult::Type::STR, "expiration_local", /*optional=*/true, "Time Expired"},
+                                {RPCResult::Type::STR, "expiration_utc", /*optional=*/true, "Time Expired"},
+                                {RPCResult::Type::NUM, "payloadsize", /*optional=*/true, "Size in bytes of payload"},
+                                {RPCResult::Type::BOOL, "paid", /*optional=*/true, "True if paid message"},
+                                {RPCResult::Type::STR, "from", /*optional=*/true, "Address the message was sent from"},
+                                {RPCResult::Type::STR, "to", /*optional=*/true, "Address the message was sent to"},
+                                {RPCResult::Type::STR, "text", /*optional=*/true, "Message text"},
+                                {RPCResult::Type::STR, "hex", /*optional=*/true, "Message text"},
+                                {RPCResult::Type::STR, "unknown_encoding", /*optional=*/true, "Message text"},
+                                {RPCResult::Type::STR, "status", /*optional=*/true, "Message status"},
+                                {RPCResult::Type::STR, "error", /*optional=*/true, "Message error"},
+                            }},
+                        }},
+                        {RPCResult::Type::STR, "expected", /*optional=*/true, "values understood"},
                 }},
                 RPCExamples{
                     "Display unread received messages:"
@@ -1415,12 +1434,31 @@ static UniValue smsgoutbox(const JSONRPCRequest &request)
                 },
                 RPCResult{
                     RPCResult::Type::OBJ, "", "", {
-                        {RPCResult::Type::STR_HEX, "msgid", "Message id"},
-                        {RPCResult::Type::STR, "version", "The message version"},
-                        {RPCResult::Type::STR, "sent", "Time the message was sent"},
-                        {RPCResult::Type::STR, "from", "Address the message was sent from"},
-                        {RPCResult::Type::STR, "to", "Address the message was sent to"},
-                        {RPCResult::Type::STR, "text", "Message text"},
+                        {RPCResult::Type::STR, "result", "No of messages or error"},
+                        {RPCResult::Type::ARR, "messages", /*optional=*/true, "", {
+                            {RPCResult::Type::OBJ, "", "", {
+                                {RPCResult::Type::STR_HEX, "msgid", "Message id"},
+                                {RPCResult::Type::STR, "version", "The message version"},
+                                {RPCResult::Type::NUM_TIME, "sent", /*optional=*/true, "Time the message was sent"},
+                                {RPCResult::Type::STR, "sent_local", /*optional=*/true, "Time the message was sent"},
+                                {RPCResult::Type::STR, "sent_utc", /*optional=*/true, "Time the message was sent"},
+                                {RPCResult::Type::NUM, "daysretention", /*optional=*/true, "DEPRECATED Number of days message will stay in the network for"},
+                                {RPCResult::Type::NUM, "ttl", /*optional=*/true, "Seconds message will stay in the network for"},
+                                {RPCResult::Type::NUM_TIME, "expiration", /*optional=*/true, "Time Expired"},
+                                {RPCResult::Type::STR, "expiration_local", /*optional=*/true, "Time Expired"},
+                                {RPCResult::Type::STR, "expiration_utc", /*optional=*/true, "Time Expired"},
+                                {RPCResult::Type::NUM, "payloadsize", /*optional=*/true, "Size in bytes of payload"},
+                                {RPCResult::Type::BOOL, "paid", /*optional=*/true, "True if paid message"},
+                                {RPCResult::Type::STR, "from", /*optional=*/true, "Address the message was sent from"},
+                                {RPCResult::Type::STR, "to", /*optional=*/true, "Address the message was sent to"},
+                                {RPCResult::Type::STR, "text", /*optional=*/true, "Message text"},
+                                {RPCResult::Type::STR, "hex", /*optional=*/true, "Message text"},
+                                {RPCResult::Type::STR, "unknown_encoding", /*optional=*/true, "Message text"},
+                                {RPCResult::Type::STR, "status", /*optional=*/true, "Message status"},
+                                {RPCResult::Type::STR, "error", /*optional=*/true, "Message error"},
+                            }},
+                        }},
+                        {RPCResult::Type::STR, "expected", /*optional=*/true, "values understood"},
                 }},
                 RPCExamples{
                     HelpExampleCli("smsgoutbox", "")
@@ -1991,6 +2029,8 @@ static UniValue smsgone(const JSONRPCRequest &request)
                         {RPCResult::Type::NUM, "daysretention", "DEPRECATED Number of days message will stay in the network for"},
                         {RPCResult::Type::NUM, "ttl", "Seconds message will stay in the network for"},
                         {RPCResult::Type::NUM_TIME, "expiration", "Time the message will be dropped from the network"},
+                        {RPCResult::Type::STR, "expiration_local", /*optional=*/true, "Time Expired"},
+                        {RPCResult::Type::STR, "expiration_utc", /*optional=*/true, "Time Expired"},
                         {RPCResult::Type::NUM, "payloadsize", "Size of user message"},
                         {RPCResult::Type::STR, "from", "Address the message was sent from"},
                 }},
diff --git a/src/smsg/smessage.cpp b/src/smsg/smessage.cpp
index 8d56d5fc30..3cc80a568d 100644
--- a/src/smsg/smessage.cpp
+++ b/src/smsg/smessage.cpp
@@ -3142,6 +3142,9 @@ int CSMSG::Receive(PeerManager *peerLogic, CNode *pfrom, std::vector<uint8_t> &v
             } else
             if (rv == SMSG_FUND_FAILED) { // Bad funding tx
                 peerLogic->Misbehaving(pfrom->GetId(), 10, "smsg-fundtx");
+            } else
+            if (rv == SMSG_FUND_DATA_NOT_FOUND) { // Missing funding tx
+                peerLogic->Misbehaving(pfrom->GetId(), 1, "smsg-fundtx-missing");
             } else {
                 peerLogic->Misbehaving(pfrom->GetId(), 1, "smsg-format");
             }
@@ -3645,7 +3648,9 @@ int CSMSG::PruneFundingTxData()
         }
         delete it;
     }
-    LogPrint(BCLog::SMSG, "%s Removed: %d\n", __func__, num_removed);
+    if (num_removed > 0) {
+        LogPrintf("%s Removed: %d, min_height_to_keep: %d\n", __func__, num_removed, min_height_to_keep);
+    }
 
     return 0;
 };

From 0eb75a14e0e21baaa4500c6948c0332322a1d15d Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Fri, 15 Apr 2022 00:03:30 +0200
Subject: [PATCH 28/57] net: Restore automatic banning.

---
 configure.ac                 |  2 +-
 doc/release-notes-particl.md |  1 +
 src/net_processing.cpp       | 28 +++++++++++++++++++++++-----
 src/secp256k1/configure.ac   |  4 ++++
 4 files changed, 29 insertions(+), 6 deletions(-)

diff --git a/configure.ac b/configure.ac
index 47cb70803f..2033e100d0 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3,7 +3,7 @@ define(_CLIENT_VERSION_MAJOR, 0)
 define(_CLIENT_VERSION_MINOR, 21)
 define(_CLIENT_VERSION_REVISION, 2)
 define(_CLIENT_VERSION_PARTICL, 8)
-define(_CLIENT_VERSION_BUILD, 0)
+define(_CLIENT_VERSION_BUILD, 1)
 define(_CLIENT_VERSION_RC, 0)
 define(_CLIENT_VERSION_IS_RELEASE, true)
 define(_COPYRIGHT_YEAR_BTC, 2021)
diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index b04328b9ce..767d7aad8c 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -6,6 +6,7 @@
 - rpc: Fix bug in filtertransactions hiding txns with watchonly inputs and spendable outputs.
 - qt: Fix missing anon outputs in coincontrol.
 - New checkpoints.
+- net: Restore automatic banning.  Ban peer if misbehaviour score is 2x limit.
 
 
 0.21.2.7
diff --git a/src/net_processing.cpp b/src/net_processing.cpp
index af84f24025..e214e25ab8 100644
--- a/src/net_processing.cpp
+++ b/src/net_processing.cpp
@@ -487,6 +487,7 @@ struct Peer {
     int m_misbehavior_score GUARDED_BY(m_misbehavior_mutex){0};
     /** Whether this peer should be disconnected and marked as discouraged (unless it has the noban permission). */
     bool m_should_discourage GUARDED_BY(m_misbehavior_mutex){false};
+    bool m_should_ban GUARDED_BY(m_misbehavior_mutex){false};
 
     /** Set of txids to reconsider once their parent transactions have been accepted **/
     std::set<uint256> m_orphan_work_set GUARDED_BY(g_cs_orphans);
@@ -1126,6 +1127,11 @@ void PeerManager::Misbehaving(const NodeId pnode, const int howmuch, const std::
     LOCK(peer->m_misbehavior_mutex);
     peer->m_misbehavior_score += howmuch;
     std::string message_prefixed = message.empty() ? "" : (": " + message);
+
+    if (peer->m_misbehavior_score >= m_banscore * 2 && !peer->m_should_ban) {
+        LogPrint(BCLog::NET, "Misbehaving: peer=%d (%d -> %d) BAN THRESHOLD EXCEEDED%s\n", pnode, peer->m_misbehavior_score - howmuch, peer->m_misbehavior_score, message_prefixed);
+        peer->m_should_ban = true;
+    } else
     if (peer->m_misbehavior_score >= m_banscore && peer->m_misbehavior_score - howmuch < m_banscore) {
         LogPrint(BCLog::NET, "Misbehaving: peer=%d (%d -> %d) DISCOURAGE THRESHOLD EXCEEDED%s\n", pnode, peer->m_misbehavior_score - howmuch, peer->m_misbehavior_score, message_prefixed);
         peer->m_should_discourage = true;
@@ -1353,9 +1359,13 @@ void PassOnMisbehaviour(CNodeState *state, NodeId node_id, int howmuch)
     if (peer == nullptr) return;
     LOCK(peer->m_misbehavior_mutex);
     peer->m_misbehavior_score = howmuch;
-    if (peer->m_misbehavior_score >= gArgs.GetArg("-banscore", DISCOURAGEMENT_THRESHOLD)) {
+    int banscore = gArgs.GetArg("-banscore", DISCOURAGEMENT_THRESHOLD);
+    if (peer->m_misbehavior_score >= banscore) {
         peer->m_should_discourage = true;
     }
+    if (peer->m_misbehavior_score >= banscore * 2) {
+        peer->m_should_ban = true;
+    }
     LogPrint(BCLog::NET, "peer=%d Inherited misbehavior (%d)\n", node_id, peer->m_misbehavior_score);
 }
 
@@ -4199,13 +4209,16 @@ bool PeerManager::MaybeDiscourageAndDisconnect(CNode& pnode)
     PeerRef peer = GetPeerRef(peer_id);
     if (peer == nullptr) return false;
 
+    bool banning{false};
     {
         LOCK(peer->m_misbehavior_mutex);
 
         // There's nothing to do if the m_should_discourage flag isn't set
-        if (!peer->m_should_discourage) return false;
+        if (!peer->m_should_discourage && !peer->m_should_ban) return false;
 
+        banning = peer->m_should_ban;
         peer->m_should_discourage = false;
+        peer->m_should_ban = false;
     } // peer.m_misbehavior_mutex
 
     if (pnode.HasPermission(PF_NOBAN)) {
@@ -4228,9 +4241,14 @@ bool PeerManager::MaybeDiscourageAndDisconnect(CNode& pnode)
         return true;
     }
 
-    // Normal case: Disconnect the peer and discourage all nodes sharing the address
-    LogPrintf("Disconnecting and discouraging peer %d!\n", peer_id);
-    if (m_banman) m_banman->Discourage(pnode.addr);
+    if (m_banman && banning) {
+        LogPrintf("Disconnecting and banning peer %d!\n", peer_id);
+        m_banman->Ban(pnode.addr);
+    } else {
+        // Normal case: Disconnect the peer and discourage all nodes sharing the address
+        LogPrintf("Disconnecting and discouraging peer %d!\n", peer_id);
+        if (m_banman) m_banman->Discourage(pnode.addr);
+    }
     m_connman.DisconnectNode(pnode.addr);
     return true;
 }
diff --git a/src/secp256k1/configure.ac b/src/secp256k1/configure.ac
index fd3cd2ee4c..f62cf72828 100644
--- a/src/secp256k1/configure.ac
+++ b/src/secp256k1/configure.ac
@@ -627,6 +627,10 @@ echo "  module ecdh             = $enable_module_ecdh"
 echo "  module recovery         = $enable_module_recovery"
 echo "  module extrakeys        = $enable_module_extrakeys"
 echo "  module schnorrsig       = $enable_module_schnorrsig"
+echo "  module generator       = $enable_module_generator"
+echo "  module commitment       = $enable_module_commitment"
+echo "  module rangeproof       = $enable_module_rangeproof"
+echo "  module bulletproof       = $enable_module_bulletproof"
 echo
 echo "  asm                     = $set_asm"
 echo "  bignum                  = $set_bignum"

From f4dd1c0870a10257c4a997267aaf1d0793e7fa39 Mon Sep 17 00:00:00 2001
From: practicalswift <practicalswift@users.noreply.github.com>
Date: Thu, 15 Apr 2021 06:23:43 +0000
Subject: [PATCH 29/57] test: Remove intermittently failing and not very
 meaningful `BOOST_CHECK` in `cnetaddr_basic`

---
 src/test/net_tests.cpp | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/src/test/net_tests.cpp b/src/test/net_tests.cpp
index 37eca8b7ef..0c5e4c65ff 100644
--- a/src/test/net_tests.cpp
+++ b/src/test/net_tests.cpp
@@ -299,9 +299,6 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)
     BOOST_REQUIRE(addr.IsValid());
     BOOST_REQUIRE(addr.IsIPv6());
     BOOST_CHECK(!addr.IsBindAny());
-    const std::string addr_str{addr.ToString()};
-    BOOST_CHECK(addr_str == scoped_addr || addr_str == "fe80:0:0:0:0:0:0:1");
-    // The fallback case "fe80:0:0:0:0:0:0:1" is needed for macOS 10.14/10.15 and (probably) later.
     // Test that the delimiter "%" and default zone id of 0 can be omitted for the default scope.
     BOOST_REQUIRE(LookupHost(link_local + "%0", addr, false));
     BOOST_REQUIRE(addr.IsValid());

From 90566eea60e69f7daeadbaaf81159c210f24c4c9 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Fri, 15 Apr 2022 11:49:48 +0200
Subject: [PATCH 30/57] net: Add -automaticbans options

---
 src/consensus/validation.h |  2 ++
 src/init.cpp               |  1 +
 src/net_processing.cpp     | 18 ++++++++++++++++--
 src/net_processing.h       |  2 ++
 src/validation.cpp         |  2 +-
 src/validation.h           |  5 +++++
 6 files changed, 27 insertions(+), 3 deletions(-)

diff --git a/src/consensus/validation.h b/src/consensus/validation.h
index 20b246f729..566d6cafff 100644
--- a/src/consensus/validation.h
+++ b/src/consensus/validation.h
@@ -170,6 +170,7 @@ class ValidationState
     bool m_exploit_fix_2 = false;
     bool m_in_block = false;
     bool m_check_equal_rct_txid = true;
+    bool m_punish_for_duplicates = false;
     CAmount tx_balances[6] = {0};
     std::set<CCmpPubKey> m_setHaveKI;
 
@@ -212,6 +213,7 @@ class ValidationState
         m_exploit_fix_1 = state_from.m_exploit_fix_1;
         m_exploit_fix_2 = state_from.m_exploit_fix_2;
         m_check_equal_rct_txid = state_from.m_check_equal_rct_txid;
+        m_punish_for_duplicates = state_from.m_punish_for_duplicates;
     }
 };
 
diff --git a/src/init.cpp b/src/init.cpp
index feff6de865..19903abf84 100644
--- a/src/init.cpp
+++ b/src/init.cpp
@@ -559,6 +559,7 @@ void SetupServerArgs(NodeContext& node)
     argsman.AddArg("-findpeers", "Node will search for peers (default: 1)", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
 
     argsman.AddArg("-lookuptorcontrolhost=<protocol>", strprintf("Allow a hostname to be specified for the -torcontrol option. Must be \"any\", \"ipv4\", or \"ipv6\" (default: %s)", ""), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
+    argsman.AddArg("-automaticbans", strprintf("Whether to automatically ban misbehaving nodes. (default: %u)", particl::DEFAULT_AUTOMATIC_BANS), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     // end Particl specific
 
     argsman.AddArg("-addnode=<ip>", "Add a node to connect to and attempt to keep the connection open (see the `addnode` RPC command help for more info). This option can be specified multiple times to add multiple nodes.", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);
diff --git a/src/net_processing.cpp b/src/net_processing.cpp
index e214e25ab8..48f06f81f8 100644
--- a/src/net_processing.cpp
+++ b/src/net_processing.cpp
@@ -1302,6 +1302,7 @@ bool PeerManager::MaybePunishNodeForBlock(NodeId nodeid, const BlockValidationSt
     return false;
 }
 
+
 NodeId GetBlockSource(uint256 hash)
 {
     const auto it = mapBlockSource.find(hash);
@@ -1311,6 +1312,16 @@ NodeId GetBlockSource(uint256 hash)
     return it->second.first;
 }
 
+bool PeerManager::MaybePunishNodeForDuplicates(NodeId nodeid, const BlockValidationState& state)
+{
+    if (state.m_punish_for_duplicates) {
+        Misbehaving(nodeid, 5, "Too many duplicates");
+        return true;
+    }
+    return false;
+};
+
+
 size_t MAX_LOOSE_HEADERS = 1000;
 int MAX_DUPLICATE_HEADERS = 2000;
 int64_t MAX_LOOSE_HEADER_TIME = 120;
@@ -1451,7 +1462,6 @@ bool IncDuplicateHeaders(NodeId node_id) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
         if (peer_misbehavior_score < it->second.m_misbehavior) {
             PassOnMisbehaviour(state, node_id, it->second.m_misbehavior);
         }
-        WITH_LOCK(peer->m_misbehavior_mutex, peer->m_misbehavior_score += 5);
         return false;
     }
     map_dos_state[state->address].m_duplicate_count = 1;
@@ -1718,6 +1728,7 @@ void PeerManager::BlockChecked(const CBlock& block, const BlockValidationState&
     const uint256 hash(block.GetHash());
     std::map<uint256, std::pair<NodeId, bool>>::iterator it = mapBlockSource.find(hash);
 
+    MaybePunishNodeForDuplicates(/*nodeid=*/ it->second.first, state);
     // If the block failed validation, we know where it came from and we're still connected
     // to that peer, maybe punish.
     if (state.IsInvalid() &&
@@ -2209,6 +2220,7 @@ void PeerManager::ProcessHeadersMessage(CNode& pfrom, const std::vector<CBlockHe
             return;
         }
     }
+    MaybePunishNodeForDuplicates(state.nodeId, state);
 
     {
         LOCK(cs_main);
@@ -3609,6 +3621,7 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat
                 return;
             }
         }
+        MaybePunishNodeForDuplicates(state.nodeId, state);
 
         // When we succeed in decoding a block's txids from a cmpctblock
         // message we typically jump to the BLOCKTXN handling code, with a
@@ -4241,7 +4254,8 @@ bool PeerManager::MaybeDiscourageAndDisconnect(CNode& pnode)
         return true;
     }
 
-    if (m_banman && banning) {
+    if (m_banman && banning &&
+        gArgs.GetBoolArg("-automaticbans", particl::DEFAULT_AUTOMATIC_BANS)) {
         LogPrintf("Disconnecting and banning peer %d!\n", peer_id);
         m_banman->Ban(pnode.addr);
     } else {
diff --git a/src/net_processing.h b/src/net_processing.h
index 50338fdac5..89ceae36ae 100644
--- a/src/net_processing.h
+++ b/src/net_processing.h
@@ -109,6 +109,8 @@ class PeerManager final : public CValidationInterface, public NetEventsInterface
     bool MaybePunishNodeForBlock(NodeId nodeid, const BlockValidationState& state,
                                  bool via_compact_block, const std::string& message = "");
 
+    bool MaybePunishNodeForDuplicates(NodeId nodeid, const BlockValidationState& state);
+
     /**
      * Potentially disconnect and discourage a node based on the contents of a TxValidationState object
      *
diff --git a/src/validation.cpp b/src/validation.cpp
index aeda2d4488..c1ad701b20 100644
--- a/src/validation.cpp
+++ b/src/validation.cpp
@@ -5253,7 +5253,7 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS
             // Block header is already known.
             if (fParticlMode && !fRequested && !::ChainstateActive().IsInitialBlockDownload() && state.nodeId >= 0
                 && !IncDuplicateHeaders(state.nodeId)) {
-                Misbehaving(state.nodeId, 5, "Too many duplicates");
+                state.m_punish_for_duplicates = true;
             }
 
             pindex = miSelf->second;
diff --git a/src/validation.h b/src/validation.h
index e1fbf44648..e3d8bb12ed 100644
--- a/src/validation.h
+++ b/src/validation.h
@@ -194,6 +194,11 @@ bool RebuildRollingIndices(CTxMemPool* mempool);
 void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman);
 /** Run an instance of the script checking thread */
 void ThreadScriptCheck(int worker_num);
+
+namespace particl {
+static constexpr bool DEFAULT_AUTOMATIC_BANS = true;
+}
+
 /** Return the median number of blocks that other nodes claim to have */
 int GetNumBlocksOfPeers();
 /** Set the median number of blocks that other nodes claim to have - debug only */

From a16123ddb284e8abdff98101d6bfdee32d0168e3 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Fri, 15 Apr 2022 22:44:34 +0200
Subject: [PATCH 31/57] net: Simplify persistent misbehaviour counter.

---
 src/net.cpp            |  2 +-
 src/net_processing.cpp | 51 +++++++++++++++++++++++++++++++++---------
 src/net_processing.h   |  1 +
 src/validation.cpp     |  1 -
 4 files changed, 43 insertions(+), 12 deletions(-)

diff --git a/src/net.cpp b/src/net.cpp
index 772519f9a8..30a910fada 100644
--- a/src/net.cpp
+++ b/src/net.cpp
@@ -2263,7 +2263,7 @@ void CConnman::ThreadMessageHandler()
         int64_t nTimeNow = GetTime();
         if (nTimeNextBanReduced < nTimeNow) {
             LOCK(cs_main);
-            CheckUnreceivedHeaders(nTimeNow);
+            CheckUnreceivedHeaders(nTimeNow); // Also reduces persistent misbehaviour score
             for (auto *pnode : vNodesCopy) {
                 DecMisbehaving(pnode->id, 1);
 
diff --git a/src/net_processing.cpp b/src/net_processing.cpp
index 48f06f81f8..7cd77cc349 100644
--- a/src/net_processing.cpp
+++ b/src/net_processing.cpp
@@ -452,6 +452,9 @@ class CNodeDOS
 
     //! Persistent misbehaving counter
     int m_misbehavior = 0;
+
+    //! Times node was discouraged
+    int m_discouraged_count = 0;
 };
 
 /** Map maintaining per-addr DOS state. */
@@ -1123,6 +1126,10 @@ void PeerManager::Misbehaving(const NodeId pnode, const int howmuch, const std::
 
     PeerRef peer = GetPeerRef(pnode);
     if (peer == nullptr) return;
+    if (fParticlMode) {
+        LOCK(cs_main);
+        IncPersistentMisbehaviour(pnode, howmuch);
+    }
 
     LOCK(peer->m_misbehavior_mutex);
     peer->m_misbehavior_score += howmuch;
@@ -1315,7 +1322,7 @@ NodeId GetBlockSource(uint256 hash)
 bool PeerManager::MaybePunishNodeForDuplicates(NodeId nodeid, const BlockValidationState& state)
 {
     if (state.m_punish_for_duplicates) {
-        Misbehaving(nodeid, 5, "Too many duplicates");
+        Misbehaving(nodeid, 10, "Too many duplicates");
         return true;
     }
     return false;
@@ -1390,11 +1397,6 @@ void MisbehavingByAddr(CNetAddr addr, int misbehavior_cfwd, int howmuch, const s
         if (addr == (CNetAddr)it->second.address) {
             PeerRef peer = GetPeerRef(it->first);
             if (peer == nullptr) continue;
-
-            int misbehavior_score = WITH_LOCK(peer->m_misbehavior_mutex, return peer->m_misbehavior_score);
-            if (misbehavior_score < misbehavior_cfwd) {
-                PassOnMisbehaviour(&it->second, it->first, misbehavior_cfwd);
-            }
             Misbehaving(it->first, howmuch, message);
         }
     }
@@ -1458,10 +1460,6 @@ bool IncDuplicateHeaders(NodeId node_id) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
         if (it->second.m_duplicate_count < MAX_DUPLICATE_HEADERS) {
             return true;
         }
-        int peer_misbehavior_score = WITH_LOCK(peer->m_misbehavior_mutex, return peer->m_misbehavior_score);
-        if (peer_misbehavior_score < it->second.m_misbehavior) {
-            PassOnMisbehaviour(state, node_id, it->second.m_misbehavior);
-        }
         return false;
     }
     map_dos_state[state->address].m_duplicate_count = 1;
@@ -1490,6 +1488,32 @@ void IncPersistentMisbehaviour(NodeId node_id, int howmuch)
     return;
 }
 
+bool IncPersistentDiscouraged(NodeId node_id)
+{
+    CNodeState *state = State(node_id);
+    if (state == nullptr) {
+        return false;
+    }
+    const CService &node_address = state->address;
+
+    PeerRef peer = GetPeerRef(node_id);
+    if (peer == nullptr) return false;
+    auto it = map_dos_state.find(node_address);
+    if (it != map_dos_state.end()) {
+        it->second.m_discouraged_count += 1;
+        if (it->second.m_discouraged_count > 5) {
+            WITH_LOCK(peer->m_misbehavior_mutex, peer->m_should_ban = true);
+            LogPrintf("Too often discouraged. Banning peer %d!\n", node_id);
+            it->second.m_discouraged_count = 0;
+            return true;
+        }
+        LogPrint(BCLog::NET, "peer=%d discouraged count (%d)\n", node_id, it->second.m_discouraged_count);
+        return false;
+    }
+    map_dos_state[node_address].m_discouraged_count = 1;
+    return false;
+}
+
 int GetNumDOSStates()
 {
     return map_dos_state.size();
@@ -4234,6 +4258,13 @@ bool PeerManager::MaybeDiscourageAndDisconnect(CNode& pnode)
         peer->m_should_ban = false;
     } // peer.m_misbehavior_mutex
 
+    if (fParticlMode && !banning) {
+        LOCK(cs_main);
+        if (IncPersistentDiscouraged(peer->m_id)) {
+            banning = true;
+        }
+    }
+
     if (pnode.HasPermission(PF_NOBAN)) {
         // We never disconnect or discourage peers for bad behavior if they have the NOBAN permission flag
         LogPrintf("Warning: not punishing noban peer %d!\n", peer_id);
diff --git a/src/net_processing.h b/src/net_processing.h
index 89ceae36ae..e57389f171 100644
--- a/src/net_processing.h
+++ b/src/net_processing.h
@@ -169,6 +169,7 @@ void DecMisbehaving(NodeId nodeid, int howmuch);
 NodeId GetBlockSource(uint256 hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
 
 void IncPersistentMisbehaviour(NodeId node_id, int howmuch) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
+bool IncPersistentDiscouraged(NodeId node_id) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
 int GetNumDOSStates() EXCLUSIVE_LOCKS_REQUIRED(cs_main);
 void ClearDOSStates() EXCLUSIVE_LOCKS_REQUIRED(cs_main);
 
diff --git a/src/validation.cpp b/src/validation.cpp
index c1ad701b20..dc2932a4b5 100644
--- a/src/validation.cpp
+++ b/src/validation.cpp
@@ -5480,7 +5480,6 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, Block
 
     if (state.nFlags & BLOCK_STAKE_KERNEL_SPENT && !(state.nFlags & BLOCK_FAILED_DUPLICATE_STAKE)) {
         if (state.nodeId > -1) {
-            IncPersistentMisbehaviour(state.nodeId, 20);
             Misbehaving(state.nodeId, 20, "Spent kernel");
         }
     }

From 1dfd74564303163392901881ae762558036c352d Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Mon, 18 Apr 2022 15:34:38 +0200
Subject: [PATCH 32/57] secp256k1: Pop scratch space when failing early.

---
 src/secp256k1/.gitignore                                 | 3 +++
 src/secp256k1/src/modules/bulletproofs/rangeproof_impl.h | 2 ++
 2 files changed, 5 insertions(+)

diff --git a/src/secp256k1/.gitignore b/src/secp256k1/.gitignore
index 1d90795472..da86eda210 100644
--- a/src/secp256k1/.gitignore
+++ b/src/secp256k1/.gitignore
@@ -6,6 +6,9 @@ bench_sign
 bench_verify
 bench_recover
 bench_internal
+bench_bulletproof
+bench_generator
+bench_rangeproof
 tests
 exhaustive_tests
 gen_context
diff --git a/src/secp256k1/src/modules/bulletproofs/rangeproof_impl.h b/src/secp256k1/src/modules/bulletproofs/rangeproof_impl.h
index 3525fa38be..2b8d405214 100644
--- a/src/secp256k1/src/modules/bulletproofs/rangeproof_impl.h
+++ b/src/secp256k1/src/modules/bulletproofs/rangeproof_impl.h
@@ -242,6 +242,7 @@ static int secp256k1_bulletproof_rangeproof_verify_impl(const secp256k1_ecmult_c
         /* Compute y, z, x */
         if (!secp256k1_bulletproof_deserialize_point(&age, &proof[i][64], 0, 4) ||
             !secp256k1_bulletproof_deserialize_point(&sge, &proof[i][64], 1, 4)) {
+            secp256k1_scratch_apply_checkpoint(&bp_error_callback, scratch, scratch_checkpoint);
             return 0;
         }
 
@@ -260,6 +261,7 @@ static int secp256k1_bulletproof_rangeproof_verify_impl(const secp256k1_ecmult_c
 
         if (!secp256k1_bulletproof_deserialize_point(&ecmult_data[i].t1, &proof[i][64], 2, 4) ||
             !secp256k1_bulletproof_deserialize_point(&ecmult_data[i].t2, &proof[i][64], 3, 4)) {
+            secp256k1_scratch_apply_checkpoint(&bp_error_callback, scratch, scratch_checkpoint);
             return 0;
         }
 

From ddcd929433cc1c3f57e0b129b43f881734c756b9 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Mon, 18 Apr 2022 18:32:50 +0200
Subject: [PATCH 33/57] tests: Fix intermittent failure

---
 test/functional/p2p_part_disable_types.py | 14 +++++++++++++-
 1 file changed, 13 insertions(+), 1 deletion(-)

diff --git a/test/functional/p2p_part_disable_types.py b/test/functional/p2p_part_disable_types.py
index dc6032356d..471700e5a4 100755
--- a/test/functional/p2p_part_disable_types.py
+++ b/test/functional/p2p_part_disable_types.py
@@ -36,8 +36,9 @@ def run_test(self):
         txids.append(nodes[1].sendtypeto('part', 'part', [{'address': sx0, 'amount': 10},]))
         txids.append(nodes[1].sendtypeto('part', 'blind', [{'address': sx0, 'amount': 12},]))
         txids.append(nodes[1].sendtypeto('part', 'blind', [{'address': sx1, 'amount': 13},]))
-        txids.append(nodes[1].sendtypeto('part', 'anon', [{'address': sx0, 'amount': 14},]))
+        txids.append(nodes[1].sendtypeto('part', 'blind', [{'address': sx0, 'amount': 14},]))
         txids.append(nodes[1].sendtypeto('part', 'anon', [{'address': sx0, 'amount': 15},]))
+        txids.append(nodes[1].sendtypeto('part', 'anon', [{'address': sx0, 'amount': 16},]))
         for i in range(20):
             txids.append(nodes[1].sendtypeto('part', 'anon', [{'address': sx1, 'amount': 1},]))
 
@@ -98,14 +99,25 @@ def run_test(self):
         except Exception:
             pass
 
+        def lock_outputs(txid):
+            rtx = nodes[0].getrawtransaction(txid, True)
+            for utxo in rtx['vout']:
+                if 'type' in utxo and utxo['type'] in ('anon', 'data'):
+                    continue
+                nodes[0].lockunspent(False, [{'txid': rtx['txid'], 'vout': utxo['n']}])
+
         txids = []
         txids.append(nodes[0].sendtypeto('anon', 'anon', [{'address': sx1, 'amount': 1},], '', '', 5))
         txids.append(nodes[0].sendtypeto('part', 'anon', [{'address': sx1, 'amount': 1},]))
         txids.append(nodes[0].sendtypeto('anon', 'part', [{'address': sx1, 'amount': 1},], '', '', 5))
+        lock_outputs(txids[-1])
         txids.append(nodes[0].sendtypeto('part', 'blind', [{'address': sx1, 'amount': 1},]))
+        lock_outputs(txids[-1])
         txids.append(nodes[0].sendtypeto('blind', 'part', [{'address': sx1, 'amount': 1},]))
+        lock_outputs(txids[-1])
         txids.append(nodes[0].sendtypeto('blind', 'anon', [{'address': sx1, 'amount': 1},]))
         txids.append(nodes[0].sendtypeto('anon', 'blind', [{'address': sx1, 'amount': 1},], '', '', 5))
+        lock_outputs(txids[-1])
 
         for txid in txids:
             rtx = nodes[0].getrawtransaction(txid)

From 6e9c522749235f7c92fdee0bf23c40cf2972e20d Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Thu, 21 Apr 2022 22:23:10 +0200
Subject: [PATCH 34/57] smsg db compaction and smsgin/outbox pagination.

---
 doc/release-notes-particl.md         |  7 ++
 src/smsg/db.cpp                      |  5 ++
 src/smsg/db.h                        |  5 ++
 src/smsg/rpcsmessage.cpp             | 97 +++++++++++++++++++++++-----
 src/smsg/smessage.cpp                |  3 +
 test/functional/feature_part_smsg.py | 30 ++++++++-
 6 files changed, 129 insertions(+), 18 deletions(-)

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index 767d7aad8c..fe8200ed65 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -1,4 +1,11 @@
 
+0.21.2.9
+==============
+
+- smsg: The smsgdb is periodically compacted.
+- smsg: Added pagination to smsginbox and smsgoutbox
+
+
 0.21.2.8
 ==============
 
diff --git a/src/smsg/db.cpp b/src/smsg/db.cpp
index b5646b6fc0..e6c8f5db61 100644
--- a/src/smsg/db.cpp
+++ b/src/smsg/db.cpp
@@ -853,6 +853,11 @@ bool SecMsgDB::EraseBestBlock()
     return error("SecMsgDB erase failed: %s\n", s.ToString());
 };
 
+void SecMsgDB::Compact() const
+{
+    pdb->CompactRange(nullptr, nullptr);
+}
+
 bool PutBestBlock(leveldb::WriteBatch *batch, const uint256 &block_hash, int height)
 {
     CDataStream ssKey(SER_DISK, CLIENT_VERSION);
diff --git a/src/smsg/db.h b/src/smsg/db.h
index c4342d01ae..964fbeb226 100644
--- a/src/smsg/db.h
+++ b/src/smsg/db.h
@@ -88,6 +88,11 @@ class SecMsgDB
     bool ReadBestBlock(uint256 &hash, int &height);
     bool EraseBestBlock();
 
+    /**
+     * Compact a certain range of keys in the database.
+     */
+    void Compact() const;
+
     leveldb::DB *pdb; // points to the global instance
     leveldb::WriteBatch *activeBatch;
 };
diff --git a/src/smsg/rpcsmessage.cpp b/src/smsg/rpcsmessage.cpp
index d5e887777c..57c13cede9 100644
--- a/src/smsg/rpcsmessage.cpp
+++ b/src/smsg/rpcsmessage.cpp
@@ -1,5 +1,5 @@
 // Copyright (c) 2014-2016 The ShadowCoin developers
-// Copyright (c) 2017-2020 The Particl Core developers
+// Copyright (c) 2017-2022 The Particl Core developers
 // Distributed under the MIT/X11 software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
@@ -1228,12 +1228,15 @@ static UniValue smsginbox(const JSONRPCRequest &request)
                 "\nDecrypt and display received messages.\n"
                 "Warning: clear will delete all messages.\n",
                 {
-                    {"mode", RPCArg::Type::STR, /* default */ "unread", "\"all|unread|clear\" List all messages, unread messages or clear all messages."},
+                    {"mode", RPCArg::Type::STR, /* default */ "unread", "\"all|unread|count|clear\" List all messages, unread messages, count or delete all messages."},
                     {"filter", RPCArg::Type::STR, /* default */ "", "Filter messages when in list mode. Applied to from, to and text fields."},
                     {"options", RPCArg::Type::OBJ, /* default */ "", "",
                         {
                             {"updatestatus", RPCArg::Type::BOOL, /* default */ "true", "Update read status if true."},
                             {"encoding", RPCArg::Type::STR, /* default */ "text", "Display message data in encoding, values: \"text\", \"hex\", \"none\"."},
+                            {"offset", RPCArg::Type::NUM, /* default */ "", "Skip the first \"offset\" messages"},
+                            {"max_results", RPCArg::Type::NUM, /* default */ "", "Return only \"max_results\" messages"},
+                            {"unread_only", RPCArg::Type::BOOL, /* default */ "false", "Count only unread messages"},
                         },
                         "options"},
                 },
@@ -1267,13 +1270,16 @@ static UniValue smsginbox(const JSONRPCRequest &request)
                             }},
                         }},
                         {RPCResult::Type::STR, "expected", /*optional=*/true, "values understood"},
+                        {RPCResult::Type::NUM, "num_messages", /*optional=*/true, "Number of messages counted"},
                 }},
                 RPCExamples{
                     "Display unread received messages:"
                     + HelpExampleCli("smsginbox", "") +
                     "Display all received messages that match \"address\":"
                     + HelpExampleCli("smsginbox", "\"all\" \"address\"")
-                    + HelpExampleRpc("smsginbox", "")
+                    + HelpExampleRpc("smsginbox", "\"all\", \"address\"") +
+                    "Count unread messages:"
+                    + HelpExampleCli("smsginbox", "\"count\" \"\" \"{\\\"unread_only\\\":true}\"")
                 },
             }.Check(request);
 
@@ -1286,6 +1292,8 @@ static UniValue smsginbox(const JSONRPCRequest &request)
 
     std::string sEnc = "text";
     bool update_status = true;
+    bool unread_only = false;
+    int offset = 0, max_results = -1;
     if (request.params[2].isObject()) {
         UniValue options = request.params[2].get_obj();
         if (options["updatestatus"].isBool()) {
@@ -1294,12 +1302,20 @@ static UniValue smsginbox(const JSONRPCRequest &request)
         if (options["encoding"].isStr()) {
             sEnc = options["encoding"].get_str();
         }
+        if (options["unread_only"].isBool()) {
+            unread_only = options["unread_only"].get_bool();
+        }
+        if (options["offset"].isNum()) {
+            offset = options["offset"].get_int();
+        }
+        if (options["max_results"].isNum()) {
+            max_results = options["max_results"].get_int();
+        }
     }
 
     UniValue result(UniValue::VOBJ);
 
     {
-
         smsg::SecMsgDB dbInbox;
         if (!dbInbox.Open("cr+")) {
             throw JSONRPCError(RPC_INTERNAL_ERROR, "Could not open DB");
@@ -1308,6 +1324,23 @@ static UniValue smsginbox(const JSONRPCRequest &request)
         uint32_t nMessages = 0;
         uint8_t chKey[30];
 
+        if (mode == "count") {
+            LOCK(smsg::cs_smsgDB);
+
+            smsg::SecMsgStored smsgStored;
+            leveldb::Iterator *it = dbInbox.pdb->NewIterator(leveldb::ReadOptions());
+            while (dbInbox.NextSmesg(it, smsg::DBK_INBOX, chKey, smsgStored)) {
+                if (unread_only &&
+                    !(smsgStored.status & SMSG_MASK_UNREAD)) {
+                    continue;
+                }
+                nMessages++;
+            }
+            delete it;
+
+            result.pushKV("result", strprintf("Counted %s messages", unread_only ? "unread" : "all"));
+            result.pushKV("num_messages", (int)nMessages);
+        } else
         if (mode == "clear") {
             LOCK(smsg::cs_smsgDB);
             dbInbox.TxnBegin();
@@ -1335,10 +1368,17 @@ static UniValue smsginbox(const JSONRPCRequest &request)
             UniValue messageList(UniValue::VARR);
 
             while (dbInbox.NextSmesg(it, smsg::DBK_INBOX, chKey, smsgStored)) {
-                if (fCheckReadStatus
-                    && !(smsgStored.status & SMSG_MASK_UNREAD)) {
+                if (fCheckReadStatus &&
+                    !(smsgStored.status & SMSG_MASK_UNREAD)) {
                     continue;
                 }
+                if (offset > 0) {
+                    offset--;
+                    continue;
+                }
+                if (max_results >= 0 && (int)nMessages >= max_results) {
+                    break;
+                }
                 const unsigned char *pHeader = smsgStored.vchMessage.data();
                 smsg::SecureMessage smsg(pHeader);
                 const smsg::SecureMessage *psmsg = &smsg;
@@ -1352,10 +1392,10 @@ static UniValue smsginbox(const JSONRPCRequest &request)
                 if (rv == 0) {
                     std::string sAddrTo = EncodeDestination(PKHash(smsgStored.addrTo));
                     std::string sText = std::string((char*)msg.vchMessage.data());
-                    if (filter.size() > 0
-                        && !(part::stringsMatchI(msg.sFromAddress, filter, 3) ||
-                            part::stringsMatchI(sAddrTo, filter, 3) ||
-                            part::stringsMatchI(sText, filter, 3))) {
+                    if (filter.size() > 0 &&
+                        !(part::stringsMatchI(msg.sFromAddress, filter, 3) ||
+                          part::stringsMatchI(sAddrTo, filter, 3) ||
+                          part::stringsMatchI(sText, filter, 3))) {
                         continue;
                     }
 
@@ -1422,13 +1462,15 @@ static UniValue smsgoutbox(const JSONRPCRequest &request)
                 "\nDecrypt and display all sent messages.\n"
                 "Warning: \"mode\"=\"clear\" will delete all sent messages.\n",
                 {
-                    {"mode", RPCArg::Type::STR, /* default */ "all", "all|clear, List or clear messages."},
+                    {"mode", RPCArg::Type::STR, /* default */ "all", "\"all|count|clear\" List, count or clear messages."},
                     {"filter", RPCArg::Type::STR, /* default */ "", "Filter messages when in list mode. Applied to from, to and text fields."},
                     {"options", RPCArg::Type::OBJ, /* default */ "", "",
                         {
                             {"encoding", RPCArg::Type::STR, /* default */ "text", "Display message data in encoding, values: \"text\", \"hex\", \"none\"."},
                             {"sending", RPCArg::Type::BOOL, /* default */ "false", "Display messages in sending queue."},
                             {"stashed", RPCArg::Type::BOOL, /* default */ "false", "Display stashed messages."},
+                            {"offset", RPCArg::Type::NUM, /* default */ "", "Skip the first \"offset\" messages"},
+                            {"max_results", RPCArg::Type::NUM, /* default */ "", "Return only \"max_results\" messages"},
                         },
                         "options"},
                 },
@@ -1459,6 +1501,7 @@ static UniValue smsgoutbox(const JSONRPCRequest &request)
                             }},
                         }},
                         {RPCResult::Type::STR, "expected", /*optional=*/true, "values understood"},
+                        {RPCResult::Type::NUM, "num_messages", /*optional=*/true, "Number of messages counted"},
                 }},
                 RPCExamples{
                     HelpExampleCli("smsgoutbox", "")
@@ -1476,6 +1519,7 @@ static UniValue smsgoutbox(const JSONRPCRequest &request)
     bool show_sending = false;
     bool show_stashed = false;
     std::string sEnc = "text";
+    int offset = 0, max_results = -1;
     if (request.params[2].isObject()) {
         UniValue options = request.params[2].get_obj();
         if (options["encoding"].isStr()) {
@@ -1487,6 +1531,12 @@ static UniValue smsgoutbox(const JSONRPCRequest &request)
         if (options["stashed"].isBool()) {
             show_stashed = options["stashed"].get_bool();
         }
+        if (options["offset"].isNum()) {
+            offset = options["offset"].get_int();
+        }
+        if (options["max_results"].isNum()) {
+            max_results = options["max_results"].get_int();
+        }
     }
 
     if (show_sending && show_stashed) {
@@ -1509,6 +1559,16 @@ static UniValue smsgoutbox(const JSONRPCRequest &request)
         uint32_t nMessages = 0;
 
         std::string db_prefix = show_sending ? smsg::DBK_QUEUED : show_stashed ? smsg::DBK_STASHED : smsg::DBK_OUTBOX;
+        if (mode == "count") {
+            leveldb::Iterator *it = dbOutbox.pdb->NewIterator(leveldb::ReadOptions());
+            while (dbOutbox.NextSmesgKey(it, db_prefix, chKey)) {
+                nMessages++;
+            }
+            delete it;
+
+            result.pushKV("result", "Counted sent messages");
+            result.pushKV("num_messages", (int)nMessages);
+        } else
         if (mode == "clear") {
             dbOutbox.TxnBegin();
 
@@ -1530,6 +1590,13 @@ static UniValue smsgoutbox(const JSONRPCRequest &request)
             UniValue messageList(UniValue::VARR);
 
             while (dbOutbox.NextSmesg(it, db_prefix, chKey, smsgStored)) {
+                if (offset > 0) {
+                    offset--;
+                    continue;
+                }
+                if (max_results >= 0 && (int)nMessages >= max_results) {
+                    break;
+                }
                 const unsigned char *pHeader = smsgStored.vchMessage.data();
                 smsg::SecureMessage smsg(pHeader);
                 const smsg::SecureMessage *psmsg = &smsg;
@@ -1543,10 +1610,10 @@ static UniValue smsgoutbox(const JSONRPCRequest &request)
                 if (rv == 0) {
                     std::string sAddrTo = EncodeDestination(PKHash(smsgStored.addrTo));
                     std::string sText = std::string((char*)msg.vchMessage.data());
-                    if (filter.size() > 0
-                        && !(part::stringsMatchI(msg.sFromAddress, filter, 3) ||
-                            part::stringsMatchI(sAddrTo, filter, 3) ||
-                            part::stringsMatchI(sText, filter, 3))) {
+                    if (filter.size() > 0 &&
+                        !(part::stringsMatchI(msg.sFromAddress, filter, 3) ||
+                          part::stringsMatchI(sAddrTo, filter, 3) ||
+                          part::stringsMatchI(sText, filter, 3))) {
                         continue;
                     }
 
diff --git a/src/smsg/smessage.cpp b/src/smsg/smessage.cpp
index 3cc80a568d..9f8f188462 100644
--- a/src/smsg/smessage.cpp
+++ b/src/smsg/smessage.cpp
@@ -3647,6 +3647,9 @@ int CSMSG::PruneFundingTxData()
             num_removed++;
         }
         delete it;
+
+        LogPrint(BCLog::SMSG, "Compacting DB\n");
+        db.Compact();
     }
     if (num_removed > 0) {
         LogPrintf("%s Removed: %d, min_height_to_keep: %d\n", __func__, num_removed, min_height_to_keep);
diff --git a/test/functional/feature_part_smsg.py b/test/functional/feature_part_smsg.py
index 54e0aa996b..fb5a240247 100755
--- a/test/functional/feature_part_smsg.py
+++ b/test/functional/feature_part_smsg.py
@@ -1,5 +1,5 @@
 #!/usr/bin/env python3
-# Copyright (c) 2017-2019 The Particl Core developers
+# Copyright (c) 2017-2022 The Particl Core developers
 # Distributed under the MIT software license, see the accompanying
 # file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
@@ -71,8 +71,6 @@ def run_test(self):
         ro = nodes[1].smsginbox()
         assert(ro['messages'][0]['to'] == address1)
         assert(ro['messages'][0]['text'] == 'Reply 0->1.')
-
-
         assert(len(nodes[1].smsgview()['messages']) == 2)
         assert(len(nodes[1].smsgoutbox()['messages']) == 1)
 
@@ -91,11 +89,37 @@ def run_test(self):
 
         self.waitForSmsgExchange(3, 1, 0)
 
+        ro = nodes[0].smsginbox('count')
+        assert(ro['num_messages'] == 2)
+        ro = nodes[0].smsginbox('count', '', {'unread_only': True})
+        assert(ro['num_messages'] == 1)
+
         ro = nodes[0].smsginbox()
         assert(len(ro['messages']) == 1)
         assert(ro['messages'][0]['from'] == address1)
         assert(ro['messages'][0]['text'] == 'Test 1->0. 2')
 
+        self.log.info('Testing smsgin/outbox pagination')
+        ro = nodes[0].smsginbox('all')
+        assert(len(ro['messages']) == 2)
+        msgids = [ro['messages'][0]['msgid'], ro['messages'][1]['msgid']]
+        ro = nodes[0].smsginbox('all', '', {'max_results': 1})
+        assert(len(ro['messages']) == 1)
+        assert(ro['messages'][0]['msgid'] == msgids[0])
+        ro = nodes[0].smsginbox('all', '', {'max_results': 1, 'offset': 1})
+        assert(len(ro['messages']) == 1)
+        assert(ro['messages'][0]['msgid'] == msgids[1])
+
+        ro = nodes[1].smsgoutbox('all')
+        assert(len(ro['messages']) == 2)
+        msgids = [ro['messages'][0]['msgid'], ro['messages'][1]['msgid']]
+        ro = nodes[1].smsgoutbox('all', '', {'max_results': 1})
+        assert(len(ro['messages']) == 1)
+        assert(ro['messages'][0]['msgid'] == msgids[0])
+        ro = nodes[1].smsgoutbox('all', '', {'max_results': 1, 'offset': 1})
+        assert(len(ro['messages']) == 1)
+        assert(ro['messages'][0]['msgid'] == msgids[1])
+
         msg = 'Test anon 1->0. 2'
         ro = nodes[1].smsgsendanon(address0, msg)
         assert(ro['result'] == 'Sent.')

From 2e7d80837f8d149b61103907f8373ef744ea3a3a Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Sat, 23 Apr 2022 11:14:39 +0200
Subject: [PATCH 35/57] tests: Trivial fixes.

---
 test/functional/feature_ins_addressindex.py    |  4 +---
 test/functional/feature_part_anon.py           |  2 +-
 test/functional/feature_part_coldstaking.py    |  2 --
 test/functional/feature_part_smsgpaid.py       |  2 +-
 test/functional/feature_part_treasury_fund.py  |  2 +-
 test/functional/feature_part_usbdevice.py      |  2 +-
 test/functional/feature_part_zmq_test.py       |  3 +--
 test/functional/p2p_part_dos.py                |  4 +---
 test/functional/p2p_part_fork.py               |  3 ++-
 test/functional/rpc_part_atomicswap.py         |  6 +++---
 test/functional/test_framework/test_node.py    |  1 -
 test/functional/test_framework/test_particl.py |  2 +-
 test/functional/wallet_part_multisig.py        |  3 ---
 test/functional/wallet_part_particl.py         |  3 +--
 test/functional/wallet_part_segwit_scripts.py  |  2 +-
 test/functional/wallet_part_watchonly.py       |  7 ++++---
 test/get_previous_releases.py                  | 10 +++++-----
 test/lint/lint-python.sh                       |  2 +-
 18 files changed, 25 insertions(+), 35 deletions(-)

diff --git a/test/functional/feature_ins_addressindex.py b/test/functional/feature_ins_addressindex.py
index 73a15eb8c0..995d4aa414 100755
--- a/test/functional/feature_ins_addressindex.py
+++ b/test/functional/feature_ins_addressindex.py
@@ -159,8 +159,6 @@ def run_test(self):
         balance0 = self.nodes[1].getaddressbalance("pqavEUgLCZeGh8o9sTcCfYVAsrTgnQTUsK")
         assert_equal(balance0["balance"], 2 * 100000000)
 
-        unspent2 = self.nodes[2].listunspent()
-
 
         balance0 = self.nodes[1].getaddressbalance("pqZDE7YNWv5PJWidiaEG8tqfebkd6PNZDV")
         assert_equal(balance0["balance"], 45 * 100000000)
@@ -320,7 +318,7 @@ def run_test(self):
 
         addr256 = nodes[3].getnewaddress("", "false", "false", "true")
 
-        txid = self.nodes[3].sendtoaddress(addr256, 2.56)
+        self.nodes[3].sendtoaddress(addr256, 2.56)
         mempool = self.nodes[3].getaddressmempool({"addresses": [addr256]})
         assert_equal(len(mempool), 1)
 
diff --git a/test/functional/feature_part_anon.py b/test/functional/feature_part_anon.py
index 2f79cb6745..a6bdbf463a 100755
--- a/test/functional/feature_part_anon.py
+++ b/test/functional/feature_part_anon.py
@@ -183,7 +183,7 @@ def run_test(self):
         # Skip initial rescan by passing -1 as scan_chain_from
         w1_3.extkeyimportmaster('drip fog service village program equip minute dentist series hawk crop sphere olympic lazy garbage segment fox library good alley steak jazz force inmate',
             '', False, 'imported key', 'imported acc', -1)
-        sxaddr1_3 = w1_3.getnewstealthaddress('lblsx11')
+        w1_3.getnewstealthaddress('lblsx11')
         w1_3.walletsettings('other', {'onlyinstance': False})
         w1_3.walletlock()
         assert(w1_3.getwalletinfo()['encryptionstatus'] == 'Locked')
diff --git a/test/functional/feature_part_coldstaking.py b/test/functional/feature_part_coldstaking.py
index 1aa6fe2466..09e36d9530 100755
--- a/test/functional/feature_part_coldstaking.py
+++ b/test/functional/feature_part_coldstaking.py
@@ -37,8 +37,6 @@ def run_test(self):
 
         self.import_genesis_coins_a(nodes[0])
 
-        txnHashes = []
-
         nodes[1].extkeyimportmaster('drip fog service village program equip minute dentist series hawk crop sphere olympic lazy garbage segment fox library good alley steak jazz force inmate')
         nodes[2].extkeyimportmaster('seccion grito medula hecho pauta posada nueve ebrio bruto buceo baul mitad')
 
diff --git a/test/functional/feature_part_smsgpaid.py b/test/functional/feature_part_smsgpaid.py
index dc94db677d..e0a820f06a 100755
--- a/test/functional/feature_part_smsgpaid.py
+++ b/test/functional/feature_part_smsgpaid.py
@@ -137,7 +137,7 @@ def run_test(self):
                 ro = nodes[1].smsg(msgid)
                 assert(ro['location'] == 'outbox')
                 break
-            except Exception as e:
+            except Exception:
                 time.sleep(1)
         assert(ro['text'] == text_3)
         assert(ro['from'] == address1)
diff --git a/test/functional/feature_part_treasury_fund.py b/test/functional/feature_part_treasury_fund.py
index 3d019166ce..b65e5ef0e2 100755
--- a/test/functional/feature_part_treasury_fund.py
+++ b/test/functional/feature_part_treasury_fund.py
@@ -49,7 +49,7 @@ def run_test(self):
         tx_funded = nodes[1].fundrawtransaction(tx_hex, {'feeRate': 5.0})
         tx_fee = int(tx_funded['fee'] * COIN)
         tx_signed = nodes[1].signrawtransactionwithwallet(tx_funded['hex'])
-        sent_txid = nodes[0].sendrawtransaction(tx_signed['hex'], 0)
+        nodes[0].sendrawtransaction(tx_signed['hex'], 0)
 
         nodes[0].walletsettings('stakelimit', {'height': 6})
         self.wait_for_height(nodes[0], 6)
diff --git a/test/functional/feature_part_usbdevice.py b/test/functional/feature_part_usbdevice.py
index 1d611df444..02a32399d4 100755
--- a/test/functional/feature_part_usbdevice.py
+++ b/test/functional/feature_part_usbdevice.py
@@ -106,7 +106,7 @@ def run_test(self):
         try:
             nodes[1].getnewstealthaddress()
             raise AssertionError('Should have failed.')
-        except JSONRPCException as e:
+        except JSONRPCException:
             pass
 
         extaddr1_0 = nodes[1].getnewextaddress()
diff --git a/test/functional/feature_part_zmq_test.py b/test/functional/feature_part_zmq_test.py
index bb6b88bcaf..5c68d0d73c 100755
--- a/test/functional/feature_part_zmq_test.py
+++ b/test/functional/feature_part_zmq_test.py
@@ -88,7 +88,6 @@ def waitForZmqSmsg(self, msgid):
 
             topic = msg[0].decode('utf-8')
             if topic == 'smsg':
-                fFound = True
                 zmqhash = msg[1].hex()
                 assert(zmqhash[:4] == '0300')  # version 3.0
                 assert(zmqhash[4:] == msgid)
@@ -127,7 +126,7 @@ def _zmq_test(self):
                 assert(zmqhash == txnHash)
             elif topic == 'rawtx' and msgSequence == 1:
                 fFoundRawTx = True
-                body = msg[1]
+                #body = msg[1]
                 # Check that the rawtx hashes to the hashtx
                 #assert_equal(hash256(body), txnHash)
                 #CTransaction.deserialize
diff --git a/test/functional/p2p_part_dos.py b/test/functional/p2p_part_dos.py
index 05aa2a4fb3..446c70e3a6 100755
--- a/test/functional/p2p_part_dos.py
+++ b/test/functional/p2p_part_dos.py
@@ -87,8 +87,7 @@ def run_test(self):
         block_count = nodes[0].getblockcount()
         pastBlockHash = nodes[0].getblockhash(block_count-MAX_HEADERS-1)
 
-        # In each iteration, send a `headers` message with the maximumal number of entries
-        t = int(time.time()+15) & 0xfffffff0
+        # In each iteration, send a `headers` message with the maximum number of entries
         self.log.info('Initial blockindexsize: %d\n' % (nodes[0].getblockchaininfo()['blockindexsize']))
         self.log.info('Generating lots of headers with no stake\n')
         sent = 0
@@ -162,7 +161,6 @@ def run_test(self):
             assert(found_misbehave_line)
 
             self.log.info('Replace headers for next test')
-            t = int(time.time()+15) & 0xfffffff0
             self.log.info('Initial blockindexsize: %d\n' % (nodes[0].getblockchaininfo()['blockindexsize']))
             self.log.info('Generating lots of headers with no stake\n')
             sent = 0
diff --git a/test/functional/p2p_part_fork.py b/test/functional/p2p_part_fork.py
index a202b728f2..81b9def1f8 100755
--- a/test/functional/p2p_part_fork.py
+++ b/test/functional/p2p_part_fork.py
@@ -83,6 +83,7 @@ def run_test(self):
 
         # Stop group1 from staking
         nodes[0].reservebalance(True, 10000000)
+        assert(nodes[0].getblockcount() == nBlocksShorterChain)
 
         self.wait_for_height(nodes[3], nBlocksLongerChain, 2000)
 
@@ -164,7 +165,7 @@ def run_test(self):
 
         n0_lt = nodes[0].listtransactions()
         num_orphaned = 0
-        for tx in n0_ft:
+        for tx in n0_lt:
             if tx['category'] == 'orphaned_stake':
                 num_orphaned += 1
         assert(num_orphaned == 2)
diff --git a/test/functional/rpc_part_atomicswap.py b/test/functional/rpc_part_atomicswap.py
index 965437d6c3..83dfead2fa 100755
--- a/test/functional/rpc_part_atomicswap.py
+++ b/test/functional/rpc_part_atomicswap.py
@@ -504,7 +504,7 @@ def test_standardtx(self):
 
 
         rawtx2refund = createRefundTx(nodes[0], rawtxInitiate, scriptInitiate2, lockTime, addrA_0, addrA_0)
-        txnid2 = nodes[0].sendrawtransaction(rawtxInitiate)
+        nodes[0].sendrawtransaction(rawtxInitiate)
 
         self.stakeBlocks(1)
 
@@ -613,7 +613,7 @@ def test_cttx(self):
         print(ro)
         assert('non-final' in ro[0]['reject-reason'])
 
-        txnid1 = nodes[0].sendrawtransaction(rawtx_i)
+        nodes[0].sendrawtransaction(rawtx_i)
         self.stakeBlocks(1)
 
 
@@ -720,7 +720,7 @@ def test_cttx(self):
         assert('missing-inputs' in ro[0]['reject-reason'])
 
 
-        txnid1 = nodes[0].sendrawtransaction(rawtx_i)
+        nodes[0].sendrawtransaction(rawtx_i)
         ro = nodes[0].getwalletinfo()
         assert(ro['unconfirmed_blind'] > 6.0 and ro['unconfirmed_blind'] < 7.0)
 
diff --git a/test/functional/test_framework/test_node.py b/test/functional/test_framework/test_node.py
index c75d9d0dc4..29db61fcfd 100755
--- a/test/functional/test_framework/test_node.py
+++ b/test/functional/test_framework/test_node.py
@@ -700,7 +700,6 @@ def addmultisigaddress(self, nrequired, keys, label=None, address_type=None):
         return cms
 
     def addmultisigaddress_part(self, nrequired, keys, label=None, bech32=False, large_key=False, address_type=None):
-        wallet_info = self.getwalletinfo()
         if self.is_cli:
             if label is None:
                 label = 'null'
diff --git a/test/functional/test_framework/test_particl.py b/test/functional/test_framework/test_particl.py
index 90b0b3879a..b0bdc2fb29 100644
--- a/test/functional/test_framework/test_particl.py
+++ b/test/functional/test_framework/test_particl.py
@@ -101,7 +101,7 @@ def wait_for_wtx(self, node, txid, nTries=20):
         for i in range(50):
             time.sleep(0.5)
             try:
-                rv = node.gettransaction(txid)
+                node.gettransaction(txid)
                 return True
             except:
                 continue
diff --git a/test/functional/wallet_part_multisig.py b/test/functional/wallet_part_multisig.py
index 0f6516a7b4..1709df8e61 100755
--- a/test/functional/wallet_part_multisig.py
+++ b/test/functional/wallet_part_multisig.py
@@ -60,7 +60,6 @@ def run_test(self):
 
         ro = nodes[0].getaddressinfo(msAddr)
         assert(ro['isscript'] == True)
-        scriptPubKey = ro['scriptPubKey']
         redeemScript = ro['hex']
 
 
@@ -123,7 +122,6 @@ def run_test(self):
         assert(ro['isscript'] == True)
         assert(ro['sigsrequired'] == 2)
 
-        scriptPubKey = ro['scriptPubKey']
         redeemScript = ro['hex']
 
         mstxid2 = nodes[0].sendtoaddress(msAddr256, 9)
@@ -247,7 +245,6 @@ def run_test(self):
 
         ro = nodes[0].getaddressinfo(msAddr)
         assert(ro['isscript'] == True)
-        scriptPubKey = ro['scriptPubKey']
         redeemScript = ro['hex']
 
         inputs = [{
diff --git a/test/functional/wallet_part_particl.py b/test/functional/wallet_part_particl.py
index df439512c3..715b3128d5 100755
--- a/test/functional/wallet_part_particl.py
+++ b/test/functional/wallet_part_particl.py
@@ -124,8 +124,7 @@ def run_test(self):
         ro = nodes[0].extkey('setDefaultAccount', account0_id)
         assert(ro['result'] == 'Success.')
 
-        address0 = nodes[0].getnewaddress()
-
+        nodes[0].getnewaddress()
         ro = nodes[0].extkey('account', account0_id)
 
         fFound = False
diff --git a/test/functional/wallet_part_segwit_scripts.py b/test/functional/wallet_part_segwit_scripts.py
index aa316ed3de..41b5f36533 100755
--- a/test/functional/wallet_part_segwit_scripts.py
+++ b/test/functional/wallet_part_segwit_scripts.py
@@ -41,7 +41,7 @@ def run_test(self):
 
         self.log.info('Test Bitcoin embedded segwit')
         try:
-            addr_sw_p2sh = nodes[2].getnewaddress('segwit script', False, False, False, 'p2sh-segwit')
+            nodes[2].getnewaddress('segwit script', False, False, False, 'p2sh-segwit')
             assert(False)
         except Exception as e:
             assert('p2sh-segwit is disabled' in str(e))
diff --git a/test/functional/wallet_part_watchonly.py b/test/functional/wallet_part_watchonly.py
index 697d170ae3..98588d94cd 100755
--- a/test/functional/wallet_part_watchonly.py
+++ b/test/functional/wallet_part_watchonly.py
@@ -50,6 +50,7 @@ def run_test(self):
         sxaddr0 = nodes[0].getnewstealthaddress()
         sxaddrs = nodes[0].liststealthaddresses(True)
         addr_info = nodes[0].getaddressinfo(sxaddr0)
+        assert(addr_info['ismine'] is True)
         scan_vk = sxaddrs[0]['Stealth Addresses'][0]['Scan Secret']
         spend_pk = sxaddrs[0]['Stealth Addresses'][0]['spend_public_key']
         spend_vk = sxaddrs[0]['Stealth Addresses'][0]['Spend Secret']
@@ -60,7 +61,7 @@ def run_test(self):
         assert(ro['ismine'] == False)
         assert(ro['iswatchonly'] == True)
 
-        txid = nodes[0].sendtoaddress(sxaddr0, 1.0)
+        nodes[0].sendtoaddress(sxaddr0, 1.0)
         self.stakeBlocks(1)
 
         w0 = nodes[0].getwalletinfo()
@@ -73,7 +74,7 @@ def run_test(self):
         self.log.info('Test sending blind output to watchonly')
         coincontrol = {'blind_watchonly_visible': True}
         outputs = [{'address': sxaddr0, 'amount': 10},]
-        txid = nodes[0].sendtypeto('part', 'blind', outputs, 'comment', 'comment-to', 4, 64, False, coincontrol)
+        nodes[0].sendtypeto('part', 'blind', outputs, 'comment', 'comment-to', 4, 64, False, coincontrol)
         self.stakeBlocks(1)
         w0 = nodes[0].getbalances()
         w2 = nodes[2].getbalances()
@@ -85,7 +86,7 @@ def run_test(self):
         self.log.info('Test sending anon output to watchonly')
         coincontrol = {'blind_watchonly_visible': True}
         outputs = [{'address': sxaddr0, 'amount': 10},]
-        txid = nodes[0].sendtypeto('part', 'anon', outputs, 'comment', 'comment-to', 4, 64, False, coincontrol)
+        nodes[0].sendtypeto('part', 'anon', outputs, 'comment', 'comment-to', 4, 64, False, coincontrol)
         self.stakeBlocks(1)
         w0 = nodes[0].getbalances()
         w2 = nodes[2].getbalances()
diff --git a/test/get_previous_releases.py b/test/get_previous_releases.py
index a809191fbc..5e3f19998e 100755
--- a/test/get_previous_releases.py
+++ b/test/get_previous_releases.py
@@ -85,11 +85,11 @@ def download_binary(tag, args) -> int:
             return 0
         shutil.rmtree(tag)
     Path(tag).mkdir()
-    bin_path = 'bin/particl-core-{}'.format(tag[1:])
-    match = re.compile('v(.*)(rc[0-9]+)$').search(tag)
-    if match:
-        bin_path = 'bin/particl-core-{}/test.{}'.format(
-            match.group(1), match.group(2))
+    #bin_path = 'bin/particl-core-{}'.format(tag[1:])
+    #match = re.compile('v(.*)(rc[0-9]+)$').search(tag)
+    #if match:
+    #    bin_path = 'bin/particl-core-{}/test.{}'.format(
+    #        match.group(1), match.group(2))
     tarball = 'particl-{tag}-{platform}.tar.gz'.format(
         tag=tag[1:], platform=args.platform)
     #tarballUrl = 'https://bitcoincore.org/{bin_path}/{tarball}'.format(
diff --git a/test/lint/lint-python.sh b/test/lint/lint-python.sh
index 2f4540ad59..4fc130497b 100755
--- a/test/lint/lint-python.sh
+++ b/test/lint/lint-python.sh
@@ -69,7 +69,7 @@ enabled=(
     F822 # undefined name name in __all__
     F823 # local variable name  referenced before assignment
     F831 # duplicate argument name in function definition
-#    F841 # local variable 'foo' is assigned to but never used
+    F841 # local variable 'foo' is assigned to but never used
     W191 # indentation contains tabs
     W291 # trailing whitespace
     W292 # no newline at end of file

From 16b8a2da502f6c8f343be96d882fa2d5ec85d8c8 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Sun, 24 Apr 2022 16:25:35 +0200
Subject: [PATCH 36/57] smsg: Shutdown smsgdb even if smsg is not initialised.

---
 doc/release-notes-particl.md   |   3 +-
 src/Makefile.am                |   7 ++-
 src/coins.h                    |   3 +
 src/net_processing.cpp         |   4 +-
 src/smsg/db.cpp                |   6 +-
 src/smsg/db.h                  |  13 ++--
 src/smsg/smessage.cpp          | 108 +++++++++++++++------------------
 src/smsg/smessage.h            |  14 +++--
 src/smsg/types.h               |  26 ++++++++
 src/test/util/setup_common.cpp |   2 +
 src/validation.cpp             |  10 +--
 11 files changed, 116 insertions(+), 80 deletions(-)
 create mode 100644 src/smsg/types.h

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index fe8200ed65..07babaa724 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -3,7 +3,8 @@
 ==============
 
 - smsg: The smsgdb is periodically compacted.
-- smsg: Added pagination to smsginbox and smsgoutbox
+- smsg: Added pagination to smsginbox and smsgoutbox.
+- smsg: Shutdown smsgdb even if smsg is not initialised.
 
 
 0.21.2.8
diff --git a/src/Makefile.am b/src/Makefile.am
index c22bb66b19..e8f18320f6 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -227,8 +227,9 @@ BITCOIN_CORE_H = \
   signet.h \
   streams.h \
   smsg/db.h \
-  smsg/crypter.h \
   smsg/net.h \
+  smsg/types.h \
+  smsg/crypter.h \
   smsg/smessage.h \
   smsg/rpcsmessage.h \
   support/allocators/secure.h \
@@ -787,7 +788,9 @@ particl_tx_LDADD = \
   $(LIBPARTICL_UTIL) \
   $(LIBPARTICL_CONSENSUS) \
   $(LIBPARTICL_CRYPTO) \
-  $(LIBSECP256K1)
+  $(LIBSECP256K1) \
+  $(LIBLEVELDB) \
+  $(LIBLEVELDB_SSE42)
 
 particl_tx_LDADD += $(BOOST_LIBS)
 #
diff --git a/src/coins.h b/src/coins.h
index 52e2007d24..cffe4249a0 100644
--- a/src/coins.h
+++ b/src/coins.h
@@ -22,6 +22,7 @@
 #include <insight/addressindex.h>
 #include <insight/spentindex.h>
 #include <rctindex.h>
+#include <smsg/types.h>
 
 extern bool fParticlMode;
 
@@ -321,6 +322,7 @@ class CCoinsViewCache : public CCoinsViewBacked
     mutable std::map<CCmpPubKey, int64_t> anonOutputLinks;
     mutable std::map<CCmpPubKey, uint256> keyImages;
     mutable std::vector<std::pair<COutPoint, SpentCoin> > spent_cache;
+    mutable smsg::ChainSyncCache smsg_cache;
 
     bool ReadRCTOutputLink(CCmpPubKey &pk, int64_t &index)
     {
@@ -339,6 +341,7 @@ class CCoinsViewCache : public CCoinsViewBacked
         anonOutputLinks.clear();
         keyImages.clear();
         spent_cache.clear();
+        smsg_cache.Clear();
     };
 
 public:
diff --git a/src/net_processing.cpp b/src/net_processing.cpp
index 7cd77cc349..fcaa119b9f 100644
--- a/src/net_processing.cpp
+++ b/src/net_processing.cpp
@@ -1752,7 +1752,9 @@ void PeerManager::BlockChecked(const CBlock& block, const BlockValidationState&
     const uint256 hash(block.GetHash());
     std::map<uint256, std::pair<NodeId, bool>>::iterator it = mapBlockSource.find(hash);
 
-    MaybePunishNodeForDuplicates(/*nodeid=*/ it->second.first, state);
+    if (it != mapBlockSource.end()) {
+        MaybePunishNodeForDuplicates(/*nodeid=*/ it->second.first, state);
+    }
     // If the block failed validation, we know where it came from and we're still connected
     // to that peer, maybe punish.
     if (state.IsInvalid() &&
diff --git a/src/smsg/db.cpp b/src/smsg/db.cpp
index e6c8f5db61..b800e1cd34 100644
--- a/src/smsg/db.cpp
+++ b/src/smsg/db.cpp
@@ -39,9 +39,9 @@ bool SecMsgDB::Open(const char *pszMode)
 
     fs::path fullpath = GetDataDir() / "smsgdb";
 
-    if (!fCreate
-        && (!fs::exists(fullpath)
-            || !fs::is_directory(fullpath))) {
+    if (!fCreate &&
+        (!fs::exists(fullpath) ||
+         !fs::is_directory(fullpath))) {
         LogPrintf("%s: DB does not exist.\n", __func__);
         return false;
     }
diff --git a/src/smsg/db.h b/src/smsg/db.h
index 964fbeb226..45bb91d718 100644
--- a/src/smsg/db.h
+++ b/src/smsg/db.h
@@ -36,20 +36,21 @@ extern const std::string DBK_FUNDING_TX_LINK;
 class SecMsgDB
 {
 public:
-    SecMsgDB()
+    ~SecMsgDB()
     {
-        activeBatch = nullptr;
+        Finalise();
     }
 
-    ~SecMsgDB()
-    {
+    void Finalise() {
         // Deletes only data scoped to this SecMsgDB object.
         if (activeBatch) {
             delete activeBatch;
         }
+        pdb = nullptr;
     }
 
     bool Open(const char *pszMode="r+");
+    bool IsOpen() const { return pdb; };
 
     bool ScanBatch(const CDataStream &key, std::string *value, bool *deleted) const;
 
@@ -93,8 +94,8 @@ class SecMsgDB
      */
     void Compact() const;
 
-    leveldb::DB *pdb; // points to the global instance
-    leveldb::WriteBatch *activeBatch;
+    leveldb::DB *pdb{nullptr};  // Points to the global instance
+    leveldb::WriteBatch *activeBatch{nullptr};
 };
 
 bool PutBestBlock(leveldb::WriteBatch *batch, const uint256 &block_hash, int height);
diff --git a/src/smsg/smessage.cpp b/src/smsg/smessage.cpp
index 9f8f188462..2244de27cf 100644
--- a/src/smsg/smessage.cpp
+++ b/src/smsg/smessage.cpp
@@ -974,37 +974,36 @@ bool CSMSG::Start(std::shared_ptr<CWallet> pwalletIn, std::vector<std::shared_pt
     return true;
 };
 
-bool CSMSG::Shutdown()
+void CSMSG::Finalise()
 {
-    if (!fSecMsgEnabled) {
-        return false;
+    if (smsgDB) {
+        LOCK(cs_smsgDB);
+        delete smsgDB;
+        smsgDB = nullptr;
     }
+    m_chain_sync_db.Finalise();
+};
 
+bool CSMSG::Shutdown()
+{
     LogPrintf("Stopping secure messaging.\n");
+    bool was_enabled = fSecMsgEnabled;
 
-    if (m_connect_block_batch) {
-        LogPrintf("%s: Closing uncommitted batch.\n", __func__);
-        delete m_connect_block_batch;
-        m_connect_block_batch = nullptr;
-    }
-
-    if (WriteIni() != 0) {
+    if (was_enabled && WriteIni() != 0) {
         LogPrintf("Failed to save smsg.ini\n");
     }
 
     fSecMsgEnabled = false;
-    m_node->connman->SetLocalServices(ServiceFlags(m_node->connman->GetLocalServices() & ~NODE_SMSG));
 
     m_thread_interrupt();
-    thread_smsg.join();
-    thread_smsg_pow.join();
-
-    if (smsgDB) {
-        LOCK(cs_smsgDB);
-        delete smsgDB;
-        smsgDB = nullptr;
+    if (thread_smsg.joinable()) {
+        thread_smsg.join();
+    }
+    if (thread_smsg_pow.joinable()) {
+        thread_smsg_pow.join();
     }
 
+    Finalise();
     keyStore.Clear();
 
     if (secp256k1_context_smsg) {
@@ -1012,12 +1011,15 @@ bool CSMSG::Shutdown()
     }
     secp256k1_context_smsg = nullptr;
 
-    UnloadAllWallets();
+    if (was_enabled) {
+        m_node->connman->SetLocalServices(ServiceFlags(m_node->connman->GetLocalServices() & ~NODE_SMSG));
+        UnloadAllWallets();
 #ifdef ENABLE_WALLET
-    if (m_wallet_load_handler) {
-        m_wallet_load_handler->disconnect();
-    }
+        if (m_wallet_load_handler) {
+            m_wallet_load_handler->disconnect();
+        }
 #endif
+    }
     return true;
 };
 
@@ -3468,33 +3470,12 @@ int CSMSG::AdjustDifficulty(int64_t time)
     return rv;
 };
 
-int CSMSG::StartConnectingBlock()
+int CSMSG::StoreFundingTx(ChainSyncCache &cache, const CTransaction &tx, const CBlockIndex *pindex)
 {
     if (!m_track_funding_txns) {
         return SMSG_NO_ERROR;
     }
 
-    if (m_connect_block_batch) {
-        LogPrintf("%s: Closing uncommitted batch.\n", __func__);
-        delete m_connect_block_batch;
-        m_connect_block_batch = nullptr;
-    }
-
-    m_connect_block_batch = new leveldb::WriteBatch();
-
-    return SMSG_NO_ERROR;
-}
-
-int CSMSG::StoreFundingTx(const CTransaction &tx, const CBlockIndex *pindex)
-{
-    if (!m_track_funding_txns) {
-        return SMSG_NO_ERROR;
-    }
-
-    if (!m_connect_block_batch) {
-        return errorN(SMSG_GENERAL_ERROR, "%s: db batch not initialised.\n", __func__);
-    }
-
     const uint256 &block_hash = pindex->GetBlockHash();
     if (LogAcceptCategory(BCLog::SMSG)) {
         LogPrintf("%s Tx: %s, block: %s, height %d, time %d.\n", __func__, tx.GetHash().ToString(), block_hash.ToString(), pindex->nHeight, pindex->nTime);
@@ -3526,7 +3507,7 @@ int CSMSG::StoreFundingTx(const CTransaction &tx, const CBlockIndex *pindex)
 
     // TODO: Get current fee-rate, GetSmsgFeeRate
 
-    if (!PutFundingData(m_connect_block_batch, tx.GetHash(), pindex->nHeight, db_data)) {
+    if (!PutFundingData(&cache.m_connect_block_batch, tx.GetHash(), pindex->nHeight, db_data)) {
         return errorN(SMSG_GENERAL_ERROR, "%s - PutFundingData failed.", __func__);
     }
 
@@ -3658,32 +3639,43 @@ int CSMSG::PruneFundingTxData()
     return 0;
 };
 
-int CSMSG::SetBestBlock(const uint256 &block_hash, int height, int64_t time)
+int CSMSG::SetBestBlock(ChainSyncCache &cache, const uint256 &block_hash, int height, int64_t time)
 {
     if (!m_track_funding_txns) {
         return SMSG_NO_ERROR;
     }
     if (time < GetAdjustedTime() - KEEP_FUNDING_TX_DATA) {
         // Skip old blocks
+        cache.m_skip = true;
         return SMSG_NO_ERROR;
     }
-    if (!m_connect_block_batch) {
-        return SMSG_BATCH_NOT_INITIALISED;
-    }
 
-    LOCK(cs_smsgDB);
-    SecMsgDB db;
-    if (!db.Open("cw")) {
-        return SMSG_GENERAL_ERROR;
+    if (!PutBestBlock(&cache.m_connect_block_batch, block_hash, height)) {
+        return errorN(SMSG_GENERAL_ERROR, "%s - PutBestBlock failed.", __func__);
     }
 
-    if (!PutBestBlock(m_connect_block_batch, block_hash, height)) {
-        return errorN(SMSG_GENERAL_ERROR, "%s - PutBestBlock failed.", __func__);
+    return SMSG_NO_ERROR;
+}
+
+int CSMSG::WriteCache(ChainSyncCache &cache)
+{
+    if (!m_track_funding_txns) {
+        return SMSG_NO_ERROR;
+    }
+    if (cache.m_skip) {
+        // Skip old blocks
+        return SMSG_NO_ERROR;
     }
 
-    db.CommitBatch(m_connect_block_batch);
-    delete m_connect_block_batch;
-    m_connect_block_batch = nullptr;
+    {
+        LOCK(cs_smsgDB);
+        if (!m_chain_sync_db.IsOpen()) {
+            if (!m_chain_sync_db.Open("cw")) {
+                return SMSG_GENERAL_ERROR;
+            }
+        }
+        m_chain_sync_db.CommitBatch(&cache.m_connect_block_batch);
+    }
 
     return SMSG_NO_ERROR;
 }
diff --git a/src/smsg/smessage.h b/src/smsg/smessage.h
index 3757a57bac..2ce7a93e79 100644
--- a/src/smsg/smessage.h
+++ b/src/smsg/smessage.h
@@ -15,7 +15,9 @@
 #include <interfaces/handler.h>
 #include <interfaces/node.h>
 #include <util/ui_change_type.h>
-#include <leveldb/write_batch.h>
+#include <smsg/db.h>
+#include <smsg/types.h>
+
 
 #include <atomic>
 #include <boost/signals2/signal.hpp>
@@ -440,6 +442,8 @@ class CSMSG
     int WriteIni();
 
     bool Start(std::shared_ptr<CWallet> pwalletIn, std::vector<std::shared_ptr<CWallet>> &vpwallets, bool fScanChain);
+    //! Finalise the database
+    void Finalise();
     bool Shutdown();
 
     bool Enable(std::shared_ptr<CWallet> pwallet, std::vector<std::shared_ptr<CWallet>> &vpwallets);
@@ -517,11 +521,11 @@ class CSMSG
     std::vector<uint8_t> GetMsgID(const SecureMessage *psmsg, const uint8_t *pPayload);
     std::vector<uint8_t> GetMsgID(const SecureMessage &smsg);
 
-    int StartConnectingBlock();
-    int StoreFundingTx(const CTransaction &tx, const CBlockIndex *pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
+    int StoreFundingTx(ChainSyncCache &cache, const CTransaction &tx, const CBlockIndex *pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
     int CheckFundingTx(const Consensus::Params &consensus_params, const SecureMessage *psmsg, const uint8_t *pPayload);
     int PruneFundingTxData();
-    int SetBestBlock(const uint256 &block_hash, int height, int64_t time);
+    int SetBestBlock(ChainSyncCache &cache, const uint256 &block_hash, int height, int64_t time);
+    int WriteCache(ChainSyncCache &cache);
     int ReadBestBlock(uint256 &block_hash, int &height);
     int ClearBestBlock();
 
@@ -563,6 +567,7 @@ class CSMSG
 
     bool m_track_funding_txns{false};
     leveldb::WriteBatch *m_connect_block_batch{nullptr};
+    SecMsgDB m_chain_sync_db;
 
     NodeContext *m_node = nullptr;
 };
@@ -574,4 +579,3 @@ double GetDifficulty(uint32_t compact);
 extern smsg::CSMSG smsgModule;
 
 #endif // PARTICL_SMSG_SMESSAGE_H
-
diff --git a/src/smsg/types.h b/src/smsg/types.h
new file mode 100644
index 0000000000..9fb5fefb35
--- /dev/null
+++ b/src/smsg/types.h
@@ -0,0 +1,26 @@
+// Copyright (c) 2022 The Particl Core developers
+// Distributed under the MIT/X11 software license, see the accompanying
+// file COPYING or http://www.opensource.org/licenses/mit-license.php.
+
+#ifndef PARTICL_SMSG_TYPES_H
+#define PARTICL_SMSG_TYPES_H
+
+#include <leveldb/write_batch.h>
+
+namespace smsg {
+
+class ChainSyncCache
+{
+public:
+    void Clear() {
+        m_skip = false;
+        m_connect_block_batch.Clear();
+    }
+
+    bool m_skip = false;  // Don't commit if data is expired
+    leveldb::WriteBatch m_connect_block_batch;
+};
+
+} // namespace smsg
+
+#endif // PARTICL_SMSG_TYPES_H
diff --git a/src/test/util/setup_common.cpp b/src/test/util/setup_common.cpp
index 1df6852fe5..53d0222e69 100644
--- a/src/test/util/setup_common.cpp
+++ b/src/test/util/setup_common.cpp
@@ -37,6 +37,7 @@
 
 // Particl
 #include <insight/insight.h>
+#include <smsg/smessage.h>
 
 #include <functional>
 
@@ -200,6 +201,7 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const
 
 TestingSetup::~TestingSetup()
 {
+    smsgModule.Finalise();  // DB could have been initialised
     if (m_node.scheduler) m_node.scheduler->stop();
     threadGroup.interrupt_all();
     threadGroup.join_all();
diff --git a/src/validation.cpp b/src/validation.cpp
index dc2932a4b5..7133072110 100644
--- a/src/validation.cpp
+++ b/src/validation.cpp
@@ -2678,8 +2678,6 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,
     int64_t nTime2 = GetTimeMicros(); nTimeForks += nTime2 - nTime1;
     LogPrint(BCLog::BENCH, "    - Fork checks: %.2fms [%.2fs (%.2fms/blk)]\n", MILLI * (nTime2 - nTime1), nTimeForks * MICRO, nTimeForks * MILLI / nBlocksTotal);
 
-    smsgModule.StartConnectingBlock();
-
     CBlockUndo blockundo;
 
     // Precomputed transaction data pointers must not be invalidated
@@ -2807,7 +2805,7 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,
                 }
 
                 if (tx_state.m_funds_smsg) {
-                    smsgModule.StoreFundingTx(tx, pindex);
+                    smsgModule.StoreFundingTx(view.smsg_cache, tx, pindex);
                 }
             }
         } else {
@@ -3164,7 +3162,7 @@ bool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,
 
     assert(pindex->phashBlock);
 
-    smsgModule.SetBestBlock(pindex->GetBlockHash(), pindex->nHeight, pindex->nTime);
+    smsgModule.SetBestBlock(view.smsg_cache, pindex->GetBlockHash(), pindex->nHeight, pindex->nTime);
 
     // add this block to the view's block chain
     view.SetBestBlock(pindex->GetBlockHash(), pindex->nHeight);
@@ -3462,6 +3460,9 @@ bool FlushView(CCoinsViewCache *view, BlockValidationState& state, bool fDisconn
         if (!pblocktree->WriteBatch(batch)) {
             return error("%s: Write index data failed.", __func__);
         }
+        if (0 != smsgModule.WriteCache(view->smsg_cache)) {
+            return error("%s: smsgModule WriteCache failed.", __func__);
+        }
     }
 
     view->nLastRCTOutput = 0;
@@ -3469,6 +3470,7 @@ bool FlushView(CCoinsViewCache *view, BlockValidationState& state, bool fDisconn
     view->anonOutputLinks.clear();
     view->keyImages.clear();
     view->spent_cache.clear();
+    view->smsg_cache.Clear();
 
     return true;
 };

From 0b0a6bc3eea7899072e0693ffcb85bf3fa7c999d Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Sun, 24 Apr 2022 21:54:01 +0200
Subject: [PATCH 37/57] build: Raise version to 0.21.2.9

---
 ci/test/00_setup_env_native_qt5.sh          |  2 +-
 configure.ac                                |  4 ++--
 contrib/gitian-descriptors/assign_DISTNAME  |  2 +-
 contrib/gitian-descriptors/gitian-linux.yml |  2 +-
 contrib/gitian-descriptors/gitian-osx.yml   |  2 +-
 contrib/gitian-descriptors/gitian-win.yml   |  2 +-
 doc/man/particl-cli.1                       |  6 +++---
 doc/man/particl-qt.1                        | 10 +++++++---
 doc/man/particl-tx.1                        |  6 +++---
 doc/man/particl-wallet.1                    |  6 +++---
 doc/man/particld.1                          | 10 +++++++---
 doc/release-notes-particl.md                |  2 ++
 12 files changed, 32 insertions(+), 22 deletions(-)

diff --git a/ci/test/00_setup_env_native_qt5.sh b/ci/test/00_setup_env_native_qt5.sh
index 920c67d3e8..d4143d1513 100644
--- a/ci/test/00_setup_env_native_qt5.sh
+++ b/ci/test/00_setup_env_native_qt5.sh
@@ -17,5 +17,5 @@ export RUN_SECURITY_TESTS="true"
 export RUN_UNIT_TESTS_SEQUENTIAL="true"
 export RUN_UNIT_TESTS="false"
 export GOAL="install"
-export PREVIOUS_RELEASES_TO_DOWNLOAD="v0.18.1.7 v0.19.0.1"
+export PREVIOUS_RELEASES_TO_DOWNLOAD="v0.18.1.7 v0.19.2.20"
 export BITCOIN_CONFIG="--enable-zmq --with-libs=no --with-gui=qt5 --enable-glibc-back-compat --enable-reduce-exports --enable-c++17 --enable-debug CFLAGS=\"-g0 -O2 -funsigned-char\" CXXFLAGS=\"-g0 -O2 -funsigned-char\" --with-boost-process --enable-usbdevice"
diff --git a/configure.ac b/configure.ac
index 2033e100d0..7ca9df927d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2,8 +2,8 @@ AC_PREREQ([2.69])
 define(_CLIENT_VERSION_MAJOR, 0)
 define(_CLIENT_VERSION_MINOR, 21)
 define(_CLIENT_VERSION_REVISION, 2)
-define(_CLIENT_VERSION_PARTICL, 8)
-define(_CLIENT_VERSION_BUILD, 1)
+define(_CLIENT_VERSION_PARTICL, 9)
+define(_CLIENT_VERSION_BUILD, 0)
 define(_CLIENT_VERSION_RC, 0)
 define(_CLIENT_VERSION_IS_RELEASE, true)
 define(_COPYRIGHT_YEAR_BTC, 2021)
diff --git a/contrib/gitian-descriptors/assign_DISTNAME b/contrib/gitian-descriptors/assign_DISTNAME
index b71a4c1c30..6645a66c6c 100755
--- a/contrib/gitian-descriptors/assign_DISTNAME
+++ b/contrib/gitian-descriptors/assign_DISTNAME
@@ -10,5 +10,5 @@ else
     VERSION="$(git rev-parse --short=12 HEAD)"
 fi
 # git describe isn't detecting the tag in gitian
-VERSION="0.21.2.8"
+VERSION="0.21.2.9"
 DISTNAME="particl-${VERSION}"
diff --git a/contrib/gitian-descriptors/gitian-linux.yml b/contrib/gitian-descriptors/gitian-linux.yml
index f46ec375f2..b6a1e14315 100644
--- a/contrib/gitian-descriptors/gitian-linux.yml
+++ b/contrib/gitian-descriptors/gitian-linux.yml
@@ -1,5 +1,5 @@
 ---
-name: "particl-linux-0.21.2.8"
+name: "particl-linux-0.21.2.9"
 enable_cache: true
 sudo: true
 distro: "ubuntu"
diff --git a/contrib/gitian-descriptors/gitian-osx.yml b/contrib/gitian-descriptors/gitian-osx.yml
index 30d3151354..88467d017d 100644
--- a/contrib/gitian-descriptors/gitian-osx.yml
+++ b/contrib/gitian-descriptors/gitian-osx.yml
@@ -1,5 +1,5 @@
 ---
-name: "particl-osx-0.21.2.8"
+name: "particl-osx-0.21.2.9"
 enable_cache: true
 distro: "ubuntu"
 suites:
diff --git a/contrib/gitian-descriptors/gitian-win.yml b/contrib/gitian-descriptors/gitian-win.yml
index 0cd0c62554..946751da00 100644
--- a/contrib/gitian-descriptors/gitian-win.yml
+++ b/contrib/gitian-descriptors/gitian-win.yml
@@ -1,5 +1,5 @@
 ---
-name: "particl-win-0.21.2.8"
+name: "particl-win-0.21.2.9"
 enable_cache: true
 sudo: true
 distro: "ubuntu"
diff --git a/doc/man/particl-cli.1 b/doc/man/particl-cli.1
index a7403d1601..30310223e9 100644
--- a/doc/man/particl-cli.1
+++ b/doc/man/particl-cli.1
@@ -1,7 +1,7 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
-.TH PARTICL-CLI "1" "April 2022" "particl-cli v0.21.2.8" "User Commands"
+.TH PARTICL-CLI "1" "April 2022" "particl-cli v0.21.2.9" "User Commands"
 .SH NAME
-particl-cli  manual page for particl-cli v0.21.2.8
+particl-cli  manual page for particl-cli v0.21.2.9
 .SH SYNOPSIS
 .B particl-cli
 [\fI\,options\/\fR] \fI\,<command> \/\fR[\fI\,params\/\fR]  \fI\,Send command to Particl Core\/\fR
@@ -15,7 +15,7 @@ particl-cli  manual page for particl-cli v0.21.2.8
 .B particl-cli
 [\fI\,options\/\fR] \fI\,help <command>      Get help for a command\/\fR
 .SH DESCRIPTION
-Particl Core RPC client version v0.21.2.8
+Particl Core RPC client version v0.21.2.9
 .SH OPTIONS
 .HP
 ?
diff --git a/doc/man/particl-qt.1 b/doc/man/particl-qt.1
index bddbf5eec6..7a71f9eb30 100644
--- a/doc/man/particl-qt.1
+++ b/doc/man/particl-qt.1
@@ -1,12 +1,12 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
-.TH PARTICL-QT "1" "April 2022" "particl-qt v0.21.2.8" "User Commands"
+.TH PARTICL-QT "1" "April 2022" "particl-qt v0.21.2.9" "User Commands"
 .SH NAME
-particl-qt  manual page for particl-qt v0.21.2.8
+particl-qt  manual page for particl-qt v0.21.2.9
 .SH SYNOPSIS
 .B particl-qt
 [\fI\,command-line options\/\fR]
 .SH DESCRIPTION
-Particl Core version v0.21.2.8
+Particl Core version v0.21.2.9
 .SH OPTIONS
 .HP
 ?
@@ -34,6 +34,10 @@ testnet:
 signet:
 0000002a1de0f46379358c1fd09906f7ac59adf3712323ed90eb59e4c183c020)
 .HP
+\fBautomaticbans\fR
+.IP
+Whether to automatically ban misbehaving nodes. (default: 1)
+.HP
 \fBbalancesindex\fR
 .IP
 Maintain a balances index per block (default: 0)
diff --git a/doc/man/particl-tx.1 b/doc/man/particl-tx.1
index 3cc758bcec..68a71b006f 100644
--- a/doc/man/particl-tx.1
+++ b/doc/man/particl-tx.1
@@ -1,7 +1,7 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
-.TH PARTICL-TX "1" "April 2022" "particl-tx v0.21.2.8" "User Commands"
+.TH PARTICL-TX "1" "April 2022" "particl-tx v0.21.2.9" "User Commands"
 .SH NAME
-particl-tx  manual page for particl-tx v0.21.2.8
+particl-tx  manual page for particl-tx v0.21.2.9
 .SH SYNOPSIS
 .B particl-tx
 [\fI\,options\/\fR] \fI\,<hex-tx> \/\fR[\fI\,commands\/\fR]  \fI\,Update hex-encoded transaction\/\fR
@@ -9,7 +9,7 @@ particl-tx  manual page for particl-tx v0.21.2.8
 .B particl-tx
 [\fI\,options\/\fR] \fI\,-create \/\fR[\fI\,commands\/\fR]   \fI\,Create hex-encoded transaction\/\fR
 .SH DESCRIPTION
-Particl Core particltx utility version v0.21.2.8
+Particl Core particltx utility version v0.21.2.9
 .SH OPTIONS
 .HP
 ?
diff --git a/doc/man/particl-wallet.1 b/doc/man/particl-wallet.1
index 307650226b..11d3f9f53c 100644
--- a/doc/man/particl-wallet.1
+++ b/doc/man/particl-wallet.1
@@ -1,9 +1,9 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
-.TH PARTICL-WALLET "1" "April 2022" "particl-wallet v0.21.2.8" "User Commands"
+.TH PARTICL-WALLET "1" "April 2022" "particl-wallet v0.21.2.9" "User Commands"
 .SH NAME
-particl-wallet  manual page for particl-wallet v0.21.2.8
+particl-wallet  manual page for particl-wallet v0.21.2.9
 .SH DESCRIPTION
-Particl Core particlwallet version v0.21.2.8
+Particl Core particlwallet version v0.21.2.9
 .PP
 particlwallet is an offline tool for creating and interacting with Particl Core wallet files.
 By default particlwallet will act on wallets in the default mainnet wallet directory in the datadir.
diff --git a/doc/man/particld.1 b/doc/man/particld.1
index 02ccd315a6..56c25dd8af 100644
--- a/doc/man/particld.1
+++ b/doc/man/particld.1
@@ -1,12 +1,12 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
-.TH PARTICLD "1" "April 2022" "particld v0.21.2.8" "User Commands"
+.TH PARTICLD "1" "April 2022" "particld v0.21.2.9" "User Commands"
 .SH NAME
-particld  manual page for particld v0.21.2.8
+particld  manual page for particld v0.21.2.9
 .SH SYNOPSIS
 .B particld
 [\fI\,options\/\fR]                     \fI\,Start Particl Core\/\fR
 .SH DESCRIPTION
-Particl Core version v0.21.2.8
+Particl Core version v0.21.2.9
 .SH OPTIONS
 .HP
 ?
@@ -34,6 +34,10 @@ testnet:
 signet:
 0000002a1de0f46379358c1fd09906f7ac59adf3712323ed90eb59e4c183c020)
 .HP
+\fBautomaticbans\fR
+.IP
+Whether to automatically ban misbehaving nodes. (default: 1)
+.HP
 \fBbalancesindex\fR
 .IP
 Maintain a balances index per block (default: 0)
diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index 07babaa724..7279d33cc2 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -5,6 +5,8 @@
 - smsg: The smsgdb is periodically compacted.
 - smsg: Added pagination to smsginbox and smsgoutbox.
 - smsg: Shutdown smsgdb even if smsg is not initialised.
+- net: Ban nodes that have been discouraged 5 times.
+- net: All misbehaviour increments the persistent counter.
 
 
 0.21.2.8

From 083d52c6bcca93adec3271d9effd488f034c789e Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Thu, 19 May 2022 21:34:54 +0200
Subject: [PATCH 38/57] contrib: Avoid sha256sum on freebsd 13.1

---
 contrib/install_db4.sh | 10 ++++------
 1 file changed, 4 insertions(+), 6 deletions(-)

diff --git a/contrib/install_db4.sh b/contrib/install_db4.sh
index e9130a21de..dda8d001f0 100755
--- a/contrib/install_db4.sh
+++ b/contrib/install_db4.sh
@@ -32,14 +32,12 @@ check_exists() {
 sha256_check() {
   # Args: <sha256_hash> <filename>
   #
-  if check_exists sha256sum; then
+  if [ "$(uname)" = "FreeBSD" ]; then
+    sha256 -c "${1}" "${2}"
+  elif check_exists sha256sum; then
     echo "${1}  ${2}" | sha256sum -c
   elif check_exists sha256; then
-    if [ "$(uname)" = "FreeBSD" ]; then
-      sha256 -c "${1}" "${2}"
-    else
-      echo "${1}  ${2}" | sha256 -c
-    fi
+    echo "${1}  ${2}" | sha256 -c
   else
     echo "${1}  ${2}" | shasum -a 256 -c
   fi

From 37aba5f02c9639933b2fe03e5071921908dd6722 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Fri, 3 Jun 2022 22:26:23 +0200
Subject: [PATCH 39/57] rpc: Added pending_depth to getcoldstakinginfo

---
 doc/release-notes-particl.md                |  9 ++++++
 src/wallet/rpchdwallet.cpp                  | 36 ++++++++++++---------
 test/functional/feature_part_coldstaking.py |  5 +--
 test/functional/feature_part_pos.py         | 10 +++++-
 test/functional/wallet_part_multiwallet.py  |  6 ++--
 5 files changed, 44 insertions(+), 22 deletions(-)

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index 7279d33cc2..1271eadcb5 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -1,4 +1,13 @@
 
+0.21.2.10
+==============
+
+- rpc: Added pending_depth to getcoldstakinginfo
+  - getbalances staked shows immature coins unspendable before maturing after 100 blocks (COINBASE_MATURITY)
+  - getcoldstakinginfo pending_depth shows coins unstakable until after 225 blocks (nStakeMinConfirmations)
+- rpc: Added minstakeabledepth to getstakinginfo
+
+
 0.21.2.9
 ==============
 
diff --git a/src/wallet/rpchdwallet.cpp b/src/wallet/rpchdwallet.cpp
index c139b53f14..0f1a81dc02 100644
--- a/src/wallet/rpchdwallet.cpp
+++ b/src/wallet/rpchdwallet.cpp
@@ -4365,6 +4365,7 @@ static UniValue getstakinginfo(const JSONRPCRequest &request)
                         {RPCResult::Type::STR_AMOUNT, "wallettreasurydonationpercent", "User set percentage of the block reward ceded to the treasury"},
                         {RPCResult::Type::STR_AMOUNT, "treasurydonationpercent", "Network enforced percentage of the block reward ceded to the treasury"},
                         {RPCResult::Type::STR_AMOUNT, "minstakeablevalue", "The minimum value for an output to attempt staking in " + CURRENCY_UNIT},
+                        {RPCResult::Type::NUM, "minstakeabledepth", "Minimum depth required in the chain for an output to stake"},
                         {RPCResult::Type::NUM, "currentblocksize", "The last approximate block size in bytes"},
                         {RPCResult::Type::NUM, "currentblockweight", "The last block weight"},
                         {RPCResult::Type::NUM, "currentblocktx", "The number of transactions in the last block"},
@@ -4452,8 +4453,11 @@ static UniValue getstakinginfo(const JSONRPCRequest &request)
         obj.pushKV("treasurydonationpercent", pTreasuryFundSettings->nMinTreasuryStakePercent);
     }
 
-    obj.pushKV("minstakeablevalue", pwallet->m_min_stakeable_value);
+    obj.pushKV("minstakeablevalue", ValueFromAmount(pwallet->m_min_stakeable_value));
 
+    int nHeight = pwallet->chain().getHeightInt();
+    int nRequiredDepth = std::min((int)(Params().GetStakeMinConfirmations() - 1), (int)(nHeight / 2));
+    obj.pushKV("minstakeabledepth", nRequiredDepth);
     obj.pushKV("currentblocksize", (uint64_t)nLastBlockSize);
     obj.pushKV("currentblocktx", (uint64_t)nLastBlockTx);
 
@@ -4486,10 +4490,11 @@ static UniValue getcoldstakinginfo(const JSONRPCRequest &request)
                 RPCResult{
                     RPCResult::Type::OBJ, "", "", {
                         {RPCResult::Type::BOOL, "enabled", "If a valid coldstakingaddress is loaded or not on this wallet"},
-                        {RPCResult::Type::STR, "coldstaking_extkey_id", "The id of the current coldstakingaddress"},
+                        {RPCResult::Type::STR, "coldstaking_extkey_id", /*optional=*/true, "The id of the current coldstakingaddress"},
                         {RPCResult::Type::STR_AMOUNT, "coin_in_stakeable_script", "Current amount of coin in scripts stakeable by this wallet"},
                         {RPCResult::Type::STR_AMOUNT, "coin_in_coldstakeable_script", "Current amount of coin in scripts stakeable by the wallet with the coldstakingaddress"},
                         {RPCResult::Type::STR_AMOUNT, "percent_in_coldstakeable_script", "Percentage of coin in coldstakeable scripts"},
+                        {RPCResult::Type::STR_AMOUNT, "pending_depth", "Amount of coin in this wallet that will stake once it reaches the required depth"},
                         {RPCResult::Type::STR_AMOUNT, "currently_staking", "Amount of coin estimated to be currently staking by this wallet"},
                 }},
                 RPCExamples{
@@ -4526,16 +4531,13 @@ static UniValue getcoldstakinginfo(const JSONRPCRequest &request)
         cctl.m_include_immature = true;
         LOCK(pwallet->cs_wallet);
         nHeight = ::ChainActive().Tip()->nHeight;
-        nRequiredDepth = std::min((int)(Params().GetStakeMinConfirmations()-1), (int)(nHeight / 2));
+        nRequiredDepth = std::min((int)(Params().GetStakeMinConfirmations() - 1), (int)(nHeight / 2));
         pwallet->AvailableCoins(vecOutputs, !include_unsafe, &cctl, nMinimumAmount, nMaximumAmount, nMinimumSumAmount, nMaximumCount);
     }
 
     LOCK(pwallet->cs_wallet);
 
-    CAmount nStakeable = 0;
-    CAmount nColdStakeable = 0;
-    CAmount nWalletStaking = 0;
-
+    CAmount nStakeable{0}, nColdStakeable{0}, nWalletStaking{0}, nWalletPendingDepth{0};
     CKeyID keyID;
     CScript coinstakePath;
     for (const auto &out : vecOutputs) {
@@ -4551,8 +4553,8 @@ static UniValue getcoldstakinginfo(const JSONRPCRequest &request)
         if (scriptPubKey->IsPayToPublicKeyHash256_CS() || scriptPubKey->IsPayToScriptHash256_CS() || scriptPubKey->IsPayToScriptHash_CS()) {
             // Show output on both the spending and staking wallets
             if (!out.fSpendable) {
-                if (!particl::ExtractStakingKeyID(*scriptPubKey, keyID)
-                    || !pwallet->HaveKey(keyID)) {
+                if (!particl::ExtractStakingKeyID(*scriptPubKey, keyID) ||
+                    !pwallet->HaveKey(keyID)) {
                     continue;
                 }
             }
@@ -4561,23 +4563,24 @@ static UniValue getcoldstakinginfo(const JSONRPCRequest &request)
             continue;
         }
 
-        if (out.nDepth < nRequiredDepth) {
-            continue;
-        }
-
         if (!particl::ExtractStakingKeyID(*scriptPubKey, keyID)) {
             continue;
         }
+
         if (pwallet->HaveKey(keyID)) {
-            nWalletStaking += nValue;
+            if (out.nDepth < nRequiredDepth) {
+                nWalletPendingDepth += nValue;
+            } else {
+                nWalletStaking += nValue;
+            }
         }
     }
 
     bool fEnabled = false;
     UniValue jsonSettings;
     CBitcoinAddress addrColdStaking;
-    if (pwallet->GetSetting("changeaddress", jsonSettings)
-        && jsonSettings["coldstakingaddress"].isStr()) {
+    if (pwallet->GetSetting("changeaddress", jsonSettings) &&
+        jsonSettings["coldstakingaddress"].isStr()) {
         std::string sAddress;
         try { sAddress = jsonSettings["coldstakingaddress"].get_str();
         } catch (std::exception &e) {
@@ -4604,6 +4607,7 @@ static UniValue getcoldstakinginfo(const JSONRPCRequest &request)
     CAmount nTotal = nColdStakeable + nStakeable;
     obj.pushKV("percent_in_coldstakeable_script",
         UniValue(UniValue::VNUM, strprintf("%.2f", nTotal == 0 ? 0.0 : (nColdStakeable * 10000 / nTotal) / 100.0)));
+    obj.pushKV("pending_depth", ValueFromAmount(nWalletPendingDepth));
     obj.pushKV("currently_staking", ValueFromAmount(nWalletStaking));
 
     return obj;
diff --git a/test/functional/feature_part_coldstaking.py b/test/functional/feature_part_coldstaking.py
index 09e36d9530..ff0a1d8975 100755
--- a/test/functional/feature_part_coldstaking.py
+++ b/test/functional/feature_part_coldstaking.py
@@ -91,7 +91,9 @@ def run_test(self):
         txid1 = nodes[0].sendtoaddress(addr2_1, 100)
         tx = nodes[0].getrawtransaction(txid1, True)
 
-        assert_equal(nodes[0].getcoldstakinginfo()['coin_in_coldstakeable_script'], Decimal('9899.999572'))
+        cs_info = nodes[0].getcoldstakinginfo()
+        assert_equal(cs_info['coin_in_coldstakeable_script'], Decimal('9899.999572'))
+        assert_equal(cs_info['coin_in_stakeable_script'], cs_info['currently_staking'] + cs_info['pending_depth'])
 
         hashCoinstake = ''
         hashOther = ''
@@ -233,7 +235,6 @@ def run_test(self):
         assert(fFound)
 
         assert(self.wait_for_mempool(nodes[1], txid3))
-
         assert(nodes[1].extkey('key', 'xBDBWFLeYrbBhPRSKHzVwN61rwUGwCXvUB', 'true')['num_derives'] == '3')
 
         # Test stake to coldstakingchangeaddress
diff --git a/test/functional/feature_part_pos.py b/test/functional/feature_part_pos.py
index 39a5f7d4a0..2a408b5d4f 100755
--- a/test/functional/feature_part_pos.py
+++ b/test/functional/feature_part_pos.py
@@ -182,7 +182,10 @@ def run_test(self):
         assert(abs(header_before['moneysupply'] - (header_after['moneysupply'] + decimal.Decimal(100.0) - stakereward)) < 0.00000002)
 
         self.log.info('Test clearing rewardaddress')
-        ro = nodes[0].walletsettings('stakingoptions', {})
+        # Set minstakeablevalue above 1.0
+        nodes[0].walletsettings('stakingoptions', {'minstakeablevalue': 2.0})
+        stake_info = nodes[0].getstakinginfo()
+        assert(stake_info['minstakeablevalue'] == 2.0)
 
         self.stakeBlocks(1)
         coinstakehash = nodes[0].getblock(nodes[0].getbestblockhash())['tx'][0]
@@ -218,6 +221,11 @@ def run_test(self):
                 break
         assert(found_stake_kernel)
 
+        self.log.info('Test that getcoldstakinginfo coin_in_stakeable_script == currently_staking + pending_depth')
+        cs_info = nodes[0].getcoldstakinginfo()
+        assert(cs_info['pending_depth'] > 0.0)
+        assert(cs_info['coin_in_stakeable_script'] == cs_info['currently_staking'] + cs_info['pending_depth'])
+
 
 if __name__ == '__main__':
     PosTest().main()
diff --git a/test/functional/wallet_part_multiwallet.py b/test/functional/wallet_part_multiwallet.py
index 2472c96456..fe84595226 100755
--- a/test/functional/wallet_part_multiwallet.py
+++ b/test/functional/wallet_part_multiwallet.py
@@ -108,11 +108,11 @@ def run_test(self):
         w4_stakinginfo = w4.getstakinginfo()
         w5_stakinginfo = w5.getstakinginfo()
         w6_stakinginfo = w6.getstakinginfo()
-        assert(w4_stakinginfo['minstakeablevalue'] == 1)
+        assert(float(w4_stakinginfo['minstakeablevalue']) == 0.00000001)
         assert(w4_stakinginfo['weight'] == 199000000)
-        assert(w5_stakinginfo['minstakeablevalue'] == 100000000)
+        assert(w5_stakinginfo['minstakeablevalue'] == 1.0)
         assert(w5_stakinginfo['weight'] == 100000000)
-        assert(w6_stakinginfo['minstakeablevalue'] == 1)
+        assert(float(w6_stakinginfo['minstakeablevalue']) == 0.00000001)
         assert(w6_stakinginfo['weight'] == 100000000)
         assert(float(w6.walletsettings('other')['other']['minownedvalue']) == 1.0)
 

From cfb08c342eee277357409b154721e939b34f56cc Mon Sep 17 00:00:00 2001
From: Joan Karadimov <joan.karadimov@gmail.com>
Date: Fri, 22 Oct 2021 01:19:27 +0300
Subject: [PATCH 40/57] refactor: include a missing <limits> header in fs.cpp

... needed for std::numeric_limits<T>::max on WIN32

Github-Pull: #23335
Rebased-From: 077a875d94b51e3c87381133657be98989c8643e
---
 src/fs.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/fs.cpp b/src/fs.cpp
index 3aba47976c..5e1d7af7ab 100644
--- a/src/fs.cpp
+++ b/src/fs.cpp
@@ -16,6 +16,7 @@
 #define NOMINMAX
 #endif
 #include <codecvt>
+#include <limits>
 #include <windows.h>
 #endif
 

From efb9f00f07c7ebf5fac56c464e5dd65d6d9b8457 Mon Sep 17 00:00:00 2001
From: "W. J. van der Laan" <laanwj@protonmail.com>
Date: Mon, 20 Sep 2021 12:19:38 +0200
Subject: [PATCH 41/57] build: Restrict check for CRC32C intrinsic to aarch64

`crc32c`'s hardware accelerated code doesn't handle ARM 32-bit at all.
Make the check in `configure.ac` check for this architecture explicitly.

For the release binaries, the current `configure.ac` check happens
to work: it enables it on aarch64 but disables it for armhf. However
some combination of compiler version and settings might ostensibly cause
this check to succeed on armhf (as reported on IRC). So make the 64-bit
platform requirement explicit.

Github-Pull: #23045
Rebased-From: f2747d1602ec4e1128356b861b2167daf66a845b
---
 configure.ac | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index 6df4c1ce09..1454977179 100644
--- a/configure.ac
+++ b/configure.ac
@@ -535,13 +535,17 @@ AX_CHECK_COMPILE_FLAG([-march=armv8-a+crc+crypto],[[ARM_CRC_CXXFLAGS="-march=arm
 
 TEMP_CXXFLAGS="$CXXFLAGS"
 CXXFLAGS="$CXXFLAGS $ARM_CRC_CXXFLAGS"
-AC_MSG_CHECKING(for ARM CRC32 intrinsics)
+AC_MSG_CHECKING(for AArch64 CRC32 intrinsics)
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
     #include <arm_acle.h>
     #include <arm_neon.h>
   ]],[[
+#ifdef __aarch64__
     __crc32cb(0, 0); __crc32ch(0, 0); __crc32cw(0, 0); __crc32cd(0, 0);
     vmull_p64(0, 0);
+#else
+#error "crc32c library does not support hardware acceleration on 32-bit ARM"
+#endif
   ]])],
  [ AC_MSG_RESULT(yes); enable_arm_crc=yes; ],
  [ AC_MSG_RESULT(no)]

From 029073feae4595c6d3a9c805c5caffdf82516230 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Mon, 20 Jun 2022 15:36:12 +0200
Subject: [PATCH 42/57] tests: Test listsinceblock in Particl mode

---
 src/wallet/rpcwallet.cpp              | 10 ++++++++++
 test/functional/feature_part_anon.py  | 12 ++++++++++++
 test/functional/feature_part_blind.py | 15 +++++++++++++--
 3 files changed, 35 insertions(+), 2 deletions(-)

diff --git a/src/wallet/rpcwallet.cpp b/src/wallet/rpcwallet.cpp
index 69295e9e46..58d0a57bc3 100644
--- a/src/wallet/rpcwallet.cpp
+++ b/src/wallet/rpcwallet.cpp
@@ -1989,6 +1989,10 @@ static RPCHelpMan listtransactions()
                         {
                             {RPCResult::Type::BOOL, "involvesWatchonly", "Only returns true if imported addresses were involved in transaction."},
                             {RPCResult::Type::STR, "address", "The particl address of the transaction."},
+                            {RPCResult::Type::STR, "account", /*optional=*/true, "Alias of label."},
+                            {RPCResult::Type::STR, "stealth_address", /*optional=*/true, "The stealth address the transaction was received on."},
+                            {RPCResult::Type::STR, "coldstake_address", /*optional=*/true, "The address the transaction is staking on."},
+                            {RPCResult::Type::STR, "type", /*optional=*/true, "anon/blind/standard."},
                             {RPCResult::Type::STR, "category", "The transaction category.\n"
                                 "\"send\"                  Transactions sent.\n"
                                 "\"receive\"               Non-coinbase transactions received.\n"
@@ -2001,6 +2005,7 @@ static RPCHelpMan listtransactions()
                             {RPCResult::Type::NUM, "vout", "the vout value"},
                             {RPCResult::Type::STR_AMOUNT, "fee", "The amount of the fee in " + CURRENCY_UNIT + ". This is negative and only available for the\n"
                                  "'send' category of transactions."},
+                            {RPCResult::Type::STR_AMOUNT, "reward", /*optional=*/true, "The reward if the transaction is a coinstake."},
                         },
                         TransactionDescriptionString()),
                         {
@@ -2142,6 +2147,10 @@ static RPCHelpMan listsinceblock()
                             {
                                 {RPCResult::Type::BOOL, "involvesWatchonly", "Only returns true if imported addresses were involved in transaction."},
                                 {RPCResult::Type::STR, "address", "The particl address of the transaction."},
+                                {RPCResult::Type::STR, "account", /*optional=*/true, "Alias of label."},
+                                {RPCResult::Type::STR, "stealth_address", /*optional=*/true, "The stealth address the transaction was received on."},
+                                {RPCResult::Type::STR, "coldstake_address", /*optional=*/true, "The address the transaction is staking on."},
+                                {RPCResult::Type::STR, "type", /*optional=*/true, "anon/blind/standard."},
                                 {RPCResult::Type::STR, "category", "The transaction category.\n"
                                     "\"send\"                  Transactions sent.\n"
                                     "\"receive\"               Non-coinbase transactions received.\n"
@@ -2153,6 +2162,7 @@ static RPCHelpMan listsinceblock()
                                 {RPCResult::Type::NUM, "vout", "the vout value"},
                                 {RPCResult::Type::STR_AMOUNT, "fee", "The amount of the fee in " + CURRENCY_UNIT + ". This is negative and only available for the\n"
                                      "'send' category of transactions."},
+                                {RPCResult::Type::STR_AMOUNT, "reward", /*optional=*/true, "The reward if the transaction is a coinstake."},
                             },
                             TransactionDescriptionString()),
                             {
diff --git a/test/functional/feature_part_anon.py b/test/functional/feature_part_anon.py
index a6bdbf463a..dded8a300d 100755
--- a/test/functional/feature_part_anon.py
+++ b/test/functional/feature_part_anon.py
@@ -75,6 +75,18 @@ def run_test(self):
         assert(self.wait_for_mempool(nodes[0], txnHash))
         self.stakeBlocks(1)
 
+        self.log.info('Test listsinceblock')
+        block2_hash = nodes[0].getblockhash(2)
+        rv = nodes[0].listsinceblock(block2_hash)
+        assert(len(rv['transactions']) == 2)
+        found_tx = False
+        for txn in rv['transactions']:
+            if txn['txid'] == txnHash:
+                found_tx = True
+            else:
+                assert(txn['category'] == 'stake')
+        assert(found_tx is True)
+
         ro = nodes[1].getblock(nodes[1].getblockhash(3))
         for txnHash in txnHashes:
             assert(txnHash in ro['tx'])
diff --git a/test/functional/feature_part_blind.py b/test/functional/feature_part_blind.py
index f7d411d802..b71cea6e36 100755
--- a/test/functional/feature_part_blind.py
+++ b/test/functional/feature_part_blind.py
@@ -1,5 +1,5 @@
 #!/usr/bin/env python3
-# Copyright (c) 2017-2020 The Particl Core developers
+# Copyright (c) 2017-2022 The Particl Core developers
 # Distributed under the MIT software license, see the accompanying
 # file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
@@ -147,7 +147,6 @@ def run_test(self):
         txnHash2 = nodes[0].sendtoaddress(addrTo0_2, availableBalance, '', '', True, 'node0 spend remaining')
         txnHashes.append(txnHash2)
 
-
         nodes[0].syncwithvalidationinterfacequeue()
         assert(isclose(nodes[0].getwalletinfo()['total_balance'], 99996.10316311))
         assert(isclose(nodes[1].getwalletinfo()['blind_balance'], 2.69580200))
@@ -156,6 +155,18 @@ def run_test(self):
         assert(len(unspent[0]['stealth_address']))
         assert(len(unspent[0]['label']))
 
+        self.log.info('Test listsinceblock')
+        block2_hash = nodes[0].getblockhash(2)
+        rv = nodes[2].listsinceblock(block2_hash)
+        assert(len(rv['transactions']) == 4)
+        expect_hashes = (txnHash3, txnHash4, txnHash5)
+        count_hashes = [0] * 3
+        for txn in rv['transactions']:
+            for i, expect_hash in enumerate(expect_hashes):
+                if txn['txid'] == expect_hash:
+                    count_hashes[i] += 1
+        assert(count_hashes == [1, 1, 2])
+
         self.log.info('Test lockunspent')
         unspent = nodes[1].listunspentblind(minconf=0)
         assert(nodes[1].lockunspent(False, [unspent[0]]) == True)

From 8a644caea6ec4c6cd95cfbf4d6e7d403ebd83485 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Wed, 22 Jun 2022 00:49:29 +0200
Subject: [PATCH 43/57] wallet: Only mark anon/blind tx outputs as change if
 wallet owns inputs.

---
 doc/release-notes-particl.md         |   1 +
 src/wallet/hdwallet.cpp              | 381 ++++++++++++++-------------
 src/wallet/hdwallet.h                |   7 +-
 src/wallet/hdwallettypes.h           |  53 ++--
 test/functional/feature_part_anon.py |  35 ++-
 5 files changed, 256 insertions(+), 221 deletions(-)

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index 1271eadcb5..93313794be 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -6,6 +6,7 @@
   - getbalances staked shows immature coins unspendable before maturing after 100 blocks (COINBASE_MATURITY)
   - getcoldstakinginfo pending_depth shows coins unstakable until after 225 blocks (nStakeMinConfirmations)
 - rpc: Added minstakeabledepth to getstakinginfo
+- wallet: Only mark anon/blind tx outputs as change if wallet owns inputs.
 
 
 0.21.2.9
diff --git a/src/wallet/hdwallet.cpp b/src/wallet/hdwallet.cpp
index 4820ddf43c..c9321d0b22 100644
--- a/src/wallet/hdwallet.cpp
+++ b/src/wallet/hdwallet.cpp
@@ -84,6 +84,46 @@ static bool ExtractStealthPrefix(const std::vector<uint8_t> &vData, uint32_t &pr
     return false;
 }
 
+static void AppendKey(const CHDWallet *pw, CKey &key, uint32_t nChild, UniValue &derivedKeys) EXCLUSIVE_LOCKS_REQUIRED(pw->cs_wallet)
+{
+    UniValue keyobj(UniValue::VOBJ);
+
+    CKeyID idk = key.GetPubKey().GetID();
+
+    bool fHardened = IsHardened(nChild);
+    ClearHardenedBit(nChild);
+    keyobj.pushKV("path", ToString((int64_t)nChild) + (fHardened ? "'" : ""));
+    keyobj.pushKV("address", EncodeDestination(PKHash(idk)));
+    keyobj.pushKV("privkey", CBitcoinSecret(key).ToString());
+
+    std::map<CTxDestination, CAddressBookData>::const_iterator mi = pw->m_address_book.find(PKHash(idk));
+    if (mi != pw->m_address_book.end()) {
+        // TODO: confirm vPath?
+        keyobj.pushKV("label", mi->second.GetLabel());
+        if (!mi->second.purpose.empty()) {
+            keyobj.pushKV("purpose", mi->second.purpose);
+        }
+        UniValue objDestData(UniValue::VOBJ);
+        for (const auto &pair : mi->second.destdata) {
+            objDestData.pushKV(pair.first, pair.second);
+        }
+        if (objDestData.size() > 0) {
+            keyobj.pushKV("destdata", objDestData);
+        }
+    }
+    derivedKeys.push_back(keyobj);
+    return;
+};
+
+static bool HaveAnonOutputs(std::vector<CTempRecipient> &vecSend)
+{
+    for (const auto &r : vecSend)
+    if (r.nType == OUTPUT_RINGCT) {
+        return true;
+    }
+    return false;
+}
+
 int CHDWallet::Finalise()
 {
     LOCK(cs_wallet);
@@ -380,37 +420,6 @@ bool CHDWallet::UnsetWalletFlagRV(CHDWalletDB *pwdb, uint64_t flag)
     return pwdb->WriteWalletFlags(m_wallet_flags);
 }
 
-static void AppendKey(const CHDWallet *pw, CKey &key, uint32_t nChild, UniValue &derivedKeys) EXCLUSIVE_LOCKS_REQUIRED(pw->cs_wallet)
-{
-    UniValue keyobj(UniValue::VOBJ);
-
-    CKeyID idk = key.GetPubKey().GetID();
-
-    bool fHardened = IsHardened(nChild);
-    ClearHardenedBit(nChild);
-    keyobj.pushKV("path", ToString((int64_t)nChild) + (fHardened ? "'" : ""));
-    keyobj.pushKV("address", EncodeDestination(PKHash(idk)));
-    keyobj.pushKV("privkey", CBitcoinSecret(key).ToString());
-
-    std::map<CTxDestination, CAddressBookData>::const_iterator mi = pw->m_address_book.find(PKHash(idk));
-    if (mi != pw->m_address_book.end()) {
-        // TODO: confirm vPath?
-        keyobj.pushKV("label", mi->second.GetLabel());
-        if (!mi->second.purpose.empty()) {
-            keyobj.pushKV("purpose", mi->second.purpose);
-        }
-        UniValue objDestData(UniValue::VOBJ);
-        for (const auto &pair : mi->second.destdata) {
-            objDestData.pushKV(pair.first, pair.second);
-        }
-        if (objDestData.size() > 0) {
-            keyobj.pushKV("destdata", objDestData);
-        }
-    }
-    derivedKeys.push_back(keyobj);
-    return;
-};
-
 extern int ListLooseExtKeys(CHDWallet *pwallet, int nShowKeys, UniValue &ret, size_t &nKeys);
 extern int ListAccountExtKeys(CHDWallet *pwallet, int nShowKeys, UniValue &ret, size_t &nKeys);
 extern int ListLooseStealthAddresses(UniValue &arr, const CHDWallet *pwallet, bool fShowSecrets, bool fAddressBookInfo, bool show_pubkeys=false, bool bech32=false);
@@ -1743,8 +1752,8 @@ bool CHDWallet::DelAddressBook(const CTxDestination &address)
         }
     }
 
-    if (tIsMine == ISMINE_SPENDABLE
-        && address.type() == typeid(PKHash)) {
+    if (tIsMine == ISMINE_SPENDABLE &&
+        address.type() == typeid(PKHash)) {
         CKeyID id = ToKeyID(boost::get<PKHash>(address));
         smsgModule.WalletKeyChanged(id, "", CT_DELETED);
     }
@@ -3343,71 +3352,6 @@ int CHDWallet::ExpandTempRecipients(std::vector<CTempRecipient> &vecSend, CStore
     return 0;
 };
 
-void SetCTOutVData(std::vector<uint8_t> &vData, CPubKey &pkEphem, const CTempRecipient &r)
-{
-    vData.resize((r.nStealthPrefix > 0 ? 38 : 33));
-
-    memcpy(&vData[0], pkEphem.begin(), 33);
-    if (r.nStealthPrefix > 0) {
-        vData[33] = DO_STEALTH_PREFIX;
-        uint32_t tmp = htole32(r.nStealthPrefix);
-        memcpy(&vData[34], &tmp, 4);
-    }
-};
-
-int CreateOutput(OUTPUT_PTR<CTxOutBase> &txbout, CTempRecipient &r, std::string &sError)
-{
-    switch (r.nType) {
-        case OUTPUT_DATA:
-            txbout = MAKE_OUTPUT<CTxOutData>(r.vData);
-            break;
-        case OUTPUT_STANDARD:
-            txbout = MAKE_OUTPUT<CTxOutStandard>(r.nAmount, r.scriptPubKey);
-            break;
-        case OUTPUT_CT:
-            {
-            txbout = MAKE_OUTPUT<CTxOutCT>();
-            CTxOutCT *txout = (CTxOutCT*)txbout.get();
-
-            if (r.fNonceSet) {
-                if (r.vData.size() < 33) {
-                    return errorN(1, sError, __func__, "Missing ephemeral value, vData size %d", r.vData.size());
-                }
-                txout->vData = r.vData;
-            } else {
-                CPubKey pkEphem = r.sEphem.GetPubKey();
-                SetCTOutVData(txout->vData, pkEphem, r);
-            }
-
-            txout->scriptPubKey = r.scriptPubKey;
-            }
-            break;
-        case OUTPUT_RINGCT:
-            {
-            txbout = MAKE_OUTPUT<CTxOutRingCT>();
-            CTxOutRingCT *txout = (CTxOutRingCT*)txbout.get();
-
-            txout->pk = CCmpPubKey(r.pkTo);
-
-            if (r.fNonceSet) {
-                if (r.vData.size() < 33) {
-                    return errorN(1, sError, __func__, "Missing ephemeral value, vData size %d", r.vData.size());
-                }
-                txout->vData = r.vData;
-            } else {
-                CPubKey pkEphem = r.sEphem.GetPubKey();
-                SetCTOutVData(txout->vData, pkEphem, r);
-            }
-
-            }
-            break;
-        default:
-            return errorN(1, sError, __func__, "Unknown output type %d", r.nType);
-    }
-
-    return 0;
-};
-
 int CHDWallet::AddCTData(const CCoinControl *coinControl, CTxOutBase *txout, CTempRecipient &r, std::string &sError)
 {
     secp256k1_pedersen_commitment *pCommitment = txout->GetPCommitment();
@@ -3545,15 +3489,6 @@ int CHDWallet::PostProcessTempRecipients(std::vector<CTempRecipient> &vecSend)
     return 0;
 };
 
-static bool HaveAnonOutputs(std::vector<CTempRecipient> &vecSend)
-{
-    for (const auto &r : vecSend)
-    if (r.nType == OUTPUT_RINGCT) {
-        return true;
-    }
-    return false;
-}
-
 bool CheckOutputValue(interfaces::Chain& chain, const CTempRecipient &r, const CTxOutBase *txbout, CAmount nFeeRet, std::string &sError)
 {
     if ((r.nType == OUTPUT_STANDARD
@@ -9048,6 +8983,7 @@ bool CHDWallet::CommitTransaction(CWalletTx &wtxNew, CTransactionRecord &rtx, Tx
     CWalletTx *wtx_broadcast = nullptr;
     CWalletTx::Confirmation confirm;
     if (is_record) {
+        rtx.nFlags |= ORF_FROM;
         AddToRecord(rtx, *wtxNew.tx, confirm);
         wtx_broadcast = &wtxNew;
     } else {
@@ -9568,7 +9504,6 @@ bool CHDWallet::ProcessLockedBlindedOutputs()
         }
 
         nProcessed++;
-
         ssKey >> op;
 
         int rv = pcursor->del(0);
@@ -9592,8 +9527,7 @@ bool CHDWallet::ProcessLockedBlindedOutputs()
 
         const auto &txout = stx.tx->vpout[op.n];
 
-        COutputRecord rout;
-        COutputRecord *pout = rtx.GetOutput(op.n);
+        COutputRecord rout, *pout = rtx.GetOutput(op.n);
 
         bool fHave = false;
         if (pout) { // Have output recorded already, still need to check if owned
@@ -9604,17 +9538,18 @@ bool CHDWallet::ProcessLockedBlindedOutputs()
 
         uint32_t n = 0;
         bool fUpdated = false;
+        bool is_from_me = rtx.FlagSet(ORF_FROM);
         pout->n = op.n;
         switch (txout->nVersion) {
             case OUTPUT_CT:
-                if (OwnBlindOut(&wdb, op.hash, (CTxOutCT*)txout.get(), nullptr, n, *pout, stx, fUpdated) &&
+                if (OwnBlindOut(&wdb, op.hash, (CTxOutCT*)txout.get(), nullptr, n, *pout, stx, fUpdated, is_from_me) &&
                     !fHave) {
                     fUpdated = true;
                     rtx.InsertOutput(*pout);
                 }
                 break;
             case OUTPUT_RINGCT:
-                if (OwnAnonOut(&wdb, op.hash, (CTxOutRingCT*)txout.get(), nullptr, n, *pout, stx, fUpdated) &&
+                if (OwnAnonOut(&wdb, op.hash, (CTxOutRingCT*)txout.get(), nullptr, n, *pout, stx, fUpdated, is_from_me) &&
                     !fHave) {
                     fUpdated = true;
                     rtx.InsertOutput(*pout);
@@ -9630,7 +9565,7 @@ bool CHDWallet::ProcessLockedBlindedOutputs()
 
         if (fUpdated) {
             // If txn has change, it must have been sent by this wallet
-            if (rtx.HaveChange()) {
+            if (is_from_me || rtx.HaveChange()) {
                 ProcessPlaceholder(*stx.tx.get(), rtx);
             }
 
@@ -10032,13 +9967,13 @@ int CHDWallet::CheckForStealthAndNarration(const CTxOutBase *pb, const CTxOutDat
         if (vData.size() < 2) {
             return -1; // error
         }
-        sNarr = std::string(vData.begin()+1, vData.end());
+        sNarr = std::string(vData.begin() + 1, vData.end());
         return 1;
     }
 
     if (vData[0] == DO_STEALTH) {
-        if (vData.size() < 34
-            || !pb->IsStandardOutput()) {
+        if (vData.size() < 34 ||
+            !pb->IsStandardOutput()) {
             return -1; // error
         }
 
@@ -10050,8 +9985,8 @@ int CHDWallet::CheckForStealthAndNarration(const CTxOutBase *pb, const CTxOutDat
 
         const CTxOutStandard *so = (CTxOutStandard*)pb;
         CTxDestination address;
-        if (!ExtractDestination(so->scriptPubKey, address)
-            || address.type() != typeid(PKHash)) {
+        if (!ExtractDestination(so->scriptPubKey, address) ||
+            address.type() != typeid(PKHash)) {
             //WalletLogPrintf("%s: ExtractDestination failed.\n",  __func__);
             return -1;
         }
@@ -10468,6 +10403,9 @@ bool CHDWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, CWalletTx::
 
             if (fExisted || fIsMine || fIsFromMe) {
                 CTransactionRecord rtx;
+                if (fIsFromMe) {
+                    rtx.nFlags |= ORF_FROM;
+                }
                 bool rv = AddToRecord(rtx, tx, confirm, false);
 
                 if (!confirm.hashBlock.IsNull()) {
@@ -10608,7 +10546,8 @@ const CWalletTx *CHDWallet::GetWalletOrTempTx(const uint256& hash, const CTransa
     return GetWalletTx(hash);
 };
 
-int CHDWallet::OwnStandardOut(const CTxOutStandard *pout, const CTxOutData *pdata, COutputRecord &rout, bool &fUpdated)
+int CHDWallet::OwnStandardOut(const CTxOutStandard *pout, const CTxOutData *pdata,
+    COutputRecord &rout, bool &fUpdated, bool is_from_me)
 {
     if (pout->nValue < m_min_owned_value) {
         return 0;
@@ -10634,7 +10573,8 @@ int CHDWallet::OwnStandardOut(const CTxOutStandard *pout, const CTxOutData *pdat
         return 0;
     }
 
-    if (pa && pak && pa->nActiveInternal == pak->nParent) { // TODO: could check EKVT_KEY_TYPE
+    if (is_from_me && pa && pak && pa->nActiveInternal == pak->nParent) { // TODO: could check EKVT_KEY_TYPE
+        fUpdated = fUpdated || (!rout.FlagSet(ORF_CHANGE) || !rout.FlagSet(ORF_FROM));
         rout.nFlags |= ORF_CHANGE | ORF_FROM;
     }
 
@@ -10660,47 +10600,8 @@ int CHDWallet::OwnStandardOut(const CTxOutStandard *pout, const CTxOutData *pdat
     return 1;
 };
 
-
-void ExtractNarration(const uint256 &nonce, const std::vector<uint8_t> &vData, std::string &sNarr)
-{
-    if (vData.size() < 33) {
-        return;
-    }
-
-    CPubKey pkEphem;
-    pkEphem.Set(vData.begin(), vData.begin() + 33);
-
-    int nNarrOffset = -1;
-    if (vData.size() > 38 && vData[38] == DO_NARR_CRYPT) {
-        nNarrOffset = 39;
-    } else
-    if (vData.size() > 33 && vData[33] == DO_NARR_CRYPT) {
-        nNarrOffset = 34;
-    }
-
-    if (nNarrOffset == -1) {
-        return;
-    }
-
-    size_t lenNarr = vData.size() - nNarrOffset;
-    if (lenNarr < 1 || lenNarr > 32) { // min block size 8?
-        LogPrintf("%s: Invalid narration data length: %d\n", __func__, lenNarr);
-        return;
-    }
-
-    SecMsgCrypter crypter;
-    crypter.SetKey(nonce.begin(), pkEphem.begin());
-
-    std::vector<uint8_t> vchNarr;
-    if (!crypter.Decrypt(&vData[nNarrOffset], lenNarr, vchNarr)) {
-        LogPrintf("%s: Decrypt narration failed.\n", __func__);
-        return;
-    }
-    sNarr = std::string(vchNarr.begin(), vchNarr.end());
-};
-
 int CHDWallet::OwnBlindOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOutCT *pout, const CStoredExtKey *pc, uint32_t &nLastChild,
-    COutputRecord &rout, CStoredTransaction &stx, bool &fUpdated)
+    COutputRecord &rout, CStoredTransaction &stx, bool &fUpdated, bool tx_is_from_me)
 {
     /*
     bool fDecoded = false;
@@ -10726,7 +10627,8 @@ int CHDWallet::OwnBlindOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOu
     if (!(mine & ISMINE_ALL)) {
         return 0;
     }
-    if (pa && pak && pa->nActiveInternal == pak->nParent) {
+    if (tx_is_from_me && pa && pak && pa->nActiveInternal == pak->nParent) {
+        fUpdated = fUpdated || (!rout.FlagSet(ORF_CHANGE) || !rout.FlagSet(ORF_FROM));
         rout.nFlags |= ORF_CHANGE | ORF_FROM;
     }
     if (mine & ISMINE_SPENDABLE) {
@@ -10741,8 +10643,8 @@ int CHDWallet::OwnBlindOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOu
 
     if (IsLocked()) {
         COutPoint op(txhash, rout.n);
-        if ((rout.nFlags & ORF_LOCKED)
-            && !pwdb->HaveLockedAnonOut(op)) {
+        if ((rout.nFlags & ORF_LOCKED) &&
+            !pwdb->HaveLockedAnonOut(op)) {
             rout.nValue = 0;
             fUpdated = true;
             if (LogAcceptCategory(BCLog::HDWALLET)) WalletLogPrintf("%s: Adding locked blind output %s, %d.\n", __func__, txhash.ToString(), rout.n);
@@ -10821,12 +10723,13 @@ int CHDWallet::OwnBlindOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOu
 
         ExtractNarration(nonce, pout->vData, rout.sNarration);
     } else
-    if (nonce.IsNull() || 1 != secp256k1_rangeproof_rewind(secp256k1_ctx_blind,
-        blindOut, &amountOut, msg, &mlen, nonce.begin(),
-        &min_value, &max_value,
-        &pout->commitment, pout->vRangeproof.data(), pout->vRangeproof.size(),
-        nullptr, 0,
-        secp256k1_generator_h)) {
+    if (nonce.IsNull() ||
+        1 != secp256k1_rangeproof_rewind(secp256k1_ctx_blind,
+                blindOut, &amountOut, msg, &mlen, nonce.begin(),
+                &min_value, &max_value,
+                &pout->commitment, pout->vRangeproof.data(), pout->vRangeproof.size(),
+                nullptr, 0,
+                secp256k1_generator_h)) {
         return werrorN(0, "%s: secp256k1_rangeproof_rewind failed.", __func__);
     }
     if ((CAmount)amountOut < m_min_owned_value) {
@@ -10850,7 +10753,7 @@ int CHDWallet::OwnBlindOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOu
 };
 
 int CHDWallet::OwnAnonOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOutRingCT *pout, const CStoredExtKey *pc, uint32_t &nLastChild,
-    COutputRecord &rout, CStoredTransaction &stx, bool &fUpdated)
+    COutputRecord &rout, CStoredTransaction &stx, bool &fUpdated, bool tx_is_from_me)
 {
     CKeyID idk = pout->pk.GetID();
     CKey key;
@@ -10863,7 +10766,8 @@ int CHDWallet::OwnAnonOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOut
     if (!(mine & ISMINE_ALL)) {
         return 0;
     }
-    if (pa && pak && pa->nActiveInternal == pak->nParent) {
+    if (tx_is_from_me && pa && pak && pa->nActiveInternal == pak->nParent) {
+        fUpdated = fUpdated || (!rout.FlagSet(ORF_CHANGE) || !rout.FlagSet(ORF_FROM));
         rout.nFlags |= ORF_CHANGE | ORF_FROM;
     }
     if (mine & ISMINE_SPENDABLE) {
@@ -10960,8 +10864,8 @@ int CHDWallet::OwnAnonOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOut
                 blindOut, &amountOut, msg, &mlen, nonce.begin(),
                 &min_value, &max_value,
                 &pout->commitment, pout->vRangeproof.data(), pout->vRangeproof.size(),
-        nullptr, 0,
-        secp256k1_generator_h)) {
+                nullptr, 0,
+                secp256k1_generator_h)) {
         return werrorN(0, "%s: secp256k1_rangeproof_rewind failed.", __func__);
     }
     if ((CAmount)amountOut < m_min_owned_value) {
@@ -11013,8 +10917,8 @@ bool CHDWallet::ProcessPlaceholder(const CTransaction &tx, CTransactionRecord &r
 
     CAmount nDebit = GetDebit(rtx, ISMINE_ALL);
     CAmount nCredit = rtx.TotalOutput() + rtx.nFee;
-    if (nDebit > 0
-        && nDebit != nCredit) {
+    if (nDebit > 0 &&
+        nDebit != nCredit) {
         LogPrint(BCLog::HDWALLET, "%s %s: Inserting placeholder output: %s, %d\n", GetDisplayName(), __func__, tx.GetHash().ToString(), nDebit - nCredit);
 
         const COutputRecord *pROutChange = rtx.GetChangeOutput();
@@ -11057,6 +10961,11 @@ bool CHDWallet::AddToRecord(CTransactionRecord &rtxIn, const CTransaction &tx, C
     CTransactionRecord &rtx = ret.first->second;
 
     bool fUpdated = false;
+    bool is_from_me = rtxIn.nFlags & ORF_FROM;
+    if (is_from_me && !rtx.FlagSet(ORF_FROM)) {
+        rtx.nFlags |= ORF_FROM;
+        fUpdated = true;
+    }
     if (rtx.blockHash != confirm.hashBlock ||
         rtx.block_height != confirm.block_height ||
         rtx.nIndex != confirm.nIndex) {
@@ -11183,8 +11092,7 @@ bool CHDWallet::AddToRecord(CTransactionRecord &rtxIn, const CTransaction &tx, C
     for (size_t i = 0; i < tx.vpout.size(); ++i) {
         const auto &txout = tx.vpout[i];
 
-        COutputRecord rout;
-        COutputRecord *pout = rtx.GetOutput(i);
+        COutputRecord rout, *pout = rtx.GetOutput(i);
 
         bool fHave = false;
         if (pout) { // Have output recorded already, still need to check if owned
@@ -11205,23 +11113,23 @@ bool CHDWallet::AddToRecord(CTransactionRecord &rtxIn, const CTransaction &tx, C
                     }
                 }
 
-                if (OwnStandardOut((CTxOutStandard*)txout.get(), pdata, *pout, fUpdated)
-                    && !fHave) {
+                if (OwnStandardOut((CTxOutStandard*)txout.get(), pdata, *pout, fUpdated, is_from_me) &&
+                    !fHave) {
                     fUpdated = true;
                     rtx.InsertOutput(*pout);
                 }
                 }
                 break;
             case OUTPUT_CT:
-                if (OwnBlindOut(&wdb, txhash, (CTxOutCT*)txout.get(), pcC, nCTStart, *pout, stx, fUpdated)
-                    && !fHave) {
+                if (OwnBlindOut(&wdb, txhash, (CTxOutCT*)txout.get(), pcC, nCTStart, *pout, stx, fUpdated, is_from_me) &&
+                    !fHave) {
                     fUpdated = true;
                     rtx.InsertOutput(*pout);
                 }
                 break;
             case OUTPUT_RINGCT:
-                if (OwnAnonOut(&wdb, txhash, (CTxOutRingCT*)txout.get(), pcC, nCTStart, *pout, stx, fUpdated)
-                    && !fHave) {
+                if (OwnAnonOut(&wdb, txhash, (CTxOutRingCT*)txout.get(), pcC, nCTStart, *pout, stx, fUpdated, is_from_me) &&
+                    !fHave) {
                     fUpdated = true;
                     rtx.InsertOutput(*pout);
                 }
@@ -11231,10 +11139,10 @@ bool CHDWallet::AddToRecord(CTransactionRecord &rtxIn, const CTransaction &tx, C
                 if (txd->vData.size() < 25 || txd->vData[0] != DO_FUND_MSG) {
                     continue;
                 }
-                size_t n = (txd->vData.size()-1) / 24;
+                size_t n = (txd->vData.size() - 1) / 24;
                 for (size_t k = 0; k < n; ++k) {
                     uint32_t nAmount;
-                    memcpy(&nAmount, &txd->vData[1+k*24+20], 4);
+                    memcpy(&nAmount, &txd->vData[1 + k * 24 + 20], 4);
                     nAmount = le32toh(nAmount);
                     smsg_fees += nAmount;
                     smsgs_funded += 1;
@@ -13979,6 +13887,109 @@ int LoopExtAccountsInDB(CHDWallet *pwallet, bool fInactive, LoopExtKeyCallback &
     return 0;
 };
 
+void SetCTOutVData(std::vector<uint8_t> &vData, CPubKey &pkEphem, const CTempRecipient &r)
+{
+    vData.resize((r.nStealthPrefix > 0 ? 38 : 33));
+
+    memcpy(&vData[0], pkEphem.begin(), 33);
+    if (r.nStealthPrefix > 0) {
+        vData[33] = DO_STEALTH_PREFIX;
+        uint32_t tmp = htole32(r.nStealthPrefix);
+        memcpy(&vData[34], &tmp, 4);
+    }
+};
+
+int CreateOutput(OUTPUT_PTR<CTxOutBase> &txbout, CTempRecipient &r, std::string &sError)
+{
+    switch (r.nType) {
+        case OUTPUT_DATA:
+            txbout = MAKE_OUTPUT<CTxOutData>(r.vData);
+            break;
+        case OUTPUT_STANDARD:
+            txbout = MAKE_OUTPUT<CTxOutStandard>(r.nAmount, r.scriptPubKey);
+            break;
+        case OUTPUT_CT:
+            {
+            txbout = MAKE_OUTPUT<CTxOutCT>();
+            CTxOutCT *txout = (CTxOutCT*)txbout.get();
+
+            if (r.fNonceSet) {
+                if (r.vData.size() < 33) {
+                    return errorN(1, sError, __func__, "Missing ephemeral value, vData size %d", r.vData.size());
+                }
+                txout->vData = r.vData;
+            } else {
+                CPubKey pkEphem = r.sEphem.GetPubKey();
+                SetCTOutVData(txout->vData, pkEphem, r);
+            }
+
+            txout->scriptPubKey = r.scriptPubKey;
+            }
+            break;
+        case OUTPUT_RINGCT:
+            {
+            txbout = MAKE_OUTPUT<CTxOutRingCT>();
+            CTxOutRingCT *txout = (CTxOutRingCT*)txbout.get();
+
+            txout->pk = CCmpPubKey(r.pkTo);
+
+            if (r.fNonceSet) {
+                if (r.vData.size() < 33) {
+                    return errorN(1, sError, __func__, "Missing ephemeral value, vData size %d", r.vData.size());
+                }
+                txout->vData = r.vData;
+            } else {
+                CPubKey pkEphem = r.sEphem.GetPubKey();
+                SetCTOutVData(txout->vData, pkEphem, r);
+            }
+
+            }
+            break;
+        default:
+            return errorN(1, sError, __func__, "Unknown output type %d", r.nType);
+    }
+
+    return 0;
+};
+
+void ExtractNarration(const uint256 &nonce, const std::vector<uint8_t> &vData, std::string &sNarr)
+{
+    if (vData.size() < 33) {
+        return;
+    }
+
+    CPubKey pkEphem;
+    pkEphem.Set(vData.begin(), vData.begin() + 33);
+
+    int nNarrOffset = -1;
+    if (vData.size() > 38 && vData[38] == DO_NARR_CRYPT) {
+        nNarrOffset = 39;
+    } else
+    if (vData.size() > 33 && vData[33] == DO_NARR_CRYPT) {
+        nNarrOffset = 34;
+    }
+
+    if (nNarrOffset == -1) {
+        return;
+    }
+
+    size_t lenNarr = vData.size() - nNarrOffset;
+    if (lenNarr < 1 || lenNarr > 32) { // min block size 8?
+        LogPrintf("%s: Invalid narration data length: %d\n", __func__, lenNarr);
+        return;
+    }
+
+    SecMsgCrypter crypter;
+    crypter.SetKey(nonce.begin(), pkEphem.begin());
+
+    std::vector<uint8_t> vchNarr;
+    if (!crypter.Decrypt(&vData[nNarrOffset], lenNarr, vchNarr)) {
+        LogPrintf("%s: Decrypt narration failed.\n", __func__);
+        return;
+    }
+    sNarr = std::string(vchNarr.begin(), vchNarr.end());
+};
+
 int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CHDWallet *wallet)
 {
     std::vector<CTxOutBaseRef> txouts;
diff --git a/src/wallet/hdwallet.h b/src/wallet/hdwallet.h
index 13504499b3..d06018889f 100644
--- a/src/wallet/hdwallet.h
+++ b/src/wallet/hdwallet.h
@@ -402,11 +402,12 @@ class CHDWallet : public CWallet
     int InsertTempTxn(const uint256 &txid, const CTransactionRecord *rtx) const;
     const CWalletTx *GetWalletOrTempTx(const uint256& hash, const CTransactionRecord *rtx) const;
 
-    int OwnStandardOut(const CTxOutStandard *pout, const CTxOutData *pdata, COutputRecord &rout, bool &fUpdated) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
+    int OwnStandardOut(const CTxOutStandard *pout, const CTxOutData *pdata,
+        COutputRecord &rout, bool &fUpdated, bool tx_is_from_me) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
     int OwnBlindOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOutCT *pout, const CStoredExtKey *pc, uint32_t &nLastChild,
-        COutputRecord &rout, CStoredTransaction &stx, bool &fUpdated) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
+        COutputRecord &rout, CStoredTransaction &stx, bool &fUpdated, bool tx_is_from_me) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
     int OwnAnonOut(CHDWalletDB *pwdb, const uint256 &txhash, const CTxOutRingCT *pout, const CStoredExtKey *pc, uint32_t &nLastChild,
-        COutputRecord &rout, CStoredTransaction &stx, bool &fUpdated) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
+        COutputRecord &rout, CStoredTransaction &stx, bool &fUpdated, bool tx_is_from_me) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
 
     bool ProcessPlaceholder(const CTransaction &tx, CTransactionRecord &rtx);
     bool AddToRecord(CTransactionRecord &rtxIn, const CTransaction &tx, CWalletTx::Confirmation confirm, bool fFlushOnClose=true) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
diff --git a/src/wallet/hdwallettypes.h b/src/wallet/hdwallettypes.h
index 6b0d0185a0..b968a607c5 100644
--- a/src/wallet/hdwallettypes.h
+++ b/src/wallet/hdwallettypes.h
@@ -82,7 +82,7 @@ class COutputRecord
 {
 public:
     uint8_t nType = 0;
-    uint8_t nFlags = 0;
+    uint8_t nFlags = 0; // OutputRecordFlags
     uint16_t n = 0;
     CAmount nValue = -1;
     CScript scriptPubKey;
@@ -112,6 +112,8 @@ class COutputRecord
         READWRITE(obj.sNarration);
         READWRITE(obj.vPath);
     }
+
+    bool FlagSet(uint8_t flag) { return nFlags & flag; }
 };
 
 class CTransactionRecord
@@ -121,7 +123,7 @@ class CTransactionRecord
     // Conflicted state is marked by setting blockHash and nIndex -1
     uint256 blockHash;
     int block_height = 0;
-    int16_t nFlags = 0;
+    int16_t nFlags = 0; // OutputRecordFlags
     int16_t nIndex = 0;
 
     int64_t nBlockTime = 0;
@@ -132,6 +134,19 @@ class CTransactionRecord
     std::vector<COutPoint> vin;  // When inputs are anon vin stores processed prevouts
     std::vector<COutputRecord> vout;
 
+    SERIALIZE_METHODS(CTransactionRecord, obj)
+    {
+        READWRITE(obj.blockHash);
+        READWRITE(obj.nFlags);
+        READWRITE(obj.nIndex);
+        READWRITE(obj.nBlockTime);
+        READWRITE(obj.nTimeReceived);
+        READWRITE(obj.mapValue);
+        READWRITE(obj.nFee);
+        READWRITE(obj.vin);
+        READWRITE(obj.vout);
+    }
+
     int InsertOutput(COutputRecord &r);
     bool EraseOutput(uint16_t n);
 
@@ -182,21 +197,9 @@ class CTransactionRecord
     }
 
     bool InMempool() const;
-    bool IsCoinBase() const {return false;};
-    bool IsCoinStake() const {return false;};
-
-    SERIALIZE_METHODS(CTransactionRecord, obj)
-    {
-        READWRITE(obj.blockHash);
-        READWRITE(obj.nFlags);
-        READWRITE(obj.nIndex);
-        READWRITE(obj.nBlockTime);
-        READWRITE(obj.nTimeReceived);
-        READWRITE(obj.mapValue);
-        READWRITE(obj.nFee);
-        READWRITE(obj.vin);
-        READWRITE(obj.vout);
-    }
+    bool IsCoinBase() const { return false; };
+    bool IsCoinStake() const { return false; };
+    bool FlagSet(uint8_t flag) { return nFlags & flag; }
 };
 
 class CTempRecipient
@@ -206,14 +209,6 @@ class CTempRecipient
     CTempRecipient(uint8_t nType_, CAmount nAmount_, CTxDestination &dest)
         : nType(nType_), nAmount(nAmount_), nAmountSelected(nAmount_), address(dest) {};
 
-    void SetAmount(CAmount nValue)
-    {
-        nAmount = nValue;
-        nAmountSelected = nValue;
-    }
-
-    bool ApplySubFee(CAmount nFee, size_t nSubtractFeeFromAmount, bool &fFirst);
-
     uint8_t nType = 0;
     CAmount nAmount = 0;                // If fSubtractFeeFromAmount, nAmount = nAmountSelected - feeForOutput
     CAmount nAmountSelected = 0;
@@ -245,6 +240,14 @@ class CTempRecipient
     uint32_t nChildKey = 0;             // Updates wallet after send
     uint32_t nChildKeyColdStaking = 0;  // Updates wallet after send
     uint32_t nStealthPrefix = 0;
+
+    void SetAmount(CAmount nValue)
+    {
+        nAmount = nValue;
+        nAmountSelected = nValue;
+    }
+
+    bool ApplySubFee(CAmount nFee, size_t nSubtractFeeFromAmount, bool &fFirst);
 };
 
 class COutputR
diff --git a/test/functional/feature_part_anon.py b/test/functional/feature_part_anon.py
index dded8a300d..61ec45a8ed 100755
--- a/test/functional/feature_part_anon.py
+++ b/test/functional/feature_part_anon.py
@@ -72,26 +72,45 @@ def run_test(self):
         txnHash = nodes[1].sendanontoanon(sxAddrTo0_1, 1, '', '', False, 'node1 -> node0 a->a', 5, 1)
         txnHashes = [txnHash,]
 
+        # Get a change address
+        change_addr2 = nodes[2].deriverangekeys(0, 0, 'internal', False, True)[0]
+        addr_info = nodes[2].getaddressinfo(change_addr2)
+        assert(addr_info['ischange'] is True)
+
+        # Recieving wallet should not mark an output as change if tx spends no inputs
+        txnHash2 = nodes[1].sendtypeto('anon', 'part', [{'address': change_addr2, 'amount': 1, 'narr': 'node1 -> node2 a->p'}, ], '', '', 5)
+        txnHashes.append(txnHash2)
+
         assert(self.wait_for_mempool(nodes[0], txnHash))
         self.stakeBlocks(1)
 
+        ro = nodes[1].getblock(nodes[1].getblockhash(3))
+        for txnHash in txnHashes:
+            assert(txnHash in ro['tx'])
+
+        assert(nodes[1].anonoutput()['lastindex'] == 29)
+
         self.log.info('Test listsinceblock')
         block2_hash = nodes[0].getblockhash(2)
         rv = nodes[0].listsinceblock(block2_hash)
         assert(len(rv['transactions']) == 2)
-        found_tx = False
+        found_txn = False
         for txn in rv['transactions']:
-            if txn['txid'] == txnHash:
-                found_tx = True
+            if txn['txid'] == txnHashes[0]:
+                found_txn = True
             else:
                 assert(txn['category'] == 'stake')
-        assert(found_tx is True)
+        assert(found_txn is True)
 
-        ro = nodes[1].getblock(nodes[1].getblockhash(3))
-        for txnHash in txnHashes:
-            assert(txnHash in ro['tx'])
+        rv = nodes[1].listsinceblock(block2_hash)
+        assert(len(rv['transactions']) == 2)
+        for txn in rv['transactions']:
+            assert(float(txn['amount']) == -1.0)
+            assert(txn['category'] == 'send')
 
-        assert(nodes[1].anonoutput()['lastindex'] == 28)
+        rv = nodes[2].listsinceblock(block2_hash)
+        assert(len(rv['transactions']) == 1)
+        assert(rv['transactions'][0]['txid'] == txnHash2)
 
         txnHashes.clear()
         txnHashes.append(nodes[1].sendanontoanon(sxAddrTo0_1, 101, '', '', False, 'node1 -> node0 a->a', 5, 1))

From 1037b2f60ec9d85d5971672e7d46636677213245 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Wed, 22 Jun 2022 11:26:20 +0200
Subject: [PATCH 44/57] ci: Add 0.19.2.20 previous release hashes.

---
 test/get_previous_releases.py | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/test/get_previous_releases.py b/test/get_previous_releases.py
index 5e3f19998e..4658c70ce2 100755
--- a/test/get_previous_releases.py
+++ b/test/get_previous_releases.py
@@ -53,12 +53,12 @@
 "aa7a9563b48aa79252c8e7b6a41c07a5441bd9f14c5e4562cc72720ea6cb0ee5": "bitcoin-0.19.1-riscv64-linux-gnu.tar.gz",
 "5fcac9416e486d4960e1a946145566350ca670f9aaba99de6542080851122e4c": "bitcoin-0.19.1-x86_64-linux-gnu.tar.gz",
 
-"14d967239267b256aec57df819669333c4c580e274b8f8c8d80ba485a15391bd": "particl--aarch64-linux-gnu.tar.gz",
-"070b9a588d586b64bd2f2b54ef3b46c7bd6e92fd5bda193b9ddf3f8e779db51c": "particl-0.19.0.1-arm-linux-gnueabihf.tar.gz",
-"019b70af552388c7ffd4f1bb8ecc9403a7e23c3281e4005bf818eeb99f8e229a": "particl-0.19.0.1-i686-pc-linux-gnu.tar.gz",
-"ef2157fb8323185600822921839eeb09c1f9e4eb20e6a51301447cef88ea4970": "particl-0.19.0.1-riscv64-linux-gnu.tar.gz",
-"255e3fe805382089ec02e9ce36e74f18516dc16b99a15e9f9ebb1d3fd34b0230": "particl-0.19.0.1-x86_64-linux-gnu.tar.gz",
-"524dc863a834150f9ecb77175898c63b82bfc743f7a0e14841b7063931070aee": "particl-0.19.0.1-osx64.tar.gz",
+"94b0d872dc13e985428d12acf3969fb0ca9e5d0a99454929daf60cb9ef573f31": "particl-0.19.2.20-aarch64-linux-gnu.tar.gz",
+"78f79e629c96ba909797cfd1d16ec9ac67e05fe29cacce5b03c07b34cb562bf4": "particl-0.19.2.20-arm-linux-gnueabihf.tar.gz",
+"d4c3f7c2c0e8a767986082edb9df085a235468e354b0add546180aa8df6d4994": "particl-0.19.2.20-i686-pc-linux-gnu.tar.gz",
+"a8d6c1b4090f24de6b0255a3c34cff54ec339bb132b05a71f1a3424560ee2664": "particl-0.19.2.20-riscv64-linux-gnu.tar.gz",
+"6ac6fee114cdb1e8914e6d43ae3c5f227542a30772000fe202796eb8710c48cf": "particl-0.19.2.20-x86_64-linux-gnu.tar.gz",
+"960a69830a22bad28f7251cd014ff2a4f1a6dc049aa93852aa6bdd920fcf6dd3": "particl-0.19.2.20-osx64.tar.gz",
 
 "fc649cb46d9f4ea4919bb87be8b685474f95f89ae82996dd1e36f2089b69f90d": "particl-0.18.1.7-aarch64-linux-gnu.tar.gz",
 "779e57c7e4d680736f972de07276a1037de6c2aa8a2c95c8087c43c56927dc60": "particl-0.18.1.7-arm-linux-gnueabihf.tar.gz",

From 6bfa0bef48d231b0aa7befee86834d5652809fbf Mon Sep 17 00:00:00 2001
From: Pieter Wuille <pieter@wuille.net>
Date: Wed, 8 Dec 2021 14:14:15 -0500
Subject: [PATCH 45/57] Add pure Python RIPEMD-160

Github-Pull: #23716
Rebased-From: ad3e9e1f214d739e098c6ebbd300da5df1026a44
---
 test/functional/test_framework/ripemd160.py | 130 ++++++++++++++++++++
 1 file changed, 130 insertions(+)
 create mode 100644 test/functional/test_framework/ripemd160.py

diff --git a/test/functional/test_framework/ripemd160.py b/test/functional/test_framework/ripemd160.py
new file mode 100644
index 0000000000..12801364b4
--- /dev/null
+++ b/test/functional/test_framework/ripemd160.py
@@ -0,0 +1,130 @@
+# Copyright (c) 2021 Pieter Wuille
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test-only pure Python RIPEMD160 implementation."""
+
+import unittest
+
+# Message schedule indexes for the left path.
+ML = [
+    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
+    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
+    3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
+    1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
+    4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
+]
+
+# Message schedule indexes for the right path.
+MR = [
+    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
+    6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
+    15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
+    8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
+    12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
+]
+
+# Rotation counts for the left path.
+RL = [
+    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
+    7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
+    11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
+    11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
+    9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
+]
+
+# Rotation counts for the right path.
+RR = [
+    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
+    9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
+    9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
+    15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
+    8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
+]
+
+# K constants for the left path.
+KL = [0, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
+
+# K constants for the right path.
+KR = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0]
+
+
+def fi(x, y, z, i):
+    """The f1, f2, f3, f4, and f5 functions from the specification."""
+    if i == 0:
+        return x ^ y ^ z
+    elif i == 1:
+        return (x & y) | (~x & z)
+    elif i == 2:
+        return (x | ~y) ^ z
+    elif i == 3:
+        return (x & z) | (y & ~z)
+    elif i == 4:
+        return x ^ (y | ~z)
+    else:
+        assert False
+
+
+def rol(x, i):
+    """Rotate the bottom 32 bits of x left by i bits."""
+    return ((x << i) | ((x & 0xffffffff) >> (32 - i))) & 0xffffffff
+
+
+def compress(h0, h1, h2, h3, h4, block):
+    """Compress state (h0, h1, h2, h3, h4) with block."""
+    # Left path variables.
+    al, bl, cl, dl, el = h0, h1, h2, h3, h4
+    # Right path variables.
+    ar, br, cr, dr, er = h0, h1, h2, h3, h4
+    # Message variables.
+    x = [int.from_bytes(block[4*i:4*(i+1)], 'little') for i in range(16)]
+
+    # Iterate over the 80 rounds of the compression.
+    for j in range(80):
+        rnd = j >> 4
+        # Perform left side of the transformation.
+        al = rol(al + fi(bl, cl, dl, rnd) + x[ML[j]] + KL[rnd], RL[j]) + el
+        al, bl, cl, dl, el = el, al, bl, rol(cl, 10), dl
+        # Perform right side of the transformation.
+        ar = rol(ar + fi(br, cr, dr, 4 - rnd) + x[MR[j]] + KR[rnd], RR[j]) + er
+        ar, br, cr, dr, er = er, ar, br, rol(cr, 10), dr
+
+    # Compose old state, left transform, and right transform into new state.
+    return h1 + cl + dr, h2 + dl + er, h3 + el + ar, h4 + al + br, h0 + bl + cr
+
+
+def ripemd160(data):
+    """Compute the RIPEMD-160 hash of data."""
+    # Initialize state.
+    state = (0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0)
+    # Process full 64-byte blocks in the input.
+    for b in range(len(data) >> 6):
+        state = compress(*state, data[64*b:64*(b+1)])
+    # Construct final blocks (with padding and size).
+    pad = b"\x80" + b"\x00" * ((119 - len(data)) & 63)
+    fin = data[len(data) & ~63:] + pad + (8 * len(data)).to_bytes(8, 'little')
+    # Process final blocks.
+    for b in range(len(fin) >> 6):
+        state = compress(*state, fin[64*b:64*(b+1)])
+    # Produce output.
+    return b"".join((h & 0xffffffff).to_bytes(4, 'little') for h in state)
+
+
+class TestFrameworkKey(unittest.TestCase):
+    def test_ripemd160(self):
+        """RIPEMD-160 test vectors."""
+        # See https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
+        for msg, hexout in [
+            (b"", "9c1185a5c5e9fc54612808977ee8f548b2258d31"),
+            (b"a", "0bdc9d2d256b3ee9daae347be6f4dc835a467ffe"),
+            (b"abc", "8eb208f7e05d987a9b044a8e98c6b087f15a0bfc"),
+            (b"message digest", "5d0689ef49d2fae572b881b123a85ffa21595f36"),
+            (b"abcdefghijklmnopqrstuvwxyz",
+                "f71c27109c692c1b56bbdceb5b9d2865b3708dbc"),
+            (b"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
+                "12a053384a9c0c88e405a06c27dcf49ada62eb2b"),
+            (b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
+                "b0e20b6e3116640286ed3a87a5713079b21f5189"),
+            (b"1234567890" * 8, "9b752e45573d4b39f4dbd3323cab82bf63326bfb"),
+            (b"a" * 1000000, "52783243c1697bdbe16d37f97f68f08325dc1528")
+        ]:
+            self.assertEqual(ripemd160(msg).hex(), hexout)

From bf79f08d97e2225a8a1116ede8425bb34ce8b23f Mon Sep 17 00:00:00 2001
From: Pieter Wuille <pieter@wuille.net>
Date: Wed, 8 Dec 2021 14:17:08 -0500
Subject: [PATCH 46/57] Swap out hashlib.ripemd160 for own implementation

Github-Pull: #23716
Rebased-From: 5b559dc7ecf37ab1604b75ec8ffe8436377a5fb1
---
 test/functional/test_framework/script.py | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/test/functional/test_framework/script.py b/test/functional/test_framework/script.py
index 8e5848d493..321277dbf3 100644
--- a/test/functional/test_framework/script.py
+++ b/test/functional/test_framework/script.py
@@ -8,7 +8,6 @@
 """
 
 from collections import namedtuple
-import hashlib
 import struct
 import unittest
 from typing import List, Dict
@@ -25,6 +24,8 @@
     uint256_from_str,
 )
 
+from .ripemd160 import ripemd160
+
 MAX_SCRIPT_ELEMENT_SIZE = 520
 LOCKTIME_THRESHOLD = 500000000
 ANNEX_TAG = 0x50
@@ -34,7 +35,7 @@
 LEAF_VERSION_TAPSCRIPT = 0xc0
 
 def hash160(s):
-    return hashlib.new('ripemd160', sha256(s)).digest()
+    return ripemd160(sha256(s))
 
 def bn2vch(v):
     """Convert number to bitcoin-specific little endian format."""

From 2660bc04fe92a66f0ef9b44e68b0d3da440f0f66 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Thu, 4 Aug 2022 11:53:06 +0200
Subject: [PATCH 47/57] validation: New checkpoints

---
 src/chainparams.cpp | 22 ++++++++++++----------
 1 file changed, 12 insertions(+), 10 deletions(-)

diff --git a/src/chainparams.cpp b/src/chainparams.cpp
index 9747578efa..923127a2ad 100644
--- a/src/chainparams.cpp
+++ b/src/chainparams.cpp
@@ -497,8 +497,8 @@ class CMainParams : public CChainParams {
         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].min_activation_height = 709632; // Approximately November 12th, 2021
 
         // The best chain should have at least this much work.
-        consensus.nMinimumChainWork = uint256S("0x0000000000000000000000000000000000000000000000f82647fbb4c6e90493");
-        consensus.defaultAssumeValid = uint256S("0x4e0328ad2e2cb4fe6cb9a46c675a00673ff0e2e3c8185d7055e404adefbc7a96"); // 1159409
+        consensus.nMinimumChainWork = uint256S("0x00000000000000000000000000000000000000000000010dfe6b4890926f5830");
+        consensus.defaultAssumeValid = uint256S("0xb35f0e0cde108c282380d6850bae83c1fd2e961781e2289e2b2cd3d17ff039ab"); // 1236270
 
         consensus.nMinRCTOutputDepth = 12;
 
@@ -609,13 +609,14 @@ class CMainParams : public CChainParams {
                 { 1102310,  uint256S("0x4e43167170e4639dbb1fdb84cb5735853f9595ff42713c143b70fd0625a382cd")},
                 { 1117588,  uint256S("0x6b13071bc3f5689a3f8a29808f726654283714461076ea890f4272574ff2659f")},
                 { 1159409,  uint256S("0x4e0328ad2e2cb4fe6cb9a46c675a00673ff0e2e3c8185d7055e404adefbc7a96")},
+                { 1236270,  uint256S("0xb35f0e0cde108c282380d6850bae83c1fd2e961781e2289e2b2cd3d17ff039ab")},
             }
         };
 
         chainTxData = ChainTxData {
-            // Data from rpc: getchaintxstats 4096 4e0328ad2e2cb4fe6cb9a46c675a00673ff0e2e3c8185d7055e404adefbc7a96
-            /* nTime    */ 1649705872,
-            /* nTxCount */ 1428812,
+            // Data from rpc: getchaintxstats 4096 b35f0e0cde108c282380d6850bae83c1fd2e961781e2289e2b2cd3d17ff039ab
+            /* nTime    */ 1659605952,
+            /* nTxCount */ 1538460,
             /* dTxRate  */ 0.01
         };
     }
@@ -700,8 +701,8 @@ class CTestNetParams : public CChainParams {
         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].min_activation_height = 0; // No activation delay
 
         // The best chain should have at least this much work.
-        consensus.nMinimumChainWork = uint256S("0x000000000000000000000000000000000000000000000017cad02326f93a294d");
-        consensus.defaultAssumeValid = uint256S("0x1e74a808cc907a48cdaf6f2cf5488a54d64a186fa7d65f5f717b11a8dc37d55e"); // 1086076
+        consensus.nMinimumChainWork = uint256S("0x00000000000000000000000000000000000000000000001ab0043731dde46da8");
+        consensus.defaultAssumeValid = uint256S("0x01bbfe87e90af03e6daa171611fe342403a7ebb7f4703342f34fdeb613b3ecbc"); // 1162920
 
         consensus.nMinRCTOutputDepth = 12;
 
@@ -789,13 +790,14 @@ class CTestNetParams : public CChainParams {
                 {1029738, uint256S("0x62ca4edbeb88e371d36052f7bbb52a598b1ac13d9269b5205ba7ed228d8b742a")},
                 {1044185, uint256S("0xc8b34db63fb6ec97b557a969065e56167030c36c12b7c988561736ad3a5488c0")},
                 {1086076, uint256S("0x1e74a808cc907a48cdaf6f2cf5488a54d64a186fa7d65f5f717b11a8dc37d55e")},
+                {1162920, uint256S("0x01bbfe87e90af03e6daa171611fe342403a7ebb7f4703342f34fdeb613b3ecbc")},
             }
         };
 
         chainTxData = ChainTxData{
-            // Data from rpc: getchaintxstats 4096 1e74a808cc907a48cdaf6f2cf5488a54d64a186fa7d65f5f717b11a8dc37d55e
-            /* nTime    */ 1649705808,
-            /* nTxCount */ 1150550,
+            // Data from rpc: getchaintxstats 4096 01bbfe87e90af03e6daa171611fe342403a7ebb7f4703342f34fdeb613b3ecbc
+            /* nTime    */ 1659606240,
+            /* nTxCount */ 1228036,
             /* dTxRate  */ 0.005
         };
     }

From 69b7558de5ac70c87e913f62ae1436eead923447 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Thu, 4 Aug 2022 12:28:33 +0200
Subject: [PATCH 48/57] build: Raise version to 0.21.2.10

---
 configure.ac                                |  2 +-
 contrib/gitian-descriptors/assign_DISTNAME  |  2 +-
 contrib/gitian-descriptors/gitian-linux.yml |  2 +-
 contrib/gitian-descriptors/gitian-osx.yml   |  2 +-
 contrib/gitian-descriptors/gitian-win.yml   |  2 +-
 doc/man/particl-cli.1                       |  8 ++++----
 doc/man/particl-qt.1                        | 12 ++++++------
 doc/man/particl-tx.1                        |  8 ++++----
 doc/man/particl-wallet.1                    |  8 ++++----
 doc/man/particld.1                          | 12 ++++++------
 doc/release-notes-particl.md                |  2 ++
 11 files changed, 31 insertions(+), 29 deletions(-)

diff --git a/configure.ac b/configure.ac
index 6821d5c654..b3ecbd7136 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2,7 +2,7 @@ AC_PREREQ([2.69])
 define(_CLIENT_VERSION_MAJOR, 0)
 define(_CLIENT_VERSION_MINOR, 21)
 define(_CLIENT_VERSION_REVISION, 2)
-define(_CLIENT_VERSION_PARTICL, 9)
+define(_CLIENT_VERSION_PARTICL, 10)
 define(_CLIENT_VERSION_BUILD, 0)
 define(_CLIENT_VERSION_RC, 0)
 define(_CLIENT_VERSION_IS_RELEASE, true)
diff --git a/contrib/gitian-descriptors/assign_DISTNAME b/contrib/gitian-descriptors/assign_DISTNAME
index 6645a66c6c..26829ea0fa 100755
--- a/contrib/gitian-descriptors/assign_DISTNAME
+++ b/contrib/gitian-descriptors/assign_DISTNAME
@@ -10,5 +10,5 @@ else
     VERSION="$(git rev-parse --short=12 HEAD)"
 fi
 # git describe isn't detecting the tag in gitian
-VERSION="0.21.2.9"
+VERSION="0.21.2.10"
 DISTNAME="particl-${VERSION}"
diff --git a/contrib/gitian-descriptors/gitian-linux.yml b/contrib/gitian-descriptors/gitian-linux.yml
index b6a1e14315..7cdfbd14b6 100644
--- a/contrib/gitian-descriptors/gitian-linux.yml
+++ b/contrib/gitian-descriptors/gitian-linux.yml
@@ -1,5 +1,5 @@
 ---
-name: "particl-linux-0.21.2.9"
+name: "particl-linux-0.21.2.10"
 enable_cache: true
 sudo: true
 distro: "ubuntu"
diff --git a/contrib/gitian-descriptors/gitian-osx.yml b/contrib/gitian-descriptors/gitian-osx.yml
index 88467d017d..a1cded27bf 100644
--- a/contrib/gitian-descriptors/gitian-osx.yml
+++ b/contrib/gitian-descriptors/gitian-osx.yml
@@ -1,5 +1,5 @@
 ---
-name: "particl-osx-0.21.2.9"
+name: "particl-osx-0.21.2.10"
 enable_cache: true
 distro: "ubuntu"
 suites:
diff --git a/contrib/gitian-descriptors/gitian-win.yml b/contrib/gitian-descriptors/gitian-win.yml
index 946751da00..e398067dac 100644
--- a/contrib/gitian-descriptors/gitian-win.yml
+++ b/contrib/gitian-descriptors/gitian-win.yml
@@ -1,5 +1,5 @@
 ---
-name: "particl-win-0.21.2.9"
+name: "particl-win-0.21.2.10"
 enable_cache: true
 sudo: true
 distro: "ubuntu"
diff --git a/doc/man/particl-cli.1 b/doc/man/particl-cli.1
index 30310223e9..7422b139bb 100644
--- a/doc/man/particl-cli.1
+++ b/doc/man/particl-cli.1
@@ -1,7 +1,7 @@
-.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
-.TH PARTICL-CLI "1" "April 2022" "particl-cli v0.21.2.9" "User Commands"
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.2.
+.TH PARTICL-CLI "1" "August 2022" "particl-cli v0.21.2.10" "User Commands"
 .SH NAME
-particl-cli  manual page for particl-cli v0.21.2.9
+particl-cli  manual page for particl-cli v0.21.2.10
 .SH SYNOPSIS
 .B particl-cli
 [\fI\,options\/\fR] \fI\,<command> \/\fR[\fI\,params\/\fR]  \fI\,Send command to Particl Core\/\fR
@@ -15,7 +15,7 @@ particl-cli  manual page for particl-cli v0.21.2.9
 .B particl-cli
 [\fI\,options\/\fR] \fI\,help <command>      Get help for a command\/\fR
 .SH DESCRIPTION
-Particl Core RPC client version v0.21.2.9
+Particl Core RPC client version v0.21.2.10
 .SH OPTIONS
 .HP
 ?
diff --git a/doc/man/particl-qt.1 b/doc/man/particl-qt.1
index 7a71f9eb30..fb9539f983 100644
--- a/doc/man/particl-qt.1
+++ b/doc/man/particl-qt.1
@@ -1,12 +1,12 @@
-.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
-.TH PARTICL-QT "1" "April 2022" "particl-qt v0.21.2.9" "User Commands"
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.2.
+.TH PARTICL-QT "1" "August 2022" "particl-qt v0.21.2.10" "User Commands"
 .SH NAME
-particl-qt  manual page for particl-qt v0.21.2.9
+particl-qt  manual page for particl-qt v0.21.2.10
 .SH SYNOPSIS
 .B particl-qt
 [\fI\,command-line options\/\fR]
 .SH DESCRIPTION
-Particl Core version v0.21.2.9
+Particl Core version v0.21.2.10
 .SH OPTIONS
 .HP
 ?
@@ -28,9 +28,9 @@ long fork (%s in cmd is replaced by message)
 If this block is in the chain assume that it and its ancestors are valid
 and potentially skip their script verification (0 to verify all,
 default:
-4e0328ad2e2cb4fe6cb9a46c675a00673ff0e2e3c8185d7055e404adefbc7a96,
+b35f0e0cde108c282380d6850bae83c1fd2e961781e2289e2b2cd3d17ff039ab,
 testnet:
-1e74a808cc907a48cdaf6f2cf5488a54d64a186fa7d65f5f717b11a8dc37d55e,
+01bbfe87e90af03e6daa171611fe342403a7ebb7f4703342f34fdeb613b3ecbc,
 signet:
 0000002a1de0f46379358c1fd09906f7ac59adf3712323ed90eb59e4c183c020)
 .HP
diff --git a/doc/man/particl-tx.1 b/doc/man/particl-tx.1
index 68a71b006f..eb4e4623cf 100644
--- a/doc/man/particl-tx.1
+++ b/doc/man/particl-tx.1
@@ -1,7 +1,7 @@
-.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
-.TH PARTICL-TX "1" "April 2022" "particl-tx v0.21.2.9" "User Commands"
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.2.
+.TH PARTICL-TX "1" "August 2022" "particl-tx v0.21.2.10" "User Commands"
 .SH NAME
-particl-tx  manual page for particl-tx v0.21.2.9
+particl-tx  manual page for particl-tx v0.21.2.10
 .SH SYNOPSIS
 .B particl-tx
 [\fI\,options\/\fR] \fI\,<hex-tx> \/\fR[\fI\,commands\/\fR]  \fI\,Update hex-encoded transaction\/\fR
@@ -9,7 +9,7 @@ particl-tx  manual page for particl-tx v0.21.2.9
 .B particl-tx
 [\fI\,options\/\fR] \fI\,-create \/\fR[\fI\,commands\/\fR]   \fI\,Create hex-encoded transaction\/\fR
 .SH DESCRIPTION
-Particl Core particltx utility version v0.21.2.9
+Particl Core particltx utility version v0.21.2.10
 .SH OPTIONS
 .HP
 ?
diff --git a/doc/man/particl-wallet.1 b/doc/man/particl-wallet.1
index 11d3f9f53c..f4e09c41c4 100644
--- a/doc/man/particl-wallet.1
+++ b/doc/man/particl-wallet.1
@@ -1,9 +1,9 @@
-.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
-.TH PARTICL-WALLET "1" "April 2022" "particl-wallet v0.21.2.9" "User Commands"
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.2.
+.TH PARTICL-WALLET "1" "August 2022" "particl-wallet v0.21.2.10" "User Commands"
 .SH NAME
-particl-wallet  manual page for particl-wallet v0.21.2.9
+particl-wallet  manual page for particl-wallet v0.21.2.10
 .SH DESCRIPTION
-Particl Core particlwallet version v0.21.2.9
+Particl Core particlwallet version v0.21.2.10
 .PP
 particlwallet is an offline tool for creating and interacting with Particl Core wallet files.
 By default particlwallet will act on wallets in the default mainnet wallet directory in the datadir.
diff --git a/doc/man/particld.1 b/doc/man/particld.1
index 56c25dd8af..aaf18b7efe 100644
--- a/doc/man/particld.1
+++ b/doc/man/particld.1
@@ -1,12 +1,12 @@
-.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
-.TH PARTICLD "1" "April 2022" "particld v0.21.2.9" "User Commands"
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.2.
+.TH PARTICLD "1" "August 2022" "particld v0.21.2.10" "User Commands"
 .SH NAME
-particld  manual page for particld v0.21.2.9
+particld  manual page for particld v0.21.2.10
 .SH SYNOPSIS
 .B particld
 [\fI\,options\/\fR]                     \fI\,Start Particl Core\/\fR
 .SH DESCRIPTION
-Particl Core version v0.21.2.9
+Particl Core version v0.21.2.10
 .SH OPTIONS
 .HP
 ?
@@ -28,9 +28,9 @@ long fork (%s in cmd is replaced by message)
 If this block is in the chain assume that it and its ancestors are valid
 and potentially skip their script verification (0 to verify all,
 default:
-4e0328ad2e2cb4fe6cb9a46c675a00673ff0e2e3c8185d7055e404adefbc7a96,
+b35f0e0cde108c282380d6850bae83c1fd2e961781e2289e2b2cd3d17ff039ab,
 testnet:
-1e74a808cc907a48cdaf6f2cf5488a54d64a186fa7d65f5f717b11a8dc37d55e,
+01bbfe87e90af03e6daa171611fe342403a7ebb7f4703342f34fdeb613b3ecbc,
 signet:
 0000002a1de0f46379358c1fd09906f7ac59adf3712323ed90eb59e4c183c020)
 .HP
diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index 93313794be..5ee6cbe46c 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -7,6 +7,8 @@
   - getcoldstakinginfo pending_depth shows coins unstakable until after 225 blocks (nStakeMinConfirmations)
 - rpc: Added minstakeabledepth to getstakinginfo
 - wallet: Only mark anon/blind tx outputs as change if wallet owns inputs.
+- New checkpoints
+
 
 
 0.21.2.9

From 8f9e8eb34430b794f29bffb62d77d95d83f466d5 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Sat, 20 Aug 2022 18:53:52 +0200
Subject: [PATCH 49/57] consensus: Fix rare fork possibility.

---
 doc/release-notes-particl.md | 9 +++++++++
 src/validation.cpp           | 5 ++++-
 2 files changed, 13 insertions(+), 1 deletion(-)

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index 5ee6cbe46c..5d0d0a115a 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -1,3 +1,12 @@
+0.21.2.11
+==============
+
+- consensus: Fix rare fork possibility.
+  - A block index is added for an invalid block, to prevent nodes trying
+    to redownload the same block from peers.
+    The failed block index is added to m_failed_blocks, but wasn't being
+    removed when the block index is removed to prevent DoS issues.
+
 
 0.21.2.10
 ==============
diff --git a/src/validation.cpp b/src/validation.cpp
index 7133072110..b620e5c6a4 100644
--- a/src/validation.cpp
+++ b/src/validation.cpp
@@ -5164,6 +5164,7 @@ bool RemoveUnreceivedHeader(const uint256 &hash) EXCLUSIVE_LOCKS_REQUIRED(cs_mai
     for (auto &entry : remove_headers) {
         LogPrint(BCLog::NET, "Removing loose header %s.\n", entry->second->GetBlockHash().ToString());
         setDirtyBlockIndex.erase(entry->second);
+        g_chainman.m_blockman.m_failed_blocks.erase(entry->second);
 
         if (pindexBestHeader == entry->second) {
             pindexBestHeader = ::ChainActive().Tip();
@@ -5314,7 +5315,9 @@ bool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS
             // we don't need to iterate over the failed blocks list.
             for (const CBlockIndex* failedit : m_failed_blocks) {
                 if (pindexPrev->GetAncestor(failedit->nHeight) == failedit) {
-                    //assert(failedit->nStatus & BLOCK_FAILED_VALID);
+                    if (!(failedit->nStatus & BLOCK_FAILED_VALID)) {
+                        LogPrintf("ERROR: Valid block in m_failed_blocks!\n");
+                    }
                     CBlockIndex* invalid_walk = pindexPrev;
                     if (failedit->nStatus & BLOCK_FAILED_VALID)
                     while (invalid_walk != failedit) {

From 56faa90b70d2d8bcef84121b218edc871ada2eff Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Sat, 20 Aug 2022 19:13:16 +0200
Subject: [PATCH 50/57] build: Raise version to 0.21.2.11

---
 configure.ac                                | 2 +-
 contrib/gitian-descriptors/assign_DISTNAME  | 2 +-
 contrib/gitian-descriptors/gitian-linux.yml | 2 +-
 contrib/gitian-descriptors/gitian-osx.yml   | 2 +-
 contrib/gitian-descriptors/gitian-win.yml   | 2 +-
 doc/man/particl-cli.1                       | 6 +++---
 doc/man/particl-qt.1                        | 6 +++---
 doc/man/particl-tx.1                        | 6 +++---
 doc/man/particl-wallet.1                    | 6 +++---
 doc/man/particld.1                          | 6 +++---
 10 files changed, 20 insertions(+), 20 deletions(-)

diff --git a/configure.ac b/configure.ac
index b3ecbd7136..ec3d8a9a7d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2,7 +2,7 @@ AC_PREREQ([2.69])
 define(_CLIENT_VERSION_MAJOR, 0)
 define(_CLIENT_VERSION_MINOR, 21)
 define(_CLIENT_VERSION_REVISION, 2)
-define(_CLIENT_VERSION_PARTICL, 10)
+define(_CLIENT_VERSION_PARTICL, 11)
 define(_CLIENT_VERSION_BUILD, 0)
 define(_CLIENT_VERSION_RC, 0)
 define(_CLIENT_VERSION_IS_RELEASE, true)
diff --git a/contrib/gitian-descriptors/assign_DISTNAME b/contrib/gitian-descriptors/assign_DISTNAME
index 26829ea0fa..5d5ac488bc 100755
--- a/contrib/gitian-descriptors/assign_DISTNAME
+++ b/contrib/gitian-descriptors/assign_DISTNAME
@@ -10,5 +10,5 @@ else
     VERSION="$(git rev-parse --short=12 HEAD)"
 fi
 # git describe isn't detecting the tag in gitian
-VERSION="0.21.2.10"
+VERSION="0.21.2.11"
 DISTNAME="particl-${VERSION}"
diff --git a/contrib/gitian-descriptors/gitian-linux.yml b/contrib/gitian-descriptors/gitian-linux.yml
index 7cdfbd14b6..f9c5a0c44c 100644
--- a/contrib/gitian-descriptors/gitian-linux.yml
+++ b/contrib/gitian-descriptors/gitian-linux.yml
@@ -1,5 +1,5 @@
 ---
-name: "particl-linux-0.21.2.10"
+name: "particl-linux-0.21.2.11"
 enable_cache: true
 sudo: true
 distro: "ubuntu"
diff --git a/contrib/gitian-descriptors/gitian-osx.yml b/contrib/gitian-descriptors/gitian-osx.yml
index a1cded27bf..2a108390a6 100644
--- a/contrib/gitian-descriptors/gitian-osx.yml
+++ b/contrib/gitian-descriptors/gitian-osx.yml
@@ -1,5 +1,5 @@
 ---
-name: "particl-osx-0.21.2.10"
+name: "particl-osx-0.21.2.11"
 enable_cache: true
 distro: "ubuntu"
 suites:
diff --git a/contrib/gitian-descriptors/gitian-win.yml b/contrib/gitian-descriptors/gitian-win.yml
index e398067dac..e52a706b41 100644
--- a/contrib/gitian-descriptors/gitian-win.yml
+++ b/contrib/gitian-descriptors/gitian-win.yml
@@ -1,5 +1,5 @@
 ---
-name: "particl-win-0.21.2.10"
+name: "particl-win-0.21.2.11"
 enable_cache: true
 sudo: true
 distro: "ubuntu"
diff --git a/doc/man/particl-cli.1 b/doc/man/particl-cli.1
index 7422b139bb..9858c32b50 100644
--- a/doc/man/particl-cli.1
+++ b/doc/man/particl-cli.1
@@ -1,7 +1,7 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.2.
-.TH PARTICL-CLI "1" "August 2022" "particl-cli v0.21.2.10" "User Commands"
+.TH PARTICL-CLI "1" "August 2022" "particl-cli v0.21.2.11" "User Commands"
 .SH NAME
-particl-cli  manual page for particl-cli v0.21.2.10
+particl-cli  manual page for particl-cli v0.21.2.11
 .SH SYNOPSIS
 .B particl-cli
 [\fI\,options\/\fR] \fI\,<command> \/\fR[\fI\,params\/\fR]  \fI\,Send command to Particl Core\/\fR
@@ -15,7 +15,7 @@ particl-cli  manual page for particl-cli v0.21.2.10
 .B particl-cli
 [\fI\,options\/\fR] \fI\,help <command>      Get help for a command\/\fR
 .SH DESCRIPTION
-Particl Core RPC client version v0.21.2.10
+Particl Core RPC client version v0.21.2.11
 .SH OPTIONS
 .HP
 ?
diff --git a/doc/man/particl-qt.1 b/doc/man/particl-qt.1
index fb9539f983..ff18554117 100644
--- a/doc/man/particl-qt.1
+++ b/doc/man/particl-qt.1
@@ -1,12 +1,12 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.2.
-.TH PARTICL-QT "1" "August 2022" "particl-qt v0.21.2.10" "User Commands"
+.TH PARTICL-QT "1" "August 2022" "particl-qt v0.21.2.11" "User Commands"
 .SH NAME
-particl-qt  manual page for particl-qt v0.21.2.10
+particl-qt  manual page for particl-qt v0.21.2.11
 .SH SYNOPSIS
 .B particl-qt
 [\fI\,command-line options\/\fR]
 .SH DESCRIPTION
-Particl Core version v0.21.2.10
+Particl Core version v0.21.2.11
 .SH OPTIONS
 .HP
 ?
diff --git a/doc/man/particl-tx.1 b/doc/man/particl-tx.1
index eb4e4623cf..9bf0f27792 100644
--- a/doc/man/particl-tx.1
+++ b/doc/man/particl-tx.1
@@ -1,7 +1,7 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.2.
-.TH PARTICL-TX "1" "August 2022" "particl-tx v0.21.2.10" "User Commands"
+.TH PARTICL-TX "1" "August 2022" "particl-tx v0.21.2.11" "User Commands"
 .SH NAME
-particl-tx  manual page for particl-tx v0.21.2.10
+particl-tx  manual page for particl-tx v0.21.2.11
 .SH SYNOPSIS
 .B particl-tx
 [\fI\,options\/\fR] \fI\,<hex-tx> \/\fR[\fI\,commands\/\fR]  \fI\,Update hex-encoded transaction\/\fR
@@ -9,7 +9,7 @@ particl-tx  manual page for particl-tx v0.21.2.10
 .B particl-tx
 [\fI\,options\/\fR] \fI\,-create \/\fR[\fI\,commands\/\fR]   \fI\,Create hex-encoded transaction\/\fR
 .SH DESCRIPTION
-Particl Core particltx utility version v0.21.2.10
+Particl Core particltx utility version v0.21.2.11
 .SH OPTIONS
 .HP
 ?
diff --git a/doc/man/particl-wallet.1 b/doc/man/particl-wallet.1
index f4e09c41c4..dbe6b25f40 100644
--- a/doc/man/particl-wallet.1
+++ b/doc/man/particl-wallet.1
@@ -1,9 +1,9 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.2.
-.TH PARTICL-WALLET "1" "August 2022" "particl-wallet v0.21.2.10" "User Commands"
+.TH PARTICL-WALLET "1" "August 2022" "particl-wallet v0.21.2.11" "User Commands"
 .SH NAME
-particl-wallet  manual page for particl-wallet v0.21.2.10
+particl-wallet  manual page for particl-wallet v0.21.2.11
 .SH DESCRIPTION
-Particl Core particlwallet version v0.21.2.10
+Particl Core particlwallet version v0.21.2.11
 .PP
 particlwallet is an offline tool for creating and interacting with Particl Core wallet files.
 By default particlwallet will act on wallets in the default mainnet wallet directory in the datadir.
diff --git a/doc/man/particld.1 b/doc/man/particld.1
index aaf18b7efe..8b777558c8 100644
--- a/doc/man/particld.1
+++ b/doc/man/particld.1
@@ -1,12 +1,12 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.2.
-.TH PARTICLD "1" "August 2022" "particld v0.21.2.10" "User Commands"
+.TH PARTICLD "1" "August 2022" "particld v0.21.2.11" "User Commands"
 .SH NAME
-particld  manual page for particld v0.21.2.10
+particld  manual page for particld v0.21.2.11
 .SH SYNOPSIS
 .B particld
 [\fI\,options\/\fR]                     \fI\,Start Particl Core\/\fR
 .SH DESCRIPTION
-Particl Core version v0.21.2.10
+Particl Core version v0.21.2.11
 .SH OPTIONS
 .HP
 ?

From 32ccc012b2530d6c7a11d93015bb82bbdcbdec4f Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Sat, 12 Nov 2022 12:27:26 +0200
Subject: [PATCH 51/57] wallet: Fix walletpassphrasechange after encryptwallet
 without restarting.

---
 src/wallet/hdwallet.cpp                | 58 ++++++++++++++++----------
 test/functional/wallet_part_particl.py |  7 ++++
 2 files changed, 42 insertions(+), 23 deletions(-)

diff --git a/src/wallet/hdwallet.cpp b/src/wallet/hdwallet.cpp
index c9321d0b22..f983df9f23 100644
--- a/src/wallet/hdwallet.cpp
+++ b/src/wallet/hdwallet.cpp
@@ -6192,8 +6192,8 @@ int CHDWallet::ExtKeyImportLoose(CHDWalletDB *pwdb, CStoredExtKey &sekIn, CKeyID
     }
 
     if (!fBip44 || fSaveBip44) {
-        if (IsCrypted()
-            && ExtKeyEncrypt(&sek, vMasterKey, false) != 0) {
+        if (IsCrypted() &&
+            ExtKeyEncrypt(&sek, vMasterKey, false) != 0) {
             return werrorN(1, "%s: ExtKeyEncrypt failed.", __func__);
         }
 
@@ -6253,14 +6253,14 @@ int CHDWallet::ExtKeyImportAccount(CHDWalletDB *pwdb, CStoredExtKey &sekIn, int6
             return werrorN(1, "ChainAccount failed.");
         }
         // Account exists, update secret if necessary
-        if (!sek->kp.IsValidV()
-            && sekAccount->kp.IsValidV()) {
+        if (!sek->kp.IsValidV() &&
+            sekAccount->kp.IsValidV()) {
             sekAccount->kp = sek->kp;
             std::vector<uint8_t> v;
             sekAccount->mapValue[EKVT_ADDED_SECRET_AT] = SetCompressedInt64(v, GetTime());
 
-             if (IsCrypted()
-                && ExtKeyEncrypt(sekAccount, vMasterKey, false) != 0) {
+             if (IsCrypted() &&
+                 ExtKeyEncrypt(sekAccount, vMasterKey, false) != 0) {
                 delete sek;
                 delete sea;
                 return werrorN(1, "ExtKeyEncrypt failed.");
@@ -6449,15 +6449,15 @@ int CHDWallet::ExtKeyNewMaster(CHDWalletDB *pwdb, CKeyID &idMaster, bool fAutoGe
 
     idMaster = sekMaster.GetID();
 
-    if (IsCrypted()
-        && (ExtKeyEncrypt(&sekRoot, vMasterKey, false) != 0
-            || ExtKeyEncrypt(&sekMaster, vMasterKey, false) != 0)) {
+    if (IsCrypted() &&
+        (ExtKeyEncrypt(&sekRoot, vMasterKey, false) != 0 ||
+         ExtKeyEncrypt(&sekMaster, vMasterKey, false) != 0)) {
         return werrorN(1, "ExtKeyEncrypt failed.");
     }
 
-    if (!pwdb->WriteExtKey(idRoot, sekRoot)
-        || !pwdb->WriteExtKey(idMaster, sekMaster)
-        || (fAutoGenerated && !pwdb->WriteFlag("madeDefaultEKey", 1))) {
+    if (!pwdb->WriteExtKey(idRoot, sekRoot) ||
+        !pwdb->WriteExtKey(idMaster, sekMaster) ||
+        (fAutoGenerated && !pwdb->WriteFlag("madeDefaultEKey", 1))) {
         return werrorN(1, "DB Write failed.");
     }
 
@@ -6546,8 +6546,8 @@ int CHDWallet::ExtKeyCreateAccount(CStoredExtKey *sekAccount, CKeyID &idMaster,
         ekaOut.nActiveStealth = 3;
     }
 
-    if (IsCrypted()
-        && ExtKeyEncrypt(&ekaOut, vMasterKey, false) != 0) {
+    if (IsCrypted() &&
+        ExtKeyEncrypt(&ekaOut, vMasterKey, false) != 0) {
         delete sekExternal;
         delete sekInternal;
         if (sekStealth) {
@@ -6733,6 +6733,18 @@ int CHDWallet::ExtKeyEncrypt(CStoredExtKey *sek, const CKeyingMaterial &vMKey, b
         sek->fLocked = 0;
     }
 
+    CKeyID sek_id = sek->GetID();
+    auto mi = mapExtKeys.find(sek_id);
+    if (mi != mapExtKeys.end() && sek != mi->second) {
+        auto sek_in_memory = mi->second;
+        sek_in_memory->nFlags = sek->nFlags;
+        sek_in_memory->vchCryptedSecret = vchCryptedSecret;
+        sek_in_memory->fLocked = sek->fLocked;
+        if (fLockKey) {
+            sek_in_memory->kp.key.Clear();
+        }
+    }
+
     return 0;
 };
 
@@ -6747,14 +6759,14 @@ int CHDWallet::ExtKeyEncrypt(CExtKeyAccount *sea, const CKeyingMaterial &vMKey,
             continue;
         }
 
-        if (!sek->kp.IsValidV()
-            && LogAcceptCategory(BCLog::HDWALLET)) {
+        if (!sek->kp.IsValidV() &&
+            LogAcceptCategory(BCLog::HDWALLET)) {
             WalletLogPrintf("%s : Skipping account %s chain, no secret.\n", __func__, sea->GetIDString58());
             continue;
         }
 
-        if (sek->kp.IsValidV()
-            && ExtKeyEncrypt(sek, vMKey, fLockKey) != 0) {
+        if (sek->kp.IsValidV() &&
+            ExtKeyEncrypt(sek, vMKey, fLockKey) != 0) {
             return 1;
         }
     }
@@ -8543,8 +8555,8 @@ int CHDWallet::NewExtKeyFromAccount(CHDWalletDB *pwdb, const CKeyID &idAccount,
     sekOut->mapValue[EKVT_CREATED_AT] = SetCompressedInt64(v, GetTime());
     sekOut->sLabel = sLabel;
 
-    if (IsCrypted()
-        && ExtKeyEncrypt(sekOut, vMasterKey, false) != 0) {
+    if (IsCrypted() &&
+        ExtKeyEncrypt(sekOut, vMasterKey, false) != 0) {
         sekAccount->SetCounter(nOldGen, fHardened);
         return werrorN(1, "ExtKeyEncrypt failed.");
     }
@@ -8566,9 +8578,9 @@ int CHDWallet::NewExtKeyFromAccount(CHDWalletDB *pwdb, const CKeyID &idAccount,
         SetAddressBook(pwdb, MakeExtPubKey(sekOut->kp), plabel, "receive", vPath, false, fBech32);
     }
 
-    if (!pwdb->WriteExtAccount(idAccount, *sea)
-        || !pwdb->WriteExtKey(idAccount, *sekAccount)
-        || !pwdb->WriteExtKey(idNewChain, *sekOut)) {
+    if (!pwdb->WriteExtAccount(idAccount, *sea) ||
+        !pwdb->WriteExtKey(idAccount, *sekAccount) ||
+        !pwdb->WriteExtKey(idNewChain, *sekOut)) {
         sekAccount->SetCounter(nOldGen, fHardened);
         return werrorN(1, "DB Write failed.");
     }
diff --git a/test/functional/wallet_part_particl.py b/test/functional/wallet_part_particl.py
index 715b3128d5..a8c17a1c7a 100755
--- a/test/functional/wallet_part_particl.py
+++ b/test/functional/wallet_part_particl.py
@@ -818,6 +818,13 @@ def run_test(self):
         assert nodes[1].verifymessage(sign_address, signature, message)
         assert not self.nodes[1].verifymessage(sign_address, signature, message, 'Invalid MM')
 
+        self.log.info('Test walletpassphrasechange after encryptwallet')
+        nodes[2].encryptwallet('qwerty123')
+        nodes[2].walletpassphrase('qwerty123', 3000)
+        nodes[2].walletpassphrasechange('qwerty123', 'changedPass')
+        ro = nodes[2].extkey('deriveAccount', 'smsg keys', '78900')
+        assert (ro['account'] == 'aghuG9YFBWHK7JK4pTJ5eSEayw1Xq4aQpn')
+
 
 if __name__ == '__main__':
     WalletParticlTest().main()

From 6186026fe43e02be414017ac006ca66adf90fcbf Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Sat, 12 Nov 2022 12:38:11 +0200
Subject: [PATCH 52/57] validation: New checkpoints

---
 src/chainparams.cpp | 24 +++++++++++++-----------
 1 file changed, 13 insertions(+), 11 deletions(-)

diff --git a/src/chainparams.cpp b/src/chainparams.cpp
index 923127a2ad..66315ea36f 100644
--- a/src/chainparams.cpp
+++ b/src/chainparams.cpp
@@ -497,8 +497,8 @@ class CMainParams : public CChainParams {
         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].min_activation_height = 709632; // Approximately November 12th, 2021
 
         // The best chain should have at least this much work.
-        consensus.nMinimumChainWork = uint256S("0x00000000000000000000000000000000000000000000010dfe6b4890926f5830");
-        consensus.defaultAssumeValid = uint256S("0xb35f0e0cde108c282380d6850bae83c1fd2e961781e2289e2b2cd3d17ff039ab"); // 1236270
+        consensus.nMinimumChainWork = uint256S("0x0000000000000000000000000000000000000000000001217ddce4920bddbc9c");
+        consensus.defaultAssumeValid = uint256S("0x6d3abd8a80371e78957cc30af3e84c45c44b2eb26175b50c5ba7ebc9e990189c"); // 1303280
 
         consensus.nMinRCTOutputDepth = 12;
 
@@ -610,13 +610,14 @@ class CMainParams : public CChainParams {
                 { 1117588,  uint256S("0x6b13071bc3f5689a3f8a29808f726654283714461076ea890f4272574ff2659f")},
                 { 1159409,  uint256S("0x4e0328ad2e2cb4fe6cb9a46c675a00673ff0e2e3c8185d7055e404adefbc7a96")},
                 { 1236270,  uint256S("0xb35f0e0cde108c282380d6850bae83c1fd2e961781e2289e2b2cd3d17ff039ab")},
+                { 1303280,  uint256S("0x6d3abd8a80371e78957cc30af3e84c45c44b2eb26175b50c5ba7ebc9e990189c")},
             }
         };
 
         chainTxData = ChainTxData {
-            // Data from rpc: getchaintxstats 4096 b35f0e0cde108c282380d6850bae83c1fd2e961781e2289e2b2cd3d17ff039ab
-            /* nTime    */ 1659605952,
-            /* nTxCount */ 1538460,
+            // Data from rpc: getchaintxstats 4096 6d3abd8a80371e78957cc30af3e84c45c44b2eb26175b50c5ba7ebc9e990189c
+            /* nTime    */ 1668249104,
+            /* nTxCount */ 1639931,
             /* dTxRate  */ 0.01
         };
     }
@@ -701,8 +702,8 @@ class CTestNetParams : public CChainParams {
         consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].min_activation_height = 0; // No activation delay
 
         // The best chain should have at least this much work.
-        consensus.nMinimumChainWork = uint256S("0x00000000000000000000000000000000000000000000001ab0043731dde46da8");
-        consensus.defaultAssumeValid = uint256S("0x01bbfe87e90af03e6daa171611fe342403a7ebb7f4703342f34fdeb613b3ecbc"); // 1162920
+        consensus.nMinimumChainWork = uint256S("0x00000000000000000000000000000000000000000000001d53653b0771bebf61");
+        consensus.defaultAssumeValid = uint256S("0xab3724205826d2e38f0a12e1938d4825e3ba6f983ee74a08f2af33918bb53122"); // 1230000
 
         consensus.nMinRCTOutputDepth = 12;
 
@@ -791,14 +792,15 @@ class CTestNetParams : public CChainParams {
                 {1044185, uint256S("0xc8b34db63fb6ec97b557a969065e56167030c36c12b7c988561736ad3a5488c0")},
                 {1086076, uint256S("0x1e74a808cc907a48cdaf6f2cf5488a54d64a186fa7d65f5f717b11a8dc37d55e")},
                 {1162920, uint256S("0x01bbfe87e90af03e6daa171611fe342403a7ebb7f4703342f34fdeb613b3ecbc")},
+                {1230000, uint256S("0xab3724205826d2e38f0a12e1938d4825e3ba6f983ee74a08f2af33918bb53122")},
             }
         };
 
         chainTxData = ChainTxData{
-            // Data from rpc: getchaintxstats 4096 01bbfe87e90af03e6daa171611fe342403a7ebb7f4703342f34fdeb613b3ecbc
-            /* nTime    */ 1659606240,
-            /* nTxCount */ 1228036,
-            /* dTxRate  */ 0.005
+            // Data from rpc: getchaintxstats 4096 ab3724205826d2e38f0a12e1938d4825e3ba6f983ee74a08f2af33918bb53122
+            /* nTime    */ 1668248144,
+            /* nTxCount */ 1295752,
+            /* dTxRate  */ 0.006
         };
     }
 };

From be50f7e89771ce9a64861c6683fb18545cfbcfce Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Tue, 20 Dec 2022 20:02:39 +0200
Subject: [PATCH 53/57] rpc: Fix listunspentblind filter by address

---
 doc/release-notes-particl.md          |  7 ++++
 src/key_io.cpp                        | 57 ++++++++++++---------------
 src/wallet/rpchdwallet.cpp            | 29 +++++++++-----
 test/functional/feature_part_blind.py | 12 +++++-
 4 files changed, 62 insertions(+), 43 deletions(-)

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index 5d0d0a115a..9f96f0a1b5 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -1,3 +1,10 @@
+
+0.21.2.12
+==============
+
+- rpc: Fix listunspentblind filter by address
+
+
 0.21.2.11
 ==============
 
diff --git a/src/key_io.cpp b/src/key_io.cpp
index 765be03baa..2c4c81ed29 100644
--- a/src/key_io.cpp
+++ b/src/key_io.cpp
@@ -605,8 +605,8 @@ bool CBitcoinAddress::IsValid(CChainParams::Base58Type prefix) const
 {
     if (m_bech32) {
         CChainParams::Base58Type prefixOut;
-        if (!Params().IsBech32Prefix(vchVersion, prefixOut)
-            || prefix != prefixOut) {
+        if (!Params().IsBech32Prefix(vchVersion, prefixOut) ||
+            prefix != prefixOut) {
             return false;
         }
 
@@ -634,16 +634,16 @@ bool CBitcoinAddress::IsValid(CChainParams::Base58Type prefix) const
     };
 
     bool fKnownVersion = vchVersion == Params().Base58Prefix(prefix);
-    if (prefix == CChainParams::EXT_PUBLIC_KEY
-        || prefix == CChainParams::EXT_SECRET_KEY)
+    if (prefix == CChainParams::EXT_PUBLIC_KEY ||
+        prefix == CChainParams::EXT_SECRET_KEY)
         return fKnownVersion && vchData.size() == BIP32_KEY_N_BYTES;
 
     if (prefix == CChainParams::STEALTH_ADDRESS) {
         return IsValidStealthAddress();
     }
 
-    if (prefix == CChainParams::PUBKEY_ADDRESS_256
-        || prefix == CChainParams::SCRIPT_ADDRESS_256)
+    if (prefix == CChainParams::PUBKEY_ADDRESS_256 ||
+        prefix == CChainParams::SCRIPT_ADDRESS_256)
         return fKnownVersion && vchData.size() == 32;
 
     bool fCorrectSize = vchData.size() == 20;
@@ -657,53 +657,46 @@ CTxDestination CBitcoinAddress::Get() const
     }
     uint160 id;
 
-    if (vchVersion == Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS)
-        || vchVersion == Params().Bech32Prefix(CChainParams::PUBKEY_ADDRESS))
-    {
+    if (vchVersion == Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS) ||
+        vchVersion == Params().Bech32Prefix(CChainParams::PUBKEY_ADDRESS)) {
         memcpy(&id, vchData.data(), 20);
         return PKHash(id);
     } else
-    if (vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS)
-        || vchVersion == Params().Bech32Prefix(CChainParams::SCRIPT_ADDRESS))
-    {
+    if (vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS) ||
+        vchVersion == Params().Bech32Prefix(CChainParams::SCRIPT_ADDRESS)) {
         memcpy(&id, vchData.data(), 20);
         return ScriptHash(id);
     } else
-    /*if (vchVersion == Params().Base58Prefix(CChainParams::EXT_SECRET_KEY)
-        || vchVersion == Params().Bech32Prefix(CChainParams::EXT_SECRET_KEY))
+    /*if (vchVersion == Params().Base58Prefix(CChainParams::EXT_SECRET_KEY) ||
+        vchVersion == Params().Bech32Prefix(CChainParams::EXT_SECRET_KEY))
     {
         CExtKeyPair kp;
         kp.DecodeV(vchData.data());
         return kp;
     } else */
-    if (vchVersion == Params().Base58Prefix(CChainParams::STEALTH_ADDRESS)
-        || vchVersion == Params().Bech32Prefix(CChainParams::STEALTH_ADDRESS))
-    {
+    if (vchVersion == Params().Base58Prefix(CChainParams::STEALTH_ADDRESS) ||
+        vchVersion == Params().Bech32Prefix(CChainParams::STEALTH_ADDRESS)) {
         CStealthAddress sx;
         if (0 == sx.FromRaw(vchData.data(), vchData.size()))
             return sx;
         return CNoDestination();
     } else
-    if (vchVersion == Params().Base58Prefix(CChainParams::EXT_PUBLIC_KEY)
-        || vchVersion == Params().Bech32Prefix(CChainParams::EXT_PUBLIC_KEY))
-    {
+    if (vchVersion == Params().Base58Prefix(CChainParams::EXT_PUBLIC_KEY) ||
+        vchVersion == Params().Bech32Prefix(CChainParams::EXT_PUBLIC_KEY)) {
         CExtPubKey kp;
         kp.Decode(vchData.data());
         return kp;
-    }
-    else
-    if (vchVersion == Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS_256)
-        || vchVersion == Params().Bech32Prefix(CChainParams::PUBKEY_ADDRESS_256))
-    {
+    } else
+    if (vchVersion == Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS_256) ||
+        vchVersion == Params().Bech32Prefix(CChainParams::PUBKEY_ADDRESS_256)) {
         return CKeyID256(*((uint256*)vchData.data()));
     } else
-    if (vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS_256)
-        || vchVersion == Params().Bech32Prefix(CChainParams::SCRIPT_ADDRESS_256))
-    {
+    if (vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS_256) ||
+        vchVersion == Params().Bech32Prefix(CChainParams::SCRIPT_ADDRESS_256)) {
         //uint256 id;
         //memcpy(&id, vchData.data(), 32);
         return CScriptID256(*((uint256*)vchData.data()));
-    };
+    }
 
     return CNoDestination();
 }
@@ -721,8 +714,9 @@ CTxDestination CBitcoinAddress::GetStakeOnly() const
 
 bool CBitcoinAddress::GetKeyID(CKeyID& keyID) const
 {
-    if (!IsValid() || vchVersion != Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS))
+    if (!IsValid() || vchVersion != Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS)) {
         return false;
+    }
     uint160 id;
     memcpy(&id, vchData.data(), 20);
     keyID = CKeyID(id);
@@ -731,8 +725,9 @@ bool CBitcoinAddress::GetKeyID(CKeyID& keyID) const
 
 bool CBitcoinAddress::GetKeyID(CKeyID256& keyID) const
 {
-    if (!IsValid() || vchVersion != Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS_256))
+    if (!IsValid() || vchVersion != Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS_256)) {
         return false;
+    }
     uint256 id;
     memcpy(&id, vchData.data(), 32);
     keyID = CKeyID256(id);
diff --git a/src/wallet/rpchdwallet.cpp b/src/wallet/rpchdwallet.cpp
index 0f1a81dc02..43d613a91d 100644
--- a/src/wallet/rpchdwallet.cpp
+++ b/src/wallet/rpchdwallet.cpp
@@ -4972,24 +4972,24 @@ static UniValue listunspentblind(const JSONRPCRequest &request)
         }
     }
 
-    std::set<CBitcoinAddress> setAddress;
+    std::set<CTxDestination> setAddress;
     if (request.params.size() > 2 && !request.params[2].isNull()) {
         RPCTypeCheckArgument(request.params[2], UniValue::VARR);
         UniValue inputs = request.params[2].get_array();
         for (unsigned int idx = 0; idx < inputs.size(); idx++) {
             const UniValue& input = inputs[idx];
             CBitcoinAddress address(input.get_str());
-            if (!address.IsValidStealthAddress()) {
-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string("Invalid Particl stealth address: ")+input.get_str());
+            if (!address.IsValidStealthAddress() && !address.IsValid()) {
+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string("Invalid Particl address or stealth address: ")+input.get_str());
             }
-            if (setAddress.count(address)) {
+            if (setAddress.count(address.Get())) {
                 throw JSONRPCError(RPC_INVALID_PARAMETER, std::string("Invalid parameter, duplicated address: ")+input.get_str());
             }
-           setAddress.insert(address);
+           setAddress.insert(address.Get());
         }
     }
 
-    bool include_unsafe = true;
+    bool include_unsafe{true};
     if (request.params.size() > 3 && !request.params[3].isNull()) {
         RPCTypeCheckArgument(request.params[3], UniValue::VBOOL);
         include_unsafe = request.params[3].get_bool();
@@ -5024,21 +5024,23 @@ static UniValue listunspentblind(const JSONRPCRequest &request)
 
         CAmount nValue = pout->nValue;
 
+        bool address_is_whitelisted{false};
         CTxDestination address;
         const CScript *scriptPubKey = &pout->scriptPubKey;
         bool fValidAddress = ExtractDestination(*scriptPubKey, address);
         bool reused = avoid_reuse && pwallet->IsSpentKey(out.txhash, out.i);
-        if (setAddress.size() && (!fValidAddress || !setAddress.count(CBitcoinAddress(address))))
-            continue;
+        if (fValidAddress && setAddress.count(address)) {
+            address_is_whitelisted = true;
+        }
 
         UniValue entry(UniValue::VOBJ);
         entry.pushKV("txid", out.txhash.GetHex());
         entry.pushKV("vout", out.i);
 
         if (fValidAddress) {
-            entry.pushKV("address", CBitcoinAddress(address).ToString());
+            entry.pushKV("address", EncodeDestination(address));
 
-            auto i = pwallet->m_address_book.find(address);
+            const auto i = pwallet->m_address_book.find(address);
             if (i != pwallet->m_address_book.end()) {
                 entry.pushKV("label", i->second.GetLabel());
             }
@@ -5054,6 +5056,9 @@ static UniValue listunspentblind(const JSONRPCRequest &request)
                             entry.pushKV("label", i->second.GetLabel());
                         }
                     }
+                    if (!address_is_whitelisted && setAddress.count(sx)) {
+                        address_is_whitelisted = true;
+                    }
                 }
             }
 
@@ -5074,6 +5079,10 @@ static UniValue listunspentblind(const JSONRPCRequest &request)
             }
         }
 
+        if (setAddress.size() && !address_is_whitelisted) {
+            continue;
+        }
+
         entry.pushKV("scriptPubKey", HexStr(*scriptPubKey));
 
         if (fCCFormat) {
diff --git a/test/functional/feature_part_blind.py b/test/functional/feature_part_blind.py
index b71cea6e36..a658e4352a 100755
--- a/test/functional/feature_part_blind.py
+++ b/test/functional/feature_part_blind.py
@@ -94,7 +94,6 @@ def run_test(self):
         assert(isclose(e['amount'], 0.2))
         assert(e['stealth_address'] == sxAddrTo2_1)
 
-
         txnHash4 = nodes[1].sendblindtopart(sxAddrTo2_1, 0.5, '', '', False, 'node1 -> node2 b->p')
 
         ro = nodes[1].getwalletinfo()
@@ -119,7 +118,6 @@ def run_test(self):
         assert(len(ro) == 2)
 
 
-
         sxAddrTo2_3 = nodes[2].getnewstealthaddress('n2 sx+prefix', '4', '0xaaaa')
         ro = nodes[2].validateaddress(sxAddrTo2_3)
         assert(ro['isvalid'] == True)
@@ -134,6 +132,16 @@ def run_test(self):
         ro = nodes[2].listtransactions()
         assert(ro[-1]['txid'] == txnHash5)
 
+        self.log.info('Test listunspentblind address filtering')
+        unspents = nodes[2].listunspentblind(0, 9999, [sxAddrTo2_1])
+        assert (len(unspents) == 1)
+        assert (unspents[0]['txid'] == txnHash3)
+        unspents = nodes[2].listunspentblind(0, 9999, [unspents[0]['address']])
+        assert (len(unspents) == 1)
+        assert (unspents[0]['txid'] == txnHash3)
+        unspents = nodes[2].listunspentblind(0, 9999)
+        assert (len(unspents) > 1)
+
         ro = nodes[0].getwalletinfo()
         # Some of the balance will have staked
         assert(isclose(ro['balance'] + ro['staked_balance'], 99996.09874074))

From df7d8fd3d218fcada82007fd584850bf6603d2b7 Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Wed, 21 Dec 2022 16:27:17 +0200
Subject: [PATCH 54/57] usbdevice: Add Ledger Nano S Plus PID.

---
 doc/release-notes-particl.md |  1 +
 src/usbdevice/usbdevice.cpp  | 26 +++++++++++++++-----------
 src/usbdevice/usbdevice.h    |  3 ++-
 3 files changed, 18 insertions(+), 12 deletions(-)

diff --git a/doc/release-notes-particl.md b/doc/release-notes-particl.md
index 9f96f0a1b5..461a98b191 100644
--- a/doc/release-notes-particl.md
+++ b/doc/release-notes-particl.md
@@ -3,6 +3,7 @@
 ==============
 
 - rpc: Fix listunspentblind filter by address
+- Added new PID for Ledger Nano S Plus (5015).
 
 
 0.21.2.11
diff --git a/src/usbdevice/usbdevice.cpp b/src/usbdevice/usbdevice.cpp
index a9f63dbd95..8602a86a39 100644
--- a/src/usbdevice/usbdevice.cpp
+++ b/src/usbdevice/usbdevice.cpp
@@ -1,4 +1,4 @@
-// Copyright (c) 2018-2020 The Particl Core developers
+// Copyright (c) 2018-2022 The Particl Core developers
 // Distributed under the MIT/X11 software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
@@ -31,6 +31,7 @@ const DeviceType usbDeviceTypes[] = {
     DeviceType(0x2c97, 0x1015, "Ledger",    "Nano S 1.6",   USBDEVICE_LEDGER_NANO_S),
     DeviceType(0x2c97, 0x0004, "Ledger",    "Nano X",       USBDEVICE_LEDGER_NANO_X),
     DeviceType(0x2c97, 0x4015, "Ledger",    "Nano X 1.6",   USBDEVICE_LEDGER_NANO_X),
+    DeviceType(0x2c97, 0x5015, "Ledger",    "Nano S Plus",  USBDEVICE_LEDGER_NANO_S_PLUS),
     //DeviceType(0x534c, 0x0001, "Trezor", "One", USBDEVICE_TREZOR_ONE),
 };
 
@@ -97,20 +98,23 @@ void ListHIDDevices(std::vector<std::unique_ptr<CUSBDevice> > &vDevices)
     while (cur_dev) {
         if (cur_dev->serial_number) // Possibly no access permission, check udev rules.
         for (const auto &type : usbDeviceTypes) {
-            if (cur_dev->vendor_id != type.nVendorId
-                || cur_dev->product_id != type.nProductId) {
+            if (cur_dev->vendor_id != type.nVendorId ||
+                cur_dev->product_id != type.nProductId) {
                 continue;
             }
 
-            if ((type.type == USBDEVICE_LEDGER_BLUE || type.type == USBDEVICE_LEDGER_NANO_S || type.type == USBDEVICE_LEDGER_NANO_X)
-                && MatchLedgerInterface(cur_dev)) {
+            if ((type.type == USBDEVICE_LEDGER_BLUE ||
+                 type.type == USBDEVICE_LEDGER_NANO_S ||
+                 type.type == USBDEVICE_LEDGER_NANO_X ||
+                 type.type == USBDEVICE_LEDGER_NANO_S_PLUS) &&
+                MatchLedgerInterface(cur_dev)) {
                 char mbs[128];
                 wcstombs(mbs, cur_dev->serial_number, sizeof(mbs));
                 std::unique_ptr<CUSBDevice> device(new CLedgerDevice(&type, cur_dev->path, mbs, cur_dev->interface_number));
                 vDevices.push_back(std::move(device));
             } else
-            if (type.type == USBDEVICE_TREZOR_ONE
-                && MatchTrezorInterface(cur_dev)) {
+            if (type.type == USBDEVICE_TREZOR_ONE &&
+                MatchTrezorInterface(cur_dev)) {
                 char mbs[128];
                 wcstombs(mbs, cur_dev->serial_number, sizeof(mbs));
                 std::unique_ptr<CUSBDevice> device(new CTrezorDevice(&type, cur_dev->path, mbs, cur_dev->interface_number));
@@ -138,13 +142,13 @@ void ListWebUSBDevices(std::vector<std::unique_ptr<CUSBDevice> > &vDevices)
     while (cur_dev) {
         if (cur_dev->serial_number) // Possibly no access permission, check udev rules.
         for (const auto &type : webusbDeviceTypes) {
-            if (cur_dev->vendor_id != type.nVendorId
-                || cur_dev->product_id != type.nProductId) {
+            if (cur_dev->vendor_id != type.nVendorId ||
+                cur_dev->product_id != type.nProductId) {
                 continue;
             }
 
-            if (type.type == USBDEVICE_TREZOR_ONE
-                && cur_dev->interface_number == 0) {
+            if (type.type == USBDEVICE_TREZOR_ONE &&
+                cur_dev->interface_number == 0) {
                 char mbs[128];
                 wcstombs(mbs, cur_dev->serial_number, sizeof(mbs));
                 std::unique_ptr<CUSBDevice> device(new CTrezorDevice(&type, cur_dev->path, mbs, cur_dev->interface_number));
diff --git a/src/usbdevice/usbdevice.h b/src/usbdevice/usbdevice.h
index 78bb433f9a..85ea9aaa1d 100644
--- a/src/usbdevice/usbdevice.h
+++ b/src/usbdevice/usbdevice.h
@@ -1,4 +1,4 @@
-// Copyright (c) 2018-2021 The Particl Core developers
+// Copyright (c) 2018-2022 The Particl Core developers
 // Distributed under the MIT/X11 software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
 
@@ -28,6 +28,7 @@ enum DeviceTypeID {
     USBDEVICE_TREZOR_ONE = 2,
     USBDEVICE_LEDGER_BLUE = 3,
     USBDEVICE_LEDGER_NANO_X = 4,
+    USBDEVICE_LEDGER_NANO_S_PLUS = 5,
     USBDEVICE_SIZE,
 };
 

From f0fdf2d907e60eef74e76168fb048f0c8e602dae Mon Sep 17 00:00:00 2001
From: tecnovert <tecnovert@tecnovert.net>
Date: Wed, 21 Dec 2022 20:00:53 +0200
Subject: [PATCH 55/57] tests: Disable openssl tests.

test_ecdsa_der_parse fails with openssl 3.0
---
 configure.ac | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/configure.ac b/configure.ac
index ec3d8a9a7d..1dd3cb0d4a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1831,7 +1831,7 @@ if test x$need_bundled_univalue = xyes; then
   AC_CONFIG_SUBDIRS([src/univalue])
 fi
 
-ac_configure_args="${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery --enable-module-schnorrsig --enable-experimental --enable-module-ecdh --enable-module-commitment --enable-module-rangeproof --enable-module-bulletproof --enable-module-generator --enable-module-mlsag --enable-endomorphism"
+ac_configure_args="${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery --enable-module-schnorrsig --enable-experimental --enable-module-ecdh --enable-module-commitment --enable-module-rangeproof --enable-module-bulletproof --enable-module-generator --enable-module-mlsag --enable-endomorphism --disable-openssl-tests"
 AC_CONFIG_SUBDIRS([src/secp256k1])
 
 AC_OUTPUT

From 2e19376d5b25edae2b49514afe314bb9d54e6702 Mon Sep 17 00:00:00 2001
From: Sonkeng Maldini <sdmg15@pm.me>
Date: Fri, 21 Jul 2023 20:39:54 +0100
Subject: [PATCH 57/57] fix compilation

---
 src/chainparams.cpp    | 3 +--
 src/consensus/params.h | 2 ++
 src/init.cpp           | 2 +-
 3 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/src/chainparams.cpp b/src/chainparams.cpp
index 52bf79bfde..3779e0b6eb 100644
--- a/src/chainparams.cpp
+++ b/src/chainparams.cpp
@@ -103,7 +103,6 @@ int64_t CChainParams::GetMaxSmsgFeeRateDelta(int64_t smsg_fee_prev, int64_t time
 CAmount CChainParams::GetBaseBlockReward() const
 {
     return nBlockReward;
-    return std::max((int64_t)1, max_delta);
 };
 
 CAmount CChainParams::GetProofOfStakeRewardAtYear(const int year) const
@@ -1271,4 +1270,4 @@ std::set<std::uint64_t> GetAnonIndexFromString(const std::string& str) {
         internal.insert( std::stoll(tok) );
     }
     return internal;
-}
+}
\ No newline at end of file
diff --git a/src/consensus/params.h b/src/consensus/params.h
index 05a6ce2dd5..859f6ebe05 100644
--- a/src/consensus/params.h
+++ b/src/consensus/params.h
@@ -104,6 +104,8 @@ struct Params {
     int m_frozen_blinded_height = 0;
     /** Maximum value of tainted blinded output that can be spent without being whitelisted */
     int64_t m_max_tainted_value_out = 200LL * 100000000LL /* COIN */;
+    /** Fix GetMaxSmsgFeeRateDelta */
+    uint32_t smsg_fee_rate_fix_time = 0xffffffff; /* TODO: Remove after fork */
     /** Time taproot activates on Particl chain */
     uint32_t m_taproot_time = 0xffffffff;
 
diff --git a/src/init.cpp b/src/init.cpp
index 969bfecb18..6cfc69dba1 100644
--- a/src/init.cpp
+++ b/src/init.cpp
@@ -560,7 +560,7 @@ void SetupServerArgs(NodeContext& node)
     argsman.AddArg("-findpeers", "Node will search for peers (default: 1)", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
 
     argsman.AddArg("-lookuptorcontrolhost=<protocol>", strprintf("Allow a hostname to be specified for the -torcontrol option. Must be \"any\", \"ipv4\", or \"ipv6\" (default: %s)", ""), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);
-    argsman.AddArg("-automaticbans", strprintf("Whether to automatically ban misbehaving nodes. (default: %u)", ghost::DEFAULT_AUTOMATIC_BANS), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
+    argsman.AddArg("-automaticbans", strprintf("Whether to automatically ban misbehaving nodes. (default: %u)", particl::DEFAULT_AUTOMATIC_BANS), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);
     // end Ghost specific
 
     argsman.AddArg("-addnode=<ip>", "Add a node to connect to and attempt to keep the connection open (see the `addnode` RPC command help for more info). This option can be specified multiple times to add multiple nodes.", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);
